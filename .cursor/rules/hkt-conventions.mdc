---
description: HKT (Higher-Kinded Type) conventions for typesugar
globs: ["packages/*/src/**/*.ts", "src/**/*.ts"]
alwaysApply: false
---

# HKT Conventions

## Syntax

- TypeScript HKT uses angle brackets: `F<_>` — NEVER Scala's square brackets `F[_]`
- The `@hkt` macro and transformer auto-detect `F<_>` syntax and rewrite `F<A>` to `$<F, A>`
- Current codebase convention: write `$<F, A>` explicitly (both `@typesugar/fp` and `@typesugar/collections` do this)

## Type-Level Functions

A type-level function is an interface whose `_` property uses `this["_"]`:

```typescript
// CORRECT — parameterized, sound
interface ArrayF {
  _: Array<this["_"]>;
}
interface SetF {
  _: Set<this["_"]>;
}
interface MapF<K> {
  _: Map<K, this["_"]>;
}

// WRONG — phantom type, $<StringF, B> = string for ALL B
interface StringF {
  _: string;
}
```

### Rules

1. The `_` property MUST reference `this["_"]` for the encoding to be sound
2. If `$<F, A>` resolves to the same type for all `A`, the type is phantom/unsound
3. Phantom HKT types must NOT implement typeclasses that change the element type (Functor.map, Monad.flatMap, Iterable.map, Seq.zip, etc.)
4. Phantom HKT types MAY implement read-only typeclasses (IterableOnce, Foldable) where the output type doesn't depend on HKT application
5. Never use `as unknown as` to paper over HKT type mismatches — it means the type-level function definition is wrong

## Dictionary-Passing Style

All derived operations take the typeclass dictionary as the first argument:

```typescript
// CORRECT — works with specialize() for zero-cost
function map<F>(F: Functor<F>): <A, B>(fa: $<F, A>, f: (a: A) => B) => $<F, B> {
  return (fa, f) => F.map(fa, f);
}

// WRONG — can't be specialized, dictionary not explicit
function map<F, A, B>(fa: $<F, A>, f: (a: A) => B): $<F, B> { ... }
```

## Multi-Arity Type Constructors

Fix all type parameters except one (the one that varies):

```typescript
interface MapF<K> {
  _: Map<K, this["_"]>;
} // varies V
interface EitherF<E> {
  _: Either<E, this["_"]>;
} // varies A
```

## Common Mistakes

1. Writing `F[_]` instead of `F<_>` (Scala vs TypeScript syntax)
2. Forgetting `this["_"]` in type-level function definitions
3. Implementing Functor/map for types that can't change their element type
4. Using `as unknown as` casts instead of fixing the HKT encoding
5. Not testing that `$<F, DifferentType>` actually resolves to a different concrete type
