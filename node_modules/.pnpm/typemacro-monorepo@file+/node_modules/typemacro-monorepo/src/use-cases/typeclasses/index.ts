/**
 * Typeclasses Use Case - Scala 3-like Typeclasses with Auto-Derivation
 *
 * This demonstrates the full typeclass system:
 *
 * 1. Defining typeclasses with @typeclass
 * 2. Providing primitive instances with @instance
 * 3. Auto-deriving instances for product types with @deriving
 * 4. Auto-deriving instances for sum types (discriminated unions)
 * 5. Extension methods via extend()
 * 6. Implicit resolution via summon<TC<A>>()
 * 7. Typeclass-based generic programming
 *
 * ## Scala 3 Comparison
 *
 * Scala 3:
 *   trait Show[A]:
 *     extension (a: A) def show: String
 *
 *   given Show[Int] with
 *     extension (a: Int) def show = a.toString
 *
 *   case class Point(x: Int, y: Int) derives Show, Eq, Ord
 *
 *   val p = Point(1, 2)
 *   println(p.show)  // "Point(x = 1, y = 2)"
 *
 * typemacro equivalent:
 *   @typeclass
 *   interface Show<A> {
 *     show(a: A): string;
 *   }
 *
 *   @instance("number")
 *   const showNumber: Show<number> = { show: (a) => String(a) };
 *
 *   @deriving(Show, Eq, Ord)
 *   interface Point { x: number; y: number; }
 *
 *   const p: Point = { x: 1, y: 2 };
 *   extend(p).show();  // "Point(x = 1, y = 2)"
 */

// ============================================================================
// 1. Define Typeclasses
// ============================================================================

/**
 * Show typeclass - convert values to human-readable strings.
 *
 * Scala 3 equivalent:
 *   trait Show[A]:
 *     extension (a: A) def show: String
 */
// @typeclass  (processed by macro transformer)
export interface Show<A> {
  show(a: A): string;
}

/**
 * Eq typeclass - structural equality.
 *
 * Scala 3 equivalent:
 *   trait Eq[A]:
 *     extension (a: A)
 *       def eq(b: A): Boolean
 *       def neq(b: A): Boolean = !a.eq(b)
 */
// @typeclass
export interface Eq<A> {
  eq(a: A, b: A): boolean;
  neq(a: A, b: A): boolean;
}

/**
 * Ord typeclass - total ordering.
 *
 * Scala 3 equivalent:
 *   trait Ord[A] extends Eq[A]:
 *     extension (a: A) def compare(b: A): Int
 */
// @typeclass
export interface Ord<A> {
  compare(a: A, b: A): -1 | 0 | 1;
}

/**
 * Hash typeclass - compute hash codes.
 */
// @typeclass
export interface Hash<A> {
  hash(a: A): number;
}

/**
 * Semigroup typeclass - associative binary operation.
 *
 * Scala 3 equivalent:
 *   trait Semigroup[A]:
 *     extension (a: A) def combine(b: A): A
 */
// @typeclass
export interface Semigroup<A> {
  combine(a: A, b: A): A;
}

/**
 * Monoid typeclass - semigroup with identity element.
 *
 * Scala 3 equivalent:
 *   trait Monoid[A] extends Semigroup[A]:
 *     def empty: A
 */
// @typeclass
export interface Monoid<A> {
  empty(): A;
  combine(a: A, b: A): A;
}

/**
 * Functor typeclass - mappable containers.
 *
 * Scala 3 equivalent:
 *   trait Functor[F[_]]:
 *     extension [A](fa: F[A]) def map[B](f: A => B): F[B]
 */
// @typeclass
export interface Functor<F> {
  map<A, B>(fa: F, f: (a: A) => B): F;
}

// ============================================================================
// 2. Primitive Instances
// ============================================================================

// --- Show ---
export const showNumber: Show<number> = {
  show: (a) => String(a),
};

export const showString: Show<string> = {
  show: (a) => JSON.stringify(a),
};

export const showBoolean: Show<boolean> = {
  show: (a) => String(a),
};

// --- Eq ---
export const eqNumber: Eq<number> = {
  eq: (a, b) => a === b,
  neq: (a, b) => a !== b,
};

export const eqString: Eq<string> = {
  eq: (a, b) => a === b,
  neq: (a, b) => a !== b,
};

export const eqBoolean: Eq<boolean> = {
  eq: (a, b) => a === b,
  neq: (a, b) => a !== b,
};

// --- Ord ---
export const ordNumber: Ord<number> = {
  compare: (a, b) => (a < b ? -1 : a > b ? 1 : 0),
};

export const ordString: Ord<string> = {
  compare: (a, b) => (a < b ? -1 : a > b ? 1 : 0),
};

// --- Hash ---
export const hashNumber: Hash<number> = {
  hash: (a) => a | 0,
};

export const hashString: Hash<string> = {
  hash: (a) => {
    let h = 5381;
    for (let i = 0; i < a.length; i++) {
      h = (h << 5) + h + a.charCodeAt(i);
    }
    return h >>> 0;
  },
};

export const hashBoolean: Hash<boolean> = {
  hash: (a) => (a ? 1 : 0),
};

// --- Semigroup ---
export const semigroupNumber: Semigroup<number> = {
  combine: (a, b) => a + b,
};

export const semigroupString: Semigroup<string> = {
  combine: (a, b) => a + b,
};

// --- Monoid ---
export const monoidNumber: Monoid<number> = {
  empty: () => 0,
  combine: (a, b) => a + b,
};

export const monoidString: Monoid<string> = {
  empty: () => "",
  combine: (a, b) => a + b,
};

// ============================================================================
// 3. Instance Registry (runtime, mirrors compile-time macro expansion)
// ============================================================================

/**
 * Runtime typeclass instance registry.
 * In a full macro-expanded build, this is generated by @typeclass.
 * Here we provide it manually for demonstration.
 */
export class TypeclassRegistry<TC> {
  private instances = new Map<string, TC>();

  registerInstance<T>(typeName: string, instance: TC): void {
    this.instances.set(typeName, instance);
  }

  summon<T>(typeName: string): TC {
    const instance = this.instances.get(typeName);
    if (!instance) {
      throw new Error(`No instance found for type '${typeName}'`);
    }
    return instance;
  }

  hasInstance(typeName: string): boolean {
    return this.instances.has(typeName);
  }

  registeredTypes(): string[] {
    return Array.from(this.instances.keys());
  }
}

// Create registries for each typeclass
export const ShowRegistry = new TypeclassRegistry<Show<any>>();
export const EqRegistry = new TypeclassRegistry<Eq<any>>();
export const OrdRegistry = new TypeclassRegistry<Ord<any>>();
export const HashRegistry = new TypeclassRegistry<Hash<any>>();
export const SemigroupRegistry = new TypeclassRegistry<Semigroup<any>>();
export const MonoidRegistry = new TypeclassRegistry<Monoid<any>>();

// Register primitive instances
ShowRegistry.registerInstance("number", showNumber);
ShowRegistry.registerInstance("string", showString);
ShowRegistry.registerInstance("boolean", showBoolean);

EqRegistry.registerInstance("number", eqNumber);
EqRegistry.registerInstance("string", eqString);
EqRegistry.registerInstance("boolean", eqBoolean);

OrdRegistry.registerInstance("number", ordNumber);
OrdRegistry.registerInstance("string", ordString);

HashRegistry.registerInstance("number", hashNumber);
HashRegistry.registerInstance("string", hashString);
HashRegistry.registerInstance("boolean", hashBoolean);

SemigroupRegistry.registerInstance("number", semigroupNumber);
SemigroupRegistry.registerInstance("string", semigroupString);

MonoidRegistry.registerInstance("number", monoidNumber);
MonoidRegistry.registerInstance("string", monoidString);

// ============================================================================
// 4. Auto-Derivation Engine
// ============================================================================

/**
 * Derive a Show instance for a product type (struct/interface).
 *
 * Scala 3 equivalent:
 *   given [A: Show, B: Show]: Show[(A, B)] with
 *     extension (t: (A, B)) def show = s"(${t._1.show}, ${t._2.show})"
 */
export function deriveShowProduct<T>(
  typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Show<T> {
  return {
    show: (a: T): string => {
      const fieldStrs = fieldNames.map((name, i) => {
        const fieldValue = (a as any)[name];
        const fieldTypeName = fieldTypes[i];
        const fieldShow = ShowRegistry.summon(fieldTypeName);
        return `${name} = ${fieldShow.show(fieldValue)}`;
      });
      return `${typeName}(${fieldStrs.join(", ")})`;
    },
  };
}

/**
 * Derive an Eq instance for a product type.
 *
 * Scala 3 derivation rule: all fields must have Eq instances.
 */
export function deriveEqProduct<T>(
  _typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Eq<T> {
  return {
    eq: (a: T, b: T): boolean => {
      return fieldNames.every((name, i) => {
        const fieldTypeName = fieldTypes[i];
        const fieldEq = EqRegistry.summon(fieldTypeName);
        return fieldEq.eq((a as any)[name], (b as any)[name]);
      });
    },
    neq: (a: T, b: T): boolean => {
      return !fieldNames.every((name, i) => {
        const fieldTypeName = fieldTypes[i];
        const fieldEq = EqRegistry.summon(fieldTypeName);
        return fieldEq.eq((a as any)[name], (b as any)[name]);
      });
    },
  };
}

/**
 * Derive an Ord instance for a product type.
 * Compares fields lexicographically.
 */
export function deriveOrdProduct<T>(
  _typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Ord<T> {
  return {
    compare: (a: T, b: T): -1 | 0 | 1 => {
      for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i];
        const fieldTypeName = fieldTypes[i];
        const fieldOrd = OrdRegistry.summon(fieldTypeName);
        const cmp = fieldOrd.compare((a as any)[name], (b as any)[name]);
        if (cmp !== 0) return cmp;
      }
      return 0;
    },
  };
}

/**
 * Derive a Hash instance for a product type.
 */
export function deriveHashProduct<T>(
  _typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Hash<T> {
  return {
    hash: (a: T): number => {
      let hash = 5381;
      for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i];
        const fieldTypeName = fieldTypes[i];
        const fieldHash = HashRegistry.summon(fieldTypeName);
        hash = ((hash << 5) + hash) ^ fieldHash.hash((a as any)[name]);
      }
      return hash >>> 0;
    },
  };
}

/**
 * Derive a Semigroup instance for a product type.
 * Combines each field using its own Semigroup instance.
 */
export function deriveSemigroupProduct<T>(
  _typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Semigroup<T> {
  return {
    combine: (a: T, b: T): T => {
      const result: any = {};
      for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i];
        const fieldTypeName = fieldTypes[i];
        const fieldSemigroup = SemigroupRegistry.summon(fieldTypeName);
        result[name] = fieldSemigroup.combine(
          (a as any)[name],
          (b as any)[name],
        );
      }
      return result;
    },
  };
}

/**
 * Derive a Monoid instance for a product type.
 */
export function deriveMonoidProduct<T>(
  _typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
): Monoid<T> {
  return {
    empty: (): T => {
      const result: any = {};
      for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i];
        const fieldTypeName = fieldTypes[i];
        const fieldMonoid = MonoidRegistry.summon(fieldTypeName);
        result[name] = fieldMonoid.empty();
      }
      return result;
    },
    combine: (a: T, b: T): T => {
      const result: any = {};
      for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i];
        const fieldTypeName = fieldTypes[i];
        const fieldMonoid = MonoidRegistry.summon(fieldTypeName);
        result[name] = fieldMonoid.combine((a as any)[name], (b as any)[name]);
      }
      return result;
    },
  };
}

// ============================================================================
// 5. Sum Type Derivation
// ============================================================================

/**
 * Derive a Show instance for a sum type (discriminated union).
 *
 * Scala 3 equivalent:
 *   enum Shape derives Show:
 *     case Circle(radius: Double)
 *     case Rectangle(width: Double, height: Double)
 */
export function deriveShowSum<T>(
  _typeName: string,
  discriminant: string,
  variantMap: Record<string, string>,
): Show<T> {
  return {
    show: (a: T): string => {
      const tag = (a as any)[discriminant];
      const variantTypeName = variantMap[tag];
      if (variantTypeName && ShowRegistry.hasInstance(variantTypeName)) {
        return ShowRegistry.summon(variantTypeName).show(a);
      }
      return String(a);
    },
  };
}

/**
 * Derive an Eq instance for a sum type.
 */
export function deriveEqSum<T>(
  _typeName: string,
  discriminant: string,
  variantMap: Record<string, string>,
): Eq<T> {
  return {
    eq: (a: T, b: T): boolean => {
      const aTag = (a as any)[discriminant];
      const bTag = (b as any)[discriminant];
      if (aTag !== bTag) return false;
      const variantTypeName = variantMap[aTag];
      if (variantTypeName && EqRegistry.hasInstance(variantTypeName)) {
        return EqRegistry.summon(variantTypeName).eq(a, b);
      }
      return false;
    },
    neq: (a: T, b: T): boolean => {
      const aTag = (a as any)[discriminant];
      const bTag = (b as any)[discriminant];
      if (aTag !== bTag) return true;
      const variantTypeName = variantMap[aTag];
      if (variantTypeName && EqRegistry.hasInstance(variantTypeName)) {
        return EqRegistry.summon(variantTypeName).neq(a, b);
      }
      return true;
    },
  };
}

// ============================================================================
// 6. Extension Methods (Scala 3-like)
// ============================================================================

/**
 * Create an extension method proxy for a value.
 * This is the runtime equivalent of Scala 3's extension methods.
 *
 * Scala 3:
 *   extension [A: Show](a: A)
 *     def show: String = summon[Show[A]].show(a)
 *
 * typemacro:
 *   extend(point).show()
 *   // or after macro expansion:
 *   withExtensions(point, "Point").show()
 */
export function withExtensions<T>(
  value: T,
  typeName: string,
): T & ExtensionMethods<T> {
  return new Proxy(value as any, {
    get(target, prop, receiver) {
      // First check if the property exists on the value itself
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }

      // Then check typeclass extension methods
      const propName = String(prop);

      // Show.show
      if (propName === "show" && ShowRegistry.hasInstance(typeName)) {
        return () => ShowRegistry.summon(typeName).show(target);
      }

      // Eq.eq, Eq.neq
      if (propName === "eq" && EqRegistry.hasInstance(typeName)) {
        return (other: any) => EqRegistry.summon(typeName).eq(target, other);
      }
      if (propName === "neq" && EqRegistry.hasInstance(typeName)) {
        return (other: any) => EqRegistry.summon(typeName).neq(target, other);
      }

      // Ord.compare
      if (propName === "compare" && OrdRegistry.hasInstance(typeName)) {
        return (other: any) =>
          OrdRegistry.summon(typeName).compare(target, other);
      }

      // Hash.hash
      if (propName === "hash" && HashRegistry.hasInstance(typeName)) {
        return () => HashRegistry.summon(typeName).hash(target);
      }

      // Semigroup.combine
      if (propName === "combine" && SemigroupRegistry.hasInstance(typeName)) {
        return (other: any) =>
          SemigroupRegistry.summon(typeName).combine(target, other);
      }

      return undefined;
    },
  });
}

/**
 * Extension methods added by typeclasses.
 * This type represents the methods available via withExtensions().
 */
export interface ExtensionMethods<_T> {
  /** Show.show - convert to string representation */
  show(): string;
  /** Eq.eq - check equality */
  eq(other: _T): boolean;
  /** Eq.neq - check inequality */
  neq(other: _T): boolean;
  /** Ord.compare - compare ordering */
  compare(other: _T): -1 | 0 | 1;
  /** Hash.hash - compute hash code */
  hash(): number;
  /** Semigroup.combine - combine with another value */
  combine(other: _T): _T;
}

// ============================================================================
// 7. Convenience: derives() function for runtime derivation
// ============================================================================

/**
 * Derive and register typeclass instances for a product type.
 * This is the runtime equivalent of @deriving(Show, Eq, ...).
 *
 * @example
 * ```typescript
 * interface Point { x: number; y: number; }
 * derives<Point>("Point", ["x", "y"], ["number", "number"], [Show, Eq, Ord]);
 * ```
 */
export function derives<T>(
  typeName: string,
  fieldNames: string[],
  fieldTypes: string[],
  typeclasses: Array<"Show" | "Eq" | "Ord" | "Hash" | "Semigroup" | "Monoid">,
): void {
  for (const tc of typeclasses) {
    switch (tc) {
      case "Show": {
        const instance = deriveShowProduct<T>(typeName, fieldNames, fieldTypes);
        ShowRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Eq": {
        const instance = deriveEqProduct<T>(typeName, fieldNames, fieldTypes);
        EqRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Ord": {
        const instance = deriveOrdProduct<T>(typeName, fieldNames, fieldTypes);
        OrdRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Hash": {
        const instance = deriveHashProduct<T>(typeName, fieldNames, fieldTypes);
        HashRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Semigroup": {
        const instance = deriveSemigroupProduct<T>(
          typeName,
          fieldNames,
          fieldTypes,
        );
        SemigroupRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Monoid": {
        const instance = deriveMonoidProduct<T>(
          typeName,
          fieldNames,
          fieldTypes,
        );
        MonoidRegistry.registerInstance(typeName, instance);
        break;
      }
    }
  }
}

/**
 * Derive and register typeclass instances for a sum type.
 */
export function derivesSum<T>(
  typeName: string,
  discriminant: string,
  variantMap: Record<string, string>,
  typeclasses: Array<"Show" | "Eq">,
): void {
  for (const tc of typeclasses) {
    switch (tc) {
      case "Show": {
        const instance = deriveShowSum<T>(typeName, discriminant, variantMap);
        ShowRegistry.registerInstance(typeName, instance);
        break;
      }
      case "Eq": {
        const instance = deriveEqSum<T>(typeName, discriminant, variantMap);
        EqRegistry.registerInstance(typeName, instance);
        break;
      }
    }
  }
}

// ============================================================================
// 8. Generic Programming with Typeclasses
// ============================================================================

/**
 * Sort an array using the Ord typeclass.
 *
 * Scala 3 equivalent:
 *   def sorted[A: Ord](xs: List[A]): List[A] = xs.sorted
 */
export function sorted<T>(xs: T[], typeName: string): T[] {
  const ord = OrdRegistry.summon<T>(typeName);
  return [...xs].sort((a, b) => ord.compare(a, b));
}

/**
 * Find the minimum element using Ord.
 */
export function minimum<T>(xs: T[], typeName: string): T | undefined {
  if (xs.length === 0) return undefined;
  const ord = OrdRegistry.summon<T>(typeName);
  return xs.reduce((min, x) => (ord.compare(x, min) < 0 ? x : min));
}

/**
 * Find the maximum element using Ord.
 */
export function maximum<T>(xs: T[], typeName: string): T | undefined {
  if (xs.length === 0) return undefined;
  const ord = OrdRegistry.summon<T>(typeName);
  return xs.reduce((max, x) => (ord.compare(x, max) > 0 ? x : max));
}

/**
 * Combine all elements using Monoid.
 *
 * Scala 3 equivalent:
 *   def combineAll[A: Monoid](xs: List[A]): A =
 *     xs.foldLeft(Monoid[A].empty)(Monoid[A].combine)
 */
export function combineAll<T>(xs: T[], typeName: string): T {
  const monoid = MonoidRegistry.summon<T>(typeName);
  return xs.reduce((acc, x) => monoid.combine(acc, x), monoid.empty());
}

/**
 * Deduplicate using Eq.
 */
export function distinct<T>(xs: T[], typeName: string): T[] {
  const eq = EqRegistry.summon<T>(typeName);
  const result: T[] = [];
  for (const x of xs) {
    if (!result.some((r) => eq.eq(r, x))) {
      result.push(x);
    }
  }
  return result;
}

/**
 * Group by a key function, using Show for the key representation.
 */
export function groupBy<T, K>(
  xs: T[],
  keyFn: (x: T) => K,
  keyTypeName: string,
): Map<string, T[]> {
  const keyShow = ShowRegistry.summon<K>(keyTypeName);
  const groups = new Map<string, T[]>();
  for (const x of xs) {
    const key = keyShow.show(keyFn(x));
    const group = groups.get(key) ?? [];
    group.push(x);
    groups.set(key, group);
  }
  return groups;
}
