// src/index.ts
import * as ts from "typescript";
import * as vm from "vm";
import {
  defineExpressionMacro,
  globalRegistry
} from "@typemacro/core";
var COMPTIME_TIMEOUT_MS = 5e3;
var comptimeMacro = defineExpressionMacro({
  name: "comptime",
  module: "@typemacro/comptime",
  description: "Evaluate an expression at compile time",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "comptime expects exactly one argument");
      return callExpr;
    }
    const arg = args[0];
    if (ts.isArrowFunction(arg) || ts.isFunctionExpression(arg)) {
      return evaluateViaVm(ctx, arg, callExpr);
    }
    const result = ctx.evaluate(arg);
    if (result.kind === "error") {
      return evaluateViaVm(ctx, arg, callExpr);
    }
    return ctx.comptimeValueToExpression(result);
  }
});
function evaluateViaVm(ctx, node, callExpr) {
  const sourceText = node.getText ? node.getText() : nodeToString(node, ctx);
  const isFunction = ts.isArrowFunction(node) || ts.isFunctionExpression(node);
  const codeToEval = isFunction ? `(${sourceText})()` : `(${sourceText})`;
  const { outputText, diagnostics } = ts.transpileModule(codeToEval, {
    compilerOptions: {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.CommonJS,
      strict: false,
      removeComments: true
    },
    reportDiagnostics: true
  });
  if (diagnostics && diagnostics.length > 0) {
    const messages = diagnostics.map(
      (d) => ts.flattenDiagnosticMessageText(d.messageText, "\n")
    );
    ctx.reportError(
      callExpr,
      `Cannot transpile comptime expression: ${messages.join("; ")}`
    );
    return callExpr;
  }
  const cleanedJs = outputText.replace(/^"use strict";\s*/, "").replace(/\s*Object\.defineProperty\(exports.*\n?/g, "").replace(/\s*exports\.\S+ = void 0;\s*/g, "");
  try {
    const sandbox = createComptimeSandbox();
    const context = vm.createContext(sandbox);
    const result = vm.runInContext(cleanedJs, context, {
      timeout: COMPTIME_TIMEOUT_MS,
      filename: "comptime-eval.js"
    });
    return jsValueToExpression(ctx, result, callExpr);
  } catch (error) {
    ctx.reportError(
      callExpr,
      formatComptimeError(error, sourceText, ctx, callExpr)
    );
    return callExpr;
  }
}
function formatComptimeError(error, sourceText, ctx, callExpr) {
  const rawMessage = error instanceof Error ? error.message : String(error);
  const sourceFile = ctx.sourceFile;
  const start = callExpr.getStart(sourceFile);
  const { line, character } = sourceFile.getLineAndCharacterOfPosition(start);
  const location = `${sourceFile.fileName}:${line + 1}:${character + 1}`;
  const maxSnippetLen = 200;
  const snippet = sourceText.length > maxSnippetLen ? sourceText.slice(0, maxSnippetLen) + "..." : sourceText;
  let hint = "";
  if (rawMessage.includes("Script execution timed out")) {
    hint = `
  Hint: The expression took longer than ${COMPTIME_TIMEOUT_MS}ms to evaluate. Check for infinite loops or very expensive computations.`;
  } else if (rawMessage.includes("is not defined") || rawMessage.includes("is not a function")) {
    const match = rawMessage.match(/(\w+) is not (defined|a function)/);
    const name = match?.[1] ?? "unknown";
    hint = `
  Hint: '${name}' is not available in the comptime sandbox. Only safe built-ins (Math, JSON, Array, etc.) are accessible. File I/O, network, and process access are intentionally blocked.`;
  } else if (rawMessage.includes("Cannot read properties of")) {
    hint = "\n  Hint: A null/undefined value was accessed. Check that all variables are properly initialized.";
  }
  return `Compile-time evaluation failed at ${location}
  Source: comptime(${snippet})
  Error: ${rawMessage}${hint}`;
}
function createComptimeSandbox() {
  return {
    // Safe built-ins
    Math,
    Number,
    String,
    Boolean,
    Array,
    Object,
    Map,
    Set,
    WeakMap,
    WeakSet,
    JSON,
    Date,
    RegExp,
    Error,
    TypeError,
    RangeError,
    SyntaxError,
    parseInt,
    parseFloat,
    isNaN,
    isFinite,
    NaN: NaN,
    Infinity: Infinity,
    undefined: void 0,
    // Console for debugging (output goes to build log)
    console: {
      log: (...args) => console.log("[comptime]", ...args),
      warn: (...args) => console.warn("[comptime]", ...args),
      error: (...args) => console.error("[comptime]", ...args)
    }
  };
}
function jsValueToExpression(ctx, value, errorNode) {
  if (value === null) {
    return ctx.factory.createNull();
  }
  if (value === void 0) {
    return ctx.factory.createIdentifier("undefined");
  }
  if (typeof value === "number") {
    if (value < 0) {
      return ctx.factory.createPrefixUnaryExpression(
        ts.SyntaxKind.MinusToken,
        ctx.factory.createNumericLiteral(Math.abs(value))
      );
    }
    if (!isFinite(value)) {
      return ctx.factory.createIdentifier(value > 0 ? "Infinity" : "-Infinity");
    }
    if (isNaN(value)) {
      return ctx.factory.createIdentifier("NaN");
    }
    return ctx.factory.createNumericLiteral(value);
  }
  if (typeof value === "string") {
    return ctx.factory.createStringLiteral(value);
  }
  if (typeof value === "boolean") {
    return value ? ctx.factory.createTrue() : ctx.factory.createFalse();
  }
  if (typeof value === "bigint") {
    return ctx.factory.createBigIntLiteral(value.toString());
  }
  if (Array.isArray(value)) {
    const elements = value.map((el) => jsValueToExpression(ctx, el, errorNode));
    return ctx.factory.createArrayLiteralExpression(elements);
  }
  if (value instanceof RegExp) {
    return ctx.factory.createCallExpression(
      ctx.factory.createIdentifier("RegExp"),
      void 0,
      [
        ctx.factory.createStringLiteral(value.source),
        ctx.factory.createStringLiteral(value.flags)
      ]
    );
  }
  if (typeof value === "object") {
    const properties = [];
    for (const [key, val] of Object.entries(value)) {
      properties.push(
        ctx.factory.createPropertyAssignment(
          /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? ctx.factory.createIdentifier(key) : ctx.factory.createStringLiteral(key),
          jsValueToExpression(ctx, val, errorNode)
        )
      );
    }
    return ctx.factory.createObjectLiteralExpression(properties, true);
  }
  ctx.reportError(
    errorNode,
    `Cannot serialize comptime result of type ${typeof value} to AST`
  );
  return ctx.factory.createIdentifier("undefined");
}
function nodeToString(node, ctx) {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  return printer.printNode(ts.EmitHint.Expression, node, ctx.sourceFile);
}
function jsToComptimeValue(value) {
  if (value === null) return { kind: "null" };
  if (value === void 0) return { kind: "undefined" };
  if (typeof value === "number") return { kind: "number", value };
  if (typeof value === "string") return { kind: "string", value };
  if (typeof value === "boolean") return { kind: "boolean", value };
  if (Array.isArray(value)) {
    return { kind: "array", elements: value.map(jsToComptimeValue) };
  }
  if (typeof value === "object") {
    const properties = /* @__PURE__ */ new Map();
    for (const [k, v] of Object.entries(value)) {
      properties.set(k, jsToComptimeValue(v));
    }
    return { kind: "object", properties };
  }
  return {
    kind: "error",
    message: `Cannot convert ${typeof value} to ComptimeValue`
  };
}
function register() {
  globalRegistry.register(comptimeMacro);
}
register();
export {
  comptimeMacro,
  jsToComptimeValue,
  register
};
//# sourceMappingURL=index.js.map