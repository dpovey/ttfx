{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * comptime macro - Evaluate expressions at compile time\n *\n * Inspired by Zig's comptime keyword, this macro evaluates expressions\n * during compilation and replaces them with their computed values.\n *\n * Uses Node's vm module to execute transpiled TypeScript in a sandbox,\n * giving full JavaScript semantics (closures, recursion, all operators,\n * built-in methods) without maintaining a custom interpreter.\n *\n * Usage:\n *   const x = comptime(() => 5 * 5);           // becomes: const x = 25;\n *   const factorial5 = comptime(() => {\n *     let result = 1;\n *     for (let i = 1; i <= 5; i++) result *= i;\n *     return result;\n *   });                                         // becomes: const factorial5 = 120;\n */\n\nimport * as ts from \"typescript\";\nimport * as vm from \"node:vm\";\nimport {\n  defineExpressionMacro,\n  globalRegistry,\n  MacroContext,\n  MacroContextImpl,\n  ComptimeValue,\n} from \"@typemacro/core\";\n\n/** Maximum execution time for comptime evaluation (ms) */\nconst COMPTIME_TIMEOUT_MS = 5000;\n\n/** Maximum iteration limit hint (for documentation; actual enforcement is via timeout) */\nconst MAX_ITERATIONS = 100_000;\n\nexport const comptimeMacro = defineExpressionMacro({\n  name: \"comptime\",\n  module: \"@typemacro/comptime\",\n  description: \"Evaluate an expression at compile time\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"comptime expects exactly one argument\");\n      return callExpr;\n    }\n\n    const arg = args[0];\n\n    // If it's an arrow function or function expression, evaluate via vm\n    if (ts.isArrowFunction(arg) || ts.isFunctionExpression(arg)) {\n      return evaluateViaVm(ctx as MacroContextImpl, arg, callExpr);\n    }\n\n    // For simple expressions, try the lightweight AST evaluator first\n    const result = ctx.evaluate(arg);\n\n    if (result.kind === \"error\") {\n      // Fall back to vm-based evaluation for complex expressions\n      return evaluateViaVm(ctx as MacroContextImpl, arg, callExpr);\n    }\n\n    return (ctx as MacroContextImpl).comptimeValueToExpression(result);\n  },\n});\n\n/**\n * Evaluate a TypeScript expression/function at compile time using Node's vm module.\n *\n * This transpiles the source to JavaScript, runs it in a sandboxed context,\n * and converts the result back to a TypeScript AST node.\n */\nfunction evaluateViaVm(\n  ctx: MacroContextImpl,\n  node: ts.Node,\n  callExpr: ts.CallExpression,\n): ts.Expression {\n  const sourceText = node.getText ? node.getText() : nodeToString(node, ctx);\n\n  // Wrap in an IIFE if it's a function â€” call it immediately\n  const isFunction = ts.isArrowFunction(node) || ts.isFunctionExpression(node);\n  const codeToEval = isFunction ? `(${sourceText})()` : `(${sourceText})`;\n\n  // Transpile TypeScript to JavaScript\n  const { outputText, diagnostics } = ts.transpileModule(codeToEval, {\n    compilerOptions: {\n      target: ts.ScriptTarget.ES2022,\n      module: ts.ModuleKind.CommonJS,\n      strict: false,\n      removeComments: true,\n    },\n    reportDiagnostics: true,\n  });\n\n  if (diagnostics && diagnostics.length > 0) {\n    const messages = diagnostics.map((d) =>\n      ts.flattenDiagnosticMessageText(d.messageText, \"\\n\"),\n    );\n    ctx.reportError(\n      callExpr,\n      `Cannot transpile comptime expression: ${messages.join(\"; \")}`,\n    );\n    return callExpr;\n  }\n\n  // Strip the trailing export {} that transpileModule sometimes adds\n  const cleanedJs = outputText\n    .replace(/^\"use strict\";\\s*/, \"\")\n    .replace(/\\s*Object\\.defineProperty\\(exports.*\\n?/g, \"\")\n    .replace(/\\s*exports\\.\\S+ = void 0;\\s*/g, \"\");\n\n  try {\n    const sandbox = createComptimeSandbox();\n    const context = vm.createContext(sandbox);\n    const result = vm.runInContext(cleanedJs, context, {\n      timeout: COMPTIME_TIMEOUT_MS,\n      filename: \"comptime-eval.js\",\n    });\n\n    return jsValueToExpression(ctx, result, callExpr);\n  } catch (error: unknown) {\n    ctx.reportError(\n      callExpr,\n      formatComptimeError(error, sourceText, ctx, callExpr),\n    );\n    return callExpr;\n  }\n}\n\n/**\n * Format a comptime evaluation error with source context.\n *\n * Includes the original source snippet, file location, and a clear\n * explanation of what went wrong -- not just the raw vm error.\n */\nfunction formatComptimeError(\n  error: unknown,\n  sourceText: string,\n  ctx: MacroContextImpl,\n  callExpr: ts.CallExpression,\n): string {\n  const rawMessage = error instanceof Error ? error.message : String(error);\n\n  // Get source location\n  const sourceFile = ctx.sourceFile;\n  const start = callExpr.getStart(sourceFile);\n  const { line, character } = sourceFile.getLineAndCharacterOfPosition(start);\n  const location = `${sourceFile.fileName}:${line + 1}:${character + 1}`;\n\n  // Truncate long source snippets\n  const maxSnippetLen = 200;\n  const snippet =\n    sourceText.length > maxSnippetLen\n      ? sourceText.slice(0, maxSnippetLen) + \"...\"\n      : sourceText;\n\n  // Detect common error patterns and provide helpful messages\n  let hint = \"\";\n  if (rawMessage.includes(\"Script execution timed out\")) {\n    hint =\n      `\\n  Hint: The expression took longer than ${COMPTIME_TIMEOUT_MS}ms to evaluate. ` +\n      `Check for infinite loops or very expensive computations.`;\n  } else if (\n    rawMessage.includes(\"is not defined\") ||\n    rawMessage.includes(\"is not a function\")\n  ) {\n    const match = rawMessage.match(/(\\w+) is not (defined|a function)/);\n    const name = match?.[1] ?? \"unknown\";\n    hint =\n      `\\n  Hint: '${name}' is not available in the comptime sandbox. ` +\n      `Only safe built-ins (Math, JSON, Array, etc.) are accessible. ` +\n      `File I/O, network, and process access are intentionally blocked.`;\n  } else if (rawMessage.includes(\"Cannot read properties of\")) {\n    hint =\n      \"\\n  Hint: A null/undefined value was accessed. \" +\n      \"Check that all variables are properly initialized.\";\n  }\n\n  return (\n    `Compile-time evaluation failed at ${location}\\n` +\n    `  Source: comptime(${snippet})\\n` +\n    `  Error: ${rawMessage}${hint}`\n  );\n}\n\n/**\n * Create a sandboxed environment for comptime evaluation.\n * Only safe, side-effect-free globals are exposed.\n */\nfunction createComptimeSandbox(): Record<string, unknown> {\n  return {\n    // Safe built-ins\n    Math,\n    Number,\n    String,\n    Boolean,\n    Array,\n    Object,\n    Map,\n    Set,\n    WeakMap,\n    WeakSet,\n    JSON,\n    Date,\n    RegExp,\n    Error,\n    TypeError,\n    RangeError,\n    SyntaxError,\n    parseInt,\n    parseFloat,\n    isNaN,\n    isFinite,\n    NaN,\n    Infinity,\n    undefined,\n\n    // Console for debugging (output goes to build log)\n    console: {\n      log: (...args: unknown[]) => console.log(\"[comptime]\", ...args),\n      warn: (...args: unknown[]) => console.warn(\"[comptime]\", ...args),\n      error: (...args: unknown[]) => console.error(\"[comptime]\", ...args),\n    },\n  };\n}\n\n/**\n * Convert a JavaScript runtime value to a TypeScript AST expression.\n */\nfunction jsValueToExpression(\n  ctx: MacroContextImpl,\n  value: unknown,\n  errorNode: ts.Node,\n): ts.Expression {\n  if (value === null) {\n    return ctx.factory.createNull();\n  }\n\n  if (value === undefined) {\n    return ctx.factory.createIdentifier(\"undefined\");\n  }\n\n  if (typeof value === \"number\") {\n    if (value < 0) {\n      return ctx.factory.createPrefixUnaryExpression(\n        ts.SyntaxKind.MinusToken,\n        ctx.factory.createNumericLiteral(Math.abs(value)),\n      );\n    }\n    if (!isFinite(value)) {\n      return ctx.factory.createIdentifier(value > 0 ? \"Infinity\" : \"-Infinity\");\n    }\n    if (isNaN(value)) {\n      return ctx.factory.createIdentifier(\"NaN\");\n    }\n    return ctx.factory.createNumericLiteral(value);\n  }\n\n  if (typeof value === \"string\") {\n    return ctx.factory.createStringLiteral(value);\n  }\n\n  if (typeof value === \"boolean\") {\n    return value ? ctx.factory.createTrue() : ctx.factory.createFalse();\n  }\n\n  if (typeof value === \"bigint\") {\n    return ctx.factory.createBigIntLiteral(value.toString());\n  }\n\n  if (Array.isArray(value)) {\n    const elements = value.map((el) => jsValueToExpression(ctx, el, errorNode));\n    return ctx.factory.createArrayLiteralExpression(elements);\n  }\n\n  if (value instanceof RegExp) {\n    return ctx.factory.createCallExpression(\n      ctx.factory.createIdentifier(\"RegExp\"),\n      undefined,\n      [\n        ctx.factory.createStringLiteral(value.source),\n        ctx.factory.createStringLiteral(value.flags),\n      ],\n    );\n  }\n\n  if (typeof value === \"object\") {\n    const properties: ts.PropertyAssignment[] = [];\n    for (const [key, val] of Object.entries(value)) {\n      properties.push(\n        ctx.factory.createPropertyAssignment(\n          /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)\n            ? ctx.factory.createIdentifier(key)\n            : ctx.factory.createStringLiteral(key),\n          jsValueToExpression(ctx, val, errorNode),\n        ),\n      );\n    }\n    return ctx.factory.createObjectLiteralExpression(properties, true);\n  }\n\n  // Functions, symbols, etc. cannot be serialized to AST\n  ctx.reportError(\n    errorNode,\n    `Cannot serialize comptime result of type ${typeof value} to AST`,\n  );\n  return ctx.factory.createIdentifier(\"undefined\");\n}\n\n/**\n * Convert a TS node to its source text when getText() is unavailable\n * (e.g., for synthetically created nodes).\n */\nfunction nodeToString(node: ts.Node, ctx: MacroContextImpl): string {\n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n  return printer.printNode(ts.EmitHint.Expression, node, ctx.sourceFile);\n}\n\n/**\n * Convert a JS value to a ComptimeValue (for interop with the lightweight evaluator).\n */\nexport function jsToComptimeValue(value: unknown): ComptimeValue {\n  if (value === null) return { kind: \"null\" };\n  if (value === undefined) return { kind: \"undefined\" };\n  if (typeof value === \"number\") return { kind: \"number\", value };\n  if (typeof value === \"string\") return { kind: \"string\", value };\n  if (typeof value === \"boolean\") return { kind: \"boolean\", value };\n  if (Array.isArray(value)) {\n    return { kind: \"array\", elements: value.map(jsToComptimeValue) };\n  }\n  if (typeof value === \"object\") {\n    const properties = new Map<string, ComptimeValue>();\n    for (const [k, v] of Object.entries(value)) {\n      properties.set(k, jsToComptimeValue(v));\n    }\n    return { kind: \"object\", properties };\n  }\n  return {\n    kind: \"error\",\n    message: `Cannot convert ${typeof value} to ComptimeValue`,\n  };\n}\n\n/**\n * Register macros with the global registry.\n * Call this function to enable comptime macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(comptimeMacro);\n}\n\n// Auto-register when this module is imported\nregister();\n"],"mappings":"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","names":[]}