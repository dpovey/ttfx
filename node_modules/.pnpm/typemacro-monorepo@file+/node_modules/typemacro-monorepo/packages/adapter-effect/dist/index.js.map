{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @typemacro/adapter-effect\n *\n * Effect-TS adapter providing do-notation via labeled blocks.\n *\n * ## Usage\n *\n * ```ts\n * import { effectDo } from \"@typemacro/adapter-effect\";\n *\n * // Labeled block syntax (compiles to Effect.flatMap chain)\n * let: {\n *   user << getUserById(id)\n * }\n * yield: {\n *   user,\n *   posts,\n *   comments,\n * }\n *\n * // Compiles to:\n * Effect.flatMap(getUserById(id), (user) =>\n *   Effect.succeed({ user, posts, comments })\n * );\n *\n * // Generator-based syntax (for complex control flow)\n * const program = Effect.gen(function* () {\n *   const user = yield* getUserById(id);\n *   const posts = yield* getPostsForUser(user.id);\n *   return { user, posts };\n * });\n * ```\n *\n * @module\n */\n\nimport * as ts from \"typescript\";\nimport {\n  type LabeledBlockMacro,\n  type ExpressionMacro,\n  type MacroContext,\n  defineLabeledBlockMacro,\n  defineExpressionMacro,\n  globalRegistry,\n} from \"@typemacro/core\";\n\n// ============================================================================\n// Effect Do-Notation Macro (Labeled Block)\n// ============================================================================\n\n/**\n * effectDo labeled block macro\n *\n * Transforms labeled block syntax into Effect.flatMap chains:\n *\n * ```ts\n * let: {\n *   x << getX()\n * }\n * yield: {\n *   result: x + y\n * }\n * ```\n *\n * Becomes:\n *\n * ```ts\n * Effect.flatMap(getX(), (x) =>\n *   Effect.succeed({ result: x + y })\n * )\n * ```\n */\nexport const effectLetMacro: LabeledBlockMacro = defineLabeledBlockMacro({\n  name: \"effectLet\",\n  label: \"let\",\n  continuationLabels: [\"yield\", \"pure\", \"return\"],\n  expand(\n    ctx: MacroContext,\n    mainBlock: ts.LabeledStatement,\n    continuation: ts.LabeledStatement | undefined,\n  ): ts.Statement | ts.Statement[] {\n    const { factory } = ctx;\n\n    if (!continuation) {\n      ctx.reportError(mainBlock, \"effectLet requires a 'yield', 'pure', or 'return' block after the 'let' block\");\n      return mainBlock;\n    }\n\n    // Parse bindings from the let block\n    const bindings = parseBindingsFromBlock(mainBlock.statement, ctx);\n\n    if (bindings.length === 0) {\n      ctx.reportError(mainBlock, \"effectLet 'let' block must contain at least one binding (x << effect)\");\n      return mainBlock;\n    }\n\n    // Get the yield expression\n    const yieldExpr = extractYieldExpression(continuation.statement, ctx);\n    if (!yieldExpr) {\n      ctx.reportError(continuation, \"effectLet yield block must contain an expression\");\n      return mainBlock;\n    }\n\n    // Build the flatMap chain from inside out\n    // Start with the innermost: Effect.succeed(yieldExpr)\n    let result: ts.Expression = factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        factory.createIdentifier(\"Effect\"),\n        factory.createIdentifier(\"succeed\"),\n      ),\n      undefined,\n      [yieldExpr],\n    );\n\n    // Wrap each binding from last to first\n    for (let i = bindings.length - 1; i >= 0; i--) {\n      const { name, effect } = bindings[i];\n      result = factory.createCallExpression(\n        factory.createPropertyAccessExpression(\n          factory.createIdentifier(\"Effect\"),\n          factory.createIdentifier(\"flatMap\"),\n        ),\n        undefined,\n        [\n          effect,\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              factory.createParameterDeclaration(\n                undefined,\n                undefined,\n                factory.createIdentifier(name),\n                undefined,\n                undefined,\n                undefined,\n              ),\n            ],\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            result,\n          ),\n        ],\n      );\n    }\n\n    return factory.createExpressionStatement(result);\n  },\n});\n\n// ============================================================================\n// Effect Gen Macro (Expression Macro)\n// ============================================================================\n\n/**\n * gen$ macro - shorthand for Effect.gen with yield* syntax\n *\n * ```ts\n * const result = gen$((function* () {\n *   const x = yield* getX();\n *   const y = yield* getY(x);\n *   return { x, y };\n * }));\n * ```\n *\n * Compiles to:\n *\n * ```ts\n * const result = Effect.gen(function* () {\n *   const x = yield* getX();\n *   const y = yield* getY(x);\n *   return { x, y };\n * });\n * ```\n */\nexport const genMacro: ExpressionMacro = defineExpressionMacro({\n  name: \"gen$\",\n  expand(ctx: MacroContext, node: ts.CallExpression, args: readonly ts.Expression[]): ts.Expression {\n    const { factory } = ctx;\n\n    if (args.length !== 1) {\n      ctx.reportError(node, \"gen$ expects exactly one argument: a generator function\");\n      return node;\n    }\n\n    let genFn = args[0];\n    // Unwrap if it's a parenthesized expression\n    if (ts.isParenthesizedExpression(genFn)) {\n      genFn = genFn.expression;\n    }\n\n    // Wrap in Effect.gen\n    return factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        factory.createIdentifier(\"Effect\"),\n        factory.createIdentifier(\"gen\"),\n      ),\n      undefined,\n      [genFn],\n    );\n  },\n});\n\n// ============================================================================\n// Effect Map Macro (Expression Macro)\n// ============================================================================\n\n/**\n * map$ macro - Effect.map shorthand\n *\n * ```ts\n * const result = map$(getUser(), user => user.name);\n * ```\n *\n * Compiles to:\n *\n * ```ts\n * const result = Effect.map(getUser(), user => user.name);\n * ```\n */\nexport const mapMacro: ExpressionMacro = defineExpressionMacro({\n  name: \"map$\",\n  expand(ctx: MacroContext, node: ts.CallExpression, args: readonly ts.Expression[]): ts.Expression {\n    const { factory } = ctx;\n\n    if (args.length !== 2) {\n      ctx.reportError(node, \"map$ expects exactly two arguments: effect and mapper function\");\n      return node;\n    }\n\n    return factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        factory.createIdentifier(\"Effect\"),\n        factory.createIdentifier(\"map\"),\n      ),\n      undefined,\n      [args[0], args[1]],\n    );\n  },\n});\n\n// ============================================================================\n// Effect FlatMap Macro (Expression Macro)\n// ============================================================================\n\n/**\n * flatMap$ macro - Effect.flatMap shorthand\n *\n * ```ts\n * const result = flatMap$(getUser(), user => getPosts(user.id));\n * ```\n *\n * Compiles to:\n *\n * ```ts\n * const result = Effect.flatMap(getUser(), user => getPosts(user.id));\n * ```\n */\nexport const flatMapMacro: ExpressionMacro = defineExpressionMacro({\n  name: \"flatMap$\",\n  expand(ctx: MacroContext, node: ts.CallExpression, args: readonly ts.Expression[]): ts.Expression {\n    const { factory } = ctx;\n\n    if (args.length !== 2) {\n      ctx.reportError(node, \"flatMap$ expects exactly two arguments: effect and flatMapper function\");\n      return node;\n    }\n\n    return factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        factory.createIdentifier(\"Effect\"),\n        factory.createIdentifier(\"flatMap\"),\n      ),\n      undefined,\n      [args[0], args[1]],\n    );\n  },\n});\n\n// ============================================================================\n// Effect Pipe Macro (Expression Macro)\n// ============================================================================\n\n/**\n * pipe$ macro - Effect.pipe shorthand\n *\n * ```ts\n * const result = pipe$(\n *   getUser(),\n *   Effect.flatMap(user => getPosts(user.id)),\n *   Effect.map(posts => posts.length)\n * );\n * ```\n *\n * Compiles to:\n *\n * ```ts\n * const result = Effect.pipe(\n *   getUser(),\n *   Effect.flatMap(user => getPosts(user.id)),\n *   Effect.map(posts => posts.length)\n * );\n * ```\n */\nexport const pipeMacro: ExpressionMacro = defineExpressionMacro({\n  name: \"pipe$\",\n  expand(ctx: MacroContext, node: ts.CallExpression, args: readonly ts.Expression[]): ts.Expression {\n    const { factory } = ctx;\n\n    if (args.length < 2) {\n      ctx.reportError(node, \"pipe$ expects at least two arguments: initial value and pipe functions\");\n      return node;\n    }\n\n    return factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        factory.createIdentifier(\"Effect\"),\n        factory.createIdentifier(\"pipe\"),\n      ),\n      undefined,\n      [...args],\n    );\n  },\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\ninterface Binding {\n  name: string;\n  effect: ts.Expression;\n}\n\n/**\n * Parse bindings from a block statement.\n * Expects variable declarations with << operator as initializer:\n *   { x << getX(); y << getY(x); }\n * Or expression statements:\n *   { x << getX() }\n */\nfunction parseBindingsFromBlock(stmt: ts.Statement, ctx: MacroContext): Binding[] {\n  const bindings: Binding[] = [];\n\n  if (ts.isBlock(stmt)) {\n    for (const s of stmt.statements) {\n      const binding = parseBindingStatement(s, ctx);\n      if (binding) {\n        bindings.push(binding);\n      }\n    }\n  } else if (ts.isExpressionStatement(stmt)) {\n    const binding = parseBindingFromExpression(stmt.expression, ctx);\n    if (binding) {\n      bindings.push(binding);\n    }\n  }\n\n  return bindings;\n}\n\n/**\n * Parse a single binding from a statement\n */\nfunction parseBindingStatement(stmt: ts.Statement, ctx: MacroContext): Binding | undefined {\n  if (ts.isExpressionStatement(stmt)) {\n    return parseBindingFromExpression(stmt.expression, ctx);\n  }\n\n  if (ts.isVariableStatement(stmt)) {\n    const decl = stmt.declarationList.declarations[0];\n    if (decl && decl.initializer && ts.isIdentifier(decl.name)) {\n      // Check if initializer is x << effect\n      if (\n        ts.isBinaryExpression(decl.initializer) &&\n        decl.initializer.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken\n      ) {\n        const left = decl.initializer.left;\n        if (ts.isIdentifier(left)) {\n          return {\n            name: left.text,\n            effect: decl.initializer.right,\n          };\n        }\n      }\n      // Or just a regular expression (use var name as binding name)\n      return {\n        name: decl.name.text,\n        effect: decl.initializer,\n      };\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Parse binding from expression (x << effect format)\n */\nfunction parseBindingFromExpression(expr: ts.Expression, ctx: MacroContext): Binding | undefined {\n  if (\n    ts.isBinaryExpression(expr) &&\n    expr.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken\n  ) {\n    const left = expr.left;\n    if (ts.isIdentifier(left)) {\n      return {\n        name: left.text,\n        effect: expr.right,\n      };\n    } else {\n      ctx.reportError(left, \"Left side of << must be an identifier\");\n    }\n  }\n  return undefined;\n}\n\n/**\n * Extract the yield expression from a block\n */\nfunction extractYieldExpression(stmt: ts.Statement, ctx: MacroContext): ts.Expression | undefined {\n  if (ts.isBlock(stmt)) {\n    // Return the last expression in the block, or wrap all statements\n    const lastStmt = stmt.statements[stmt.statements.length - 1];\n    if (lastStmt && ts.isExpressionStatement(lastStmt)) {\n      return lastStmt.expression;\n    }\n    if (lastStmt && ts.isReturnStatement(lastStmt) && lastStmt.expression) {\n      return lastStmt.expression;\n    }\n    // If block has multiple expressions, create object literal\n    ctx.reportError(stmt, \"yield block should contain a single expression or object literal\");\n    return undefined;\n  }\n\n  if (ts.isExpressionStatement(stmt)) {\n    return stmt.expression;\n  }\n\n  return undefined;\n}\n\n// ============================================================================\n// Registration\n// ============================================================================\n\n/**\n * Register all Effect adapter macros with the global registry.\n */\nexport function register(): void {\n  globalRegistry.register(effectLetMacro);\n  globalRegistry.register(genMacro);\n  globalRegistry.register(mapMacro);\n  globalRegistry.register(flatMapMacro);\n  globalRegistry.register(pipeMacro);\n}\n\n// Auto-register on import\nregister();\n\n// ============================================================================\n// Type Helpers (for use in user code)\n// ============================================================================\n\n/**\n * Marker type for binding expressions using <<\n * This helps with IDE support even before macro transformation.\n */\nexport type Bind<T> = T;\n\n/**\n * Runtime placeholder for gen$ (should be transformed at compile time)\n */\nexport function gen$<T>(_fn: () => Generator<unknown, T, unknown>): never {\n  throw new Error(\n    \"gen$ was not transformed at compile time. \" +\n      \"Make sure @typemacro/adapter-effect is registered with the transformer.\",\n  );\n}\n\n/**\n * Runtime placeholder for map$ (should be transformed at compile time)\n */\nexport function map$<A, B>(_effect: unknown, _fn: (a: A) => B): never {\n  throw new Error(\n    \"map$ was not transformed at compile time. \" +\n      \"Make sure @typemacro/adapter-effect is registered with the transformer.\",\n  );\n}\n\n/**\n * Runtime placeholder for flatMap$ (should be transformed at compile time)\n */\nexport function flatMap$<A, B>(_effect: unknown, _fn: (a: A) => unknown): never {\n  throw new Error(\n    \"flatMap$ was not transformed at compile time. \" +\n      \"Make sure @typemacro/adapter-effect is registered with the transformer.\",\n  );\n}\n\n/**\n * Runtime placeholder for pipe$ (should be transformed at compile time)\n */\nexport function pipe$<A>(_initial: A, ..._fns: Array<(a: unknown) => unknown>): never {\n  throw new Error(\n    \"pipe$ was not transformed at compile time. \" +\n      \"Make sure @typemacro/adapter-effect is registered with the transformer.\",\n  );\n}\n"],"mappings":"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","names":[]}