import { LabeledBlockMacro, ExpressionMacro } from '@typemacro/core';

/**
 * @typemacro/adapter-effect
 *
 * Effect-TS adapter providing do-notation via labeled blocks.
 *
 * ## Usage
 *
 * ```ts
 * import { effectDo } from "@typemacro/adapter-effect";
 *
 * // Labeled block syntax (compiles to Effect.flatMap chain)
 * let: {
 *   user << getUserById(id)
 * }
 * yield: {
 *   user,
 *   posts,
 *   comments,
 * }
 *
 * // Compiles to:
 * Effect.flatMap(getUserById(id), (user) =>
 *   Effect.succeed({ user, posts, comments })
 * );
 *
 * // Generator-based syntax (for complex control flow)
 * const program = Effect.gen(function* () {
 *   const user = yield* getUserById(id);
 *   const posts = yield* getPostsForUser(user.id);
 *   return { user, posts };
 * });
 * ```
 *
 * @module
 */

/**
 * effectDo labeled block macro
 *
 * Transforms labeled block syntax into Effect.flatMap chains:
 *
 * ```ts
 * let: {
 *   x << getX()
 * }
 * yield: {
 *   result: x + y
 * }
 * ```
 *
 * Becomes:
 *
 * ```ts
 * Effect.flatMap(getX(), (x) =>
 *   Effect.succeed({ result: x + y })
 * )
 * ```
 */
declare const effectLetMacro: LabeledBlockMacro;
/**
 * gen$ macro - shorthand for Effect.gen with yield* syntax
 *
 * ```ts
 * const result = gen$((function* () {
 *   const x = yield* getX();
 *   const y = yield* getY(x);
 *   return { x, y };
 * }));
 * ```
 *
 * Compiles to:
 *
 * ```ts
 * const result = Effect.gen(function* () {
 *   const x = yield* getX();
 *   const y = yield* getY(x);
 *   return { x, y };
 * });
 * ```
 */
declare const genMacro: ExpressionMacro;
/**
 * map$ macro - Effect.map shorthand
 *
 * ```ts
 * const result = map$(getUser(), user => user.name);
 * ```
 *
 * Compiles to:
 *
 * ```ts
 * const result = Effect.map(getUser(), user => user.name);
 * ```
 */
declare const mapMacro: ExpressionMacro;
/**
 * flatMap$ macro - Effect.flatMap shorthand
 *
 * ```ts
 * const result = flatMap$(getUser(), user => getPosts(user.id));
 * ```
 *
 * Compiles to:
 *
 * ```ts
 * const result = Effect.flatMap(getUser(), user => getPosts(user.id));
 * ```
 */
declare const flatMapMacro: ExpressionMacro;
/**
 * pipe$ macro - Effect.pipe shorthand
 *
 * ```ts
 * const result = pipe$(
 *   getUser(),
 *   Effect.flatMap(user => getPosts(user.id)),
 *   Effect.map(posts => posts.length)
 * );
 * ```
 *
 * Compiles to:
 *
 * ```ts
 * const result = Effect.pipe(
 *   getUser(),
 *   Effect.flatMap(user => getPosts(user.id)),
 *   Effect.map(posts => posts.length)
 * );
 * ```
 */
declare const pipeMacro: ExpressionMacro;
/**
 * Register all Effect adapter macros with the global registry.
 */
declare function register(): void;
/**
 * Marker type for binding expressions using <<
 * This helps with IDE support even before macro transformation.
 */
type Bind<T> = T;
/**
 * Runtime placeholder for gen$ (should be transformed at compile time)
 */
declare function gen$<T>(_fn: () => Generator<unknown, T, unknown>): never;
/**
 * Runtime placeholder for map$ (should be transformed at compile time)
 */
declare function map$<A, B>(_effect: unknown, _fn: (a: A) => B): never;
/**
 * Runtime placeholder for flatMap$ (should be transformed at compile time)
 */
declare function flatMap$<A, B>(_effect: unknown, _fn: (a: A) => unknown): never;
/**
 * Runtime placeholder for pipe$ (should be transformed at compile time)
 */
declare function pipe$<A>(_initial: A, ..._fns: Array<(a: unknown) => unknown>): never;

export { type Bind, effectLetMacro, flatMap$, flatMapMacro, gen$, genMacro, map$, mapMacro, pipe$, pipeMacro, register };
