// src/index.ts
import * as ts from "typescript";
import {
  defineLabeledBlockMacro,
  defineExpressionMacro,
  globalRegistry
} from "@typemacro/core";
var effectLetMacro = defineLabeledBlockMacro({
  name: "effectLet",
  label: "let",
  continuationLabels: ["yield", "pure", "return"],
  expand(ctx, mainBlock, continuation) {
    const { factory } = ctx;
    if (!continuation) {
      ctx.reportError(mainBlock, "effectLet requires a 'yield', 'pure', or 'return' block after the 'let' block");
      return mainBlock;
    }
    const bindings = parseBindingsFromBlock(mainBlock.statement, ctx);
    if (bindings.length === 0) {
      ctx.reportError(mainBlock, "effectLet 'let' block must contain at least one binding (x << effect)");
      return mainBlock;
    }
    const yieldExpr = extractYieldExpression(continuation.statement, ctx);
    if (!yieldExpr) {
      ctx.reportError(continuation, "effectLet yield block must contain an expression");
      return mainBlock;
    }
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("succeed")
      ),
      void 0,
      [yieldExpr]
    );
    for (let i = bindings.length - 1; i >= 0; i--) {
      const { name, effect } = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(
          factory.createIdentifier("Effect"),
          factory.createIdentifier("flatMap")
        ),
        void 0,
        [
          effect,
          factory.createArrowFunction(
            void 0,
            void 0,
            [
              factory.createParameterDeclaration(
                void 0,
                void 0,
                factory.createIdentifier(name),
                void 0,
                void 0,
                void 0
              )
            ],
            void 0,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result
          )
        ]
      );
    }
    return factory.createExpressionStatement(result);
  }
});
var genMacro = defineExpressionMacro({
  name: "gen$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 1) {
      ctx.reportError(node, "gen$ expects exactly one argument: a generator function");
      return node;
    }
    let genFn = args[0];
    if (ts.isParenthesizedExpression(genFn)) {
      genFn = genFn.expression;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("gen")
      ),
      void 0,
      [genFn]
    );
  }
});
var mapMacro = defineExpressionMacro({
  name: "map$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 2) {
      ctx.reportError(node, "map$ expects exactly two arguments: effect and mapper function");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("map")
      ),
      void 0,
      [args[0], args[1]]
    );
  }
});
var flatMapMacro = defineExpressionMacro({
  name: "flatMap$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 2) {
      ctx.reportError(node, "flatMap$ expects exactly two arguments: effect and flatMapper function");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("flatMap")
      ),
      void 0,
      [args[0], args[1]]
    );
  }
});
var pipeMacro = defineExpressionMacro({
  name: "pipe$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length < 2) {
      ctx.reportError(node, "pipe$ expects at least two arguments: initial value and pipe functions");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("pipe")
      ),
      void 0,
      [...args]
    );
  }
});
function parseBindingsFromBlock(stmt, ctx) {
  const bindings = [];
  if (ts.isBlock(stmt)) {
    for (const s of stmt.statements) {
      const binding = parseBindingStatement(s, ctx);
      if (binding) {
        bindings.push(binding);
      }
    }
  } else if (ts.isExpressionStatement(stmt)) {
    const binding = parseBindingFromExpression(stmt.expression, ctx);
    if (binding) {
      bindings.push(binding);
    }
  }
  return bindings;
}
function parseBindingStatement(stmt, ctx) {
  if (ts.isExpressionStatement(stmt)) {
    return parseBindingFromExpression(stmt.expression, ctx);
  }
  if (ts.isVariableStatement(stmt)) {
    const decl = stmt.declarationList.declarations[0];
    if (decl && decl.initializer && ts.isIdentifier(decl.name)) {
      if (ts.isBinaryExpression(decl.initializer) && decl.initializer.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken) {
        const left = decl.initializer.left;
        if (ts.isIdentifier(left)) {
          return {
            name: left.text,
            effect: decl.initializer.right
          };
        }
      }
      return {
        name: decl.name.text,
        effect: decl.initializer
      };
    }
  }
  return void 0;
}
function parseBindingFromExpression(expr, ctx) {
  if (ts.isBinaryExpression(expr) && expr.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken) {
    const left = expr.left;
    if (ts.isIdentifier(left)) {
      return {
        name: left.text,
        effect: expr.right
      };
    } else {
      ctx.reportError(left, "Left side of << must be an identifier");
    }
  }
  return void 0;
}
function extractYieldExpression(stmt, ctx) {
  if (ts.isBlock(stmt)) {
    const lastStmt = stmt.statements[stmt.statements.length - 1];
    if (lastStmt && ts.isExpressionStatement(lastStmt)) {
      return lastStmt.expression;
    }
    if (lastStmt && ts.isReturnStatement(lastStmt) && lastStmt.expression) {
      return lastStmt.expression;
    }
    ctx.reportError(stmt, "yield block should contain a single expression or object literal");
    return void 0;
  }
  if (ts.isExpressionStatement(stmt)) {
    return stmt.expression;
  }
  return void 0;
}
function register() {
  globalRegistry.register(effectLetMacro);
  globalRegistry.register(genMacro);
  globalRegistry.register(mapMacro);
  globalRegistry.register(flatMapMacro);
  globalRegistry.register(pipeMacro);
}
register();
function gen$(_fn) {
  throw new Error(
    "gen$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function map$(_effect, _fn) {
  throw new Error(
    "map$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function flatMap$(_effect, _fn) {
  throw new Error(
    "flatMap$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function pipe$(_initial, ..._fns) {
  throw new Error(
    "pipe$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
export {
  effectLetMacro,
  flatMap$,
  flatMapMacro,
  gen$,
  genMacro,
  map$,
  mapMacro,
  pipe$,
  pipeMacro,
  register
};
//# sourceMappingURL=index.js.map