"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  effectLetMacro: () => effectLetMacro,
  flatMap$: () => flatMap$,
  flatMapMacro: () => flatMapMacro,
  gen$: () => gen$,
  genMacro: () => genMacro,
  map$: () => map$,
  mapMacro: () => mapMacro,
  pipe$: () => pipe$,
  pipeMacro: () => pipeMacro,
  register: () => register
});
module.exports = __toCommonJS(index_exports);
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var effectLetMacro = (0, import_core.defineLabeledBlockMacro)({
  name: "effectLet",
  label: "let",
  continuationLabels: ["yield", "pure", "return"],
  expand(ctx, mainBlock, continuation) {
    const { factory } = ctx;
    if (!continuation) {
      ctx.reportError(mainBlock, "effectLet requires a 'yield', 'pure', or 'return' block after the 'let' block");
      return mainBlock;
    }
    const bindings = parseBindingsFromBlock(mainBlock.statement, ctx);
    if (bindings.length === 0) {
      ctx.reportError(mainBlock, "effectLet 'let' block must contain at least one binding (x << effect)");
      return mainBlock;
    }
    const yieldExpr = extractYieldExpression(continuation.statement, ctx);
    if (!yieldExpr) {
      ctx.reportError(continuation, "effectLet yield block must contain an expression");
      return mainBlock;
    }
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("succeed")
      ),
      void 0,
      [yieldExpr]
    );
    for (let i = bindings.length - 1; i >= 0; i--) {
      const { name, effect } = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(
          factory.createIdentifier("Effect"),
          factory.createIdentifier("flatMap")
        ),
        void 0,
        [
          effect,
          factory.createArrowFunction(
            void 0,
            void 0,
            [
              factory.createParameterDeclaration(
                void 0,
                void 0,
                factory.createIdentifier(name),
                void 0,
                void 0,
                void 0
              )
            ],
            void 0,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result
          )
        ]
      );
    }
    return factory.createExpressionStatement(result);
  }
});
var genMacro = (0, import_core.defineExpressionMacro)({
  name: "gen$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 1) {
      ctx.reportError(node, "gen$ expects exactly one argument: a generator function");
      return node;
    }
    let genFn = args[0];
    if (ts.isParenthesizedExpression(genFn)) {
      genFn = genFn.expression;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("gen")
      ),
      void 0,
      [genFn]
    );
  }
});
var mapMacro = (0, import_core.defineExpressionMacro)({
  name: "map$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 2) {
      ctx.reportError(node, "map$ expects exactly two arguments: effect and mapper function");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("map")
      ),
      void 0,
      [args[0], args[1]]
    );
  }
});
var flatMapMacro = (0, import_core.defineExpressionMacro)({
  name: "flatMap$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length !== 2) {
      ctx.reportError(node, "flatMap$ expects exactly two arguments: effect and flatMapper function");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("flatMap")
      ),
      void 0,
      [args[0], args[1]]
    );
  }
});
var pipeMacro = (0, import_core.defineExpressionMacro)({
  name: "pipe$",
  expand(ctx, node, args) {
    const { factory } = ctx;
    if (args.length < 2) {
      ctx.reportError(node, "pipe$ expects at least two arguments: initial value and pipe functions");
      return node;
    }
    return factory.createCallExpression(
      factory.createPropertyAccessExpression(
        factory.createIdentifier("Effect"),
        factory.createIdentifier("pipe")
      ),
      void 0,
      [...args]
    );
  }
});
function parseBindingsFromBlock(stmt, ctx) {
  const bindings = [];
  if (ts.isBlock(stmt)) {
    for (const s of stmt.statements) {
      const binding = parseBindingStatement(s, ctx);
      if (binding) {
        bindings.push(binding);
      }
    }
  } else if (ts.isExpressionStatement(stmt)) {
    const binding = parseBindingFromExpression(stmt.expression, ctx);
    if (binding) {
      bindings.push(binding);
    }
  }
  return bindings;
}
function parseBindingStatement(stmt, ctx) {
  if (ts.isExpressionStatement(stmt)) {
    return parseBindingFromExpression(stmt.expression, ctx);
  }
  if (ts.isVariableStatement(stmt)) {
    const decl = stmt.declarationList.declarations[0];
    if (decl && decl.initializer && ts.isIdentifier(decl.name)) {
      if (ts.isBinaryExpression(decl.initializer) && decl.initializer.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken) {
        const left = decl.initializer.left;
        if (ts.isIdentifier(left)) {
          return {
            name: left.text,
            effect: decl.initializer.right
          };
        }
      }
      return {
        name: decl.name.text,
        effect: decl.initializer
      };
    }
  }
  return void 0;
}
function parseBindingFromExpression(expr, ctx) {
  if (ts.isBinaryExpression(expr) && expr.operatorToken.kind === ts.SyntaxKind.LessThanLessThanToken) {
    const left = expr.left;
    if (ts.isIdentifier(left)) {
      return {
        name: left.text,
        effect: expr.right
      };
    } else {
      ctx.reportError(left, "Left side of << must be an identifier");
    }
  }
  return void 0;
}
function extractYieldExpression(stmt, ctx) {
  if (ts.isBlock(stmt)) {
    const lastStmt = stmt.statements[stmt.statements.length - 1];
    if (lastStmt && ts.isExpressionStatement(lastStmt)) {
      return lastStmt.expression;
    }
    if (lastStmt && ts.isReturnStatement(lastStmt) && lastStmt.expression) {
      return lastStmt.expression;
    }
    ctx.reportError(stmt, "yield block should contain a single expression or object literal");
    return void 0;
  }
  if (ts.isExpressionStatement(stmt)) {
    return stmt.expression;
  }
  return void 0;
}
function register() {
  import_core.globalRegistry.register(effectLetMacro);
  import_core.globalRegistry.register(genMacro);
  import_core.globalRegistry.register(mapMacro);
  import_core.globalRegistry.register(flatMapMacro);
  import_core.globalRegistry.register(pipeMacro);
}
register();
function gen$(_fn) {
  throw new Error(
    "gen$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function map$(_effect, _fn) {
  throw new Error(
    "map$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function flatMap$(_effect, _fn) {
  throw new Error(
    "flatMap$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
function pipe$(_initial, ..._fns) {
  throw new Error(
    "pipe$ was not transformed at compile time. Make sure @typemacro/adapter-effect is registered with the transformer."
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  effectLetMacro,
  flatMap$,
  flatMapMacro,
  gen$,
  genMacro,
  map$,
  mapMacro,
  pipe$,
  pipeMacro,
  register
});
//# sourceMappingURL=index.cjs.map