{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Special String Type Macros\n *\n * Compile-time validated and transformed string literals, inspired by Scala's\n * string interpolators (s\"\", f\"\", raw\"\") and custom interpolators.\n *\n * Provides:\n * - regex`...` - Compile-time validated regular expressions\n * - html`...` - HTML with XSS protection\n * - fmt`...` - Printf-style formatting with type checking\n * - json`...` - Compile-time JSON parsing\n * - raw`...` - Raw strings without escape processing\n *\n * Note: For SQL queries, use @typemacro/sql instead.\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Regex Tagged Template\n// ============================================================================\n\nexport const regexMacro = defineExpressionMacro({\n  name: \"regex\",\n  description: \"Create compile-time validated regular expressions\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(callExpr, \"regex expects a template literal\");\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    if (!ts.isNoSubstitutionTemplateLiteral(template)) {\n      ctx.reportError(callExpr, \"regex does not support interpolations\");\n      return callExpr;\n    }\n\n    const pattern = template.text;\n\n    // Validate regex at compile time\n    try {\n      new RegExp(pattern);\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      ctx.reportError(callExpr, `Invalid regular expression: ${msg}`);\n      return callExpr;\n    }\n\n    // Return: new RegExp(\"pattern\")\n    return factory.createNewExpression(\n      factory.createIdentifier(\"RegExp\"),\n      undefined,\n      [factory.createStringLiteral(pattern)],\n    );\n  },\n});\n\n// ============================================================================\n// HTML Tagged Template with XSS Protection\n// ============================================================================\n\nexport const htmlMacro = defineExpressionMacro({\n  name: \"html\",\n  description: \"Create HTML with automatic XSS escaping\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(callExpr, \"html expects a template literal\");\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    // Simple template - return as-is\n    if (ts.isNoSubstitutionTemplateLiteral(template)) {\n      return factory.createStringLiteral(template.text);\n    }\n\n    // Template with interpolations - wrap each value in escapeHtml()\n    if (ts.isTemplateExpression(template)) {\n      // Build: `head` + escapeHtml(expr1) + `mid1` + escapeHtml(expr2) + ...\n      let result: ts.Expression = factory.createStringLiteral(\n        template.head.text,\n      );\n\n      for (const span of template.templateSpans) {\n        // Add escaped value\n        const escapedValue = factory.createCallExpression(\n          factory.createIdentifier(\"__typemacro_escapeHtml\"),\n          undefined,\n          [span.expression],\n        );\n\n        result = factory.createBinaryExpression(\n          result,\n          factory.createToken(ts.SyntaxKind.PlusToken),\n          escapedValue,\n        );\n\n        // Add literal part\n        if (span.literal.text) {\n          result = factory.createBinaryExpression(\n            result,\n            factory.createToken(ts.SyntaxKind.PlusToken),\n            factory.createStringLiteral(span.literal.text),\n          );\n        }\n      }\n\n      return result;\n    }\n\n    return callExpr;\n  },\n});\n\n// ============================================================================\n// Printf-style Format Macro\n// ============================================================================\n\nexport const fmtMacro = defineExpressionMacro({\n  name: \"fmt\",\n  description: \"Printf-style formatting with type checking\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(callExpr, \"fmt expects a template literal\");\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    if (!ts.isTemplateExpression(template)) {\n      // No interpolations - return as-is\n      if (ts.isNoSubstitutionTemplateLiteral(template)) {\n        return factory.createStringLiteral(template.text);\n      }\n      return callExpr;\n    }\n\n    // Parse format specifiers from the template head and middles\n    // Format: ${value:format} where format is like %d, %s, %f, etc.\n\n    let result: ts.Expression = factory.createStringLiteral(\"\");\n\n    // Process head\n    const headParts = parseFormatString(template.head.text);\n    for (const part of headParts) {\n      if (part.type === \"literal\") {\n        result = concatStrings(\n          factory,\n          result,\n          factory.createStringLiteral(part.value),\n        );\n      }\n    }\n\n    // Process spans\n    for (let i = 0; i < template.templateSpans.length; i++) {\n      const span = template.templateSpans[i];\n\n      // The format specifier comes from the previous literal's end or a special syntax\n      // For simplicity, we'll just convert the value to string\n      const formattedValue = factory.createCallExpression(\n        factory.createIdentifier(\"String\"),\n        undefined,\n        [span.expression],\n      );\n\n      result = concatStrings(factory, result, formattedValue);\n\n      // Process literal part after the expression\n      const literalParts = parseFormatString(span.literal.text);\n      for (const part of literalParts) {\n        if (part.type === \"literal\") {\n          result = concatStrings(\n            factory,\n            result,\n            factory.createStringLiteral(part.value),\n          );\n        }\n      }\n    }\n\n    return result;\n  },\n});\n\nfunction parseFormatString(\n  str: string,\n): Array<{ type: \"literal\" | \"format\"; value: string }> {\n  // Simple parser - just return literals for now\n  // Could be enhanced to parse %d, %s, etc.\n  return [{ type: \"literal\", value: str }];\n}\n\nfunction concatStrings(\n  factory: ts.NodeFactory,\n  left: ts.Expression,\n  right: ts.Expression,\n): ts.Expression {\n  // Optimize: if left is empty string literal, just return right\n  if (ts.isStringLiteral(left) && left.text === \"\") {\n    return right;\n  }\n\n  return factory.createBinaryExpression(\n    left,\n    factory.createToken(ts.SyntaxKind.PlusToken),\n    right,\n  );\n}\n\n// ============================================================================\n// JSON Tagged Template with Schema Validation\n// ============================================================================\n\nexport const jsonMacro = defineExpressionMacro({\n  name: \"json\",\n  description: \"Parse and validate JSON at compile time\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(callExpr, \"json expects a template literal\");\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    if (!ts.isNoSubstitutionTemplateLiteral(template)) {\n      ctx.reportError(\n        callExpr,\n        \"json does not support interpolations - use a regular object literal\",\n      );\n      return callExpr;\n    }\n\n    const jsonString = template.text;\n\n    // Validate and parse JSON at compile time\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(jsonString);\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      ctx.reportError(callExpr, `Invalid JSON: ${msg}`);\n      return callExpr;\n    }\n\n    // Convert to AST\n    return jsonToAst(factory, parsed);\n  },\n});\n\nfunction jsonToAst(factory: ts.NodeFactory, value: unknown): ts.Expression {\n  if (value === null) {\n    return factory.createNull();\n  }\n\n  if (typeof value === \"string\") {\n    return factory.createStringLiteral(value);\n  }\n\n  if (typeof value === \"number\") {\n    return factory.createNumericLiteral(value);\n  }\n\n  if (typeof value === \"boolean\") {\n    return value ? factory.createTrue() : factory.createFalse();\n  }\n\n  if (Array.isArray(value)) {\n    return factory.createArrayLiteralExpression(\n      value.map((v) => jsonToAst(factory, v)),\n    );\n  }\n\n  if (typeof value === \"object\") {\n    const properties = Object.entries(value as Record<string, unknown>).map(\n      ([key, val]) =>\n        factory.createPropertyAssignment(\n          /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)\n            ? factory.createIdentifier(key)\n            : factory.createStringLiteral(key),\n          jsonToAst(factory, val),\n        ),\n    );\n    return factory.createObjectLiteralExpression(properties, true);\n  }\n\n  return factory.createIdentifier(\"undefined\");\n}\n\n// ============================================================================\n// Raw String (no escape processing)\n// ============================================================================\n\nexport const rawMacro = defineExpressionMacro({\n  name: \"raw\",\n  description: \"Raw string without escape processing\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(callExpr, \"raw expects a template literal\");\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    if (ts.isNoSubstitutionTemplateLiteral(template)) {\n      // Get the raw text (with escape sequences preserved)\n      return factory.createStringLiteral(template.rawText ?? template.text);\n    }\n\n    // For templates with substitutions, concatenate raw parts\n    if (ts.isTemplateExpression(template)) {\n      let result: ts.Expression = factory.createStringLiteral(\n        template.head.rawText ?? template.head.text,\n      );\n\n      for (const span of template.templateSpans) {\n        result = concatStrings(factory, result, span.expression);\n        result = concatStrings(\n          factory,\n          result,\n          factory.createStringLiteral(\n            span.literal.rawText ?? span.literal.text,\n          ),\n        );\n      }\n\n      return result;\n    }\n\n    return callExpr;\n  },\n});\n\n// ============================================================================\n// Registration\n// ============================================================================\n\nexport function register(): void {\n  globalRegistry.register(regexMacro);\n  globalRegistry.register(htmlMacro);\n  globalRegistry.register(fmtMacro);\n  globalRegistry.register(jsonMacro);\n  globalRegistry.register(rawMacro);\n}\n\n// Auto-register\nregister();\n\n// ============================================================================\n// Runtime Helper (injected when html macro is used)\n// ============================================================================\n\n/**\n * HTML escape function - used by the html macro\n */\nexport function __typemacro_escapeHtml(str: unknown): string {\n  const s = String(str);\n  return s\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n"],"mappings":"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","names":[]}