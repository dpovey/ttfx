"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  __typemacro_escapeHtml: () => __typemacro_escapeHtml,
  fmtMacro: () => fmtMacro,
  htmlMacro: () => htmlMacro,
  jsonMacro: () => jsonMacro,
  rawMacro: () => rawMacro,
  regexMacro: () => regexMacro,
  register: () => register
});
module.exports = __toCommonJS(index_exports);
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var regexMacro = (0, import_core.defineExpressionMacro)({
  name: "regex",
  description: "Create compile-time validated regular expressions",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "regex expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isNoSubstitutionTemplateLiteral(template)) {
      ctx.reportError(callExpr, "regex does not support interpolations");
      return callExpr;
    }
    const pattern = template.text;
    try {
      new RegExp(pattern);
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      ctx.reportError(callExpr, `Invalid regular expression: ${msg}`);
      return callExpr;
    }
    return factory.createNewExpression(
      factory.createIdentifier("RegExp"),
      void 0,
      [factory.createStringLiteral(pattern)]
    );
  }
});
var htmlMacro = (0, import_core.defineExpressionMacro)({
  name: "html",
  description: "Create HTML with automatic XSS escaping",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "html expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
      return factory.createStringLiteral(template.text);
    }
    if (ts.isTemplateExpression(template)) {
      let result = factory.createStringLiteral(
        template.head.text
      );
      for (const span of template.templateSpans) {
        const escapedValue = factory.createCallExpression(
          factory.createIdentifier("__typemacro_escapeHtml"),
          void 0,
          [span.expression]
        );
        result = factory.createBinaryExpression(
          result,
          factory.createToken(ts.SyntaxKind.PlusToken),
          escapedValue
        );
        if (span.literal.text) {
          result = factory.createBinaryExpression(
            result,
            factory.createToken(ts.SyntaxKind.PlusToken),
            factory.createStringLiteral(span.literal.text)
          );
        }
      }
      return result;
    }
    return callExpr;
  }
});
var fmtMacro = (0, import_core.defineExpressionMacro)({
  name: "fmt",
  description: "Printf-style formatting with type checking",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "fmt expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isTemplateExpression(template)) {
      if (ts.isNoSubstitutionTemplateLiteral(template)) {
        return factory.createStringLiteral(template.text);
      }
      return callExpr;
    }
    let result = factory.createStringLiteral("");
    const headParts = parseFormatString(template.head.text);
    for (const part of headParts) {
      if (part.type === "literal") {
        result = concatStrings(
          factory,
          result,
          factory.createStringLiteral(part.value)
        );
      }
    }
    for (let i = 0; i < template.templateSpans.length; i++) {
      const span = template.templateSpans[i];
      const formattedValue = factory.createCallExpression(
        factory.createIdentifier("String"),
        void 0,
        [span.expression]
      );
      result = concatStrings(factory, result, formattedValue);
      const literalParts = parseFormatString(span.literal.text);
      for (const part of literalParts) {
        if (part.type === "literal") {
          result = concatStrings(
            factory,
            result,
            factory.createStringLiteral(part.value)
          );
        }
      }
    }
    return result;
  }
});
function parseFormatString(str) {
  return [{ type: "literal", value: str }];
}
function concatStrings(factory, left, right) {
  if (ts.isStringLiteral(left) && left.text === "") {
    return right;
  }
  return factory.createBinaryExpression(
    left,
    factory.createToken(ts.SyntaxKind.PlusToken),
    right
  );
}
var jsonMacro = (0, import_core.defineExpressionMacro)({
  name: "json",
  description: "Parse and validate JSON at compile time",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "json expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isNoSubstitutionTemplateLiteral(template)) {
      ctx.reportError(
        callExpr,
        "json does not support interpolations - use a regular object literal"
      );
      return callExpr;
    }
    const jsonString = template.text;
    let parsed;
    try {
      parsed = JSON.parse(jsonString);
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      ctx.reportError(callExpr, `Invalid JSON: ${msg}`);
      return callExpr;
    }
    return jsonToAst(factory, parsed);
  }
});
function jsonToAst(factory, value) {
  if (value === null) {
    return factory.createNull();
  }
  if (typeof value === "string") {
    return factory.createStringLiteral(value);
  }
  if (typeof value === "number") {
    return factory.createNumericLiteral(value);
  }
  if (typeof value === "boolean") {
    return value ? factory.createTrue() : factory.createFalse();
  }
  if (Array.isArray(value)) {
    return factory.createArrayLiteralExpression(
      value.map((v) => jsonToAst(factory, v))
    );
  }
  if (typeof value === "object") {
    const properties = Object.entries(value).map(
      ([key, val]) => factory.createPropertyAssignment(
        /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? factory.createIdentifier(key) : factory.createStringLiteral(key),
        jsonToAst(factory, val)
      )
    );
    return factory.createObjectLiteralExpression(properties, true);
  }
  return factory.createIdentifier("undefined");
}
var rawMacro = (0, import_core.defineExpressionMacro)({
  name: "raw",
  description: "Raw string without escape processing",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "raw expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
      return factory.createStringLiteral(template.rawText ?? template.text);
    }
    if (ts.isTemplateExpression(template)) {
      let result = factory.createStringLiteral(
        template.head.rawText ?? template.head.text
      );
      for (const span of template.templateSpans) {
        result = concatStrings(factory, result, span.expression);
        result = concatStrings(
          factory,
          result,
          factory.createStringLiteral(
            span.literal.rawText ?? span.literal.text
          )
        );
      }
      return result;
    }
    return callExpr;
  }
});
function register() {
  import_core.globalRegistry.register(regexMacro);
  import_core.globalRegistry.register(htmlMacro);
  import_core.globalRegistry.register(fmtMacro);
  import_core.globalRegistry.register(jsonMacro);
  import_core.globalRegistry.register(rawMacro);
}
register();
function __typemacro_escapeHtml(str) {
  const s = String(str);
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  __typemacro_escapeHtml,
  fmtMacro,
  htmlMacro,
  jsonMacro,
  rawMacro,
  regexMacro,
  register
});
//# sourceMappingURL=index.cjs.map