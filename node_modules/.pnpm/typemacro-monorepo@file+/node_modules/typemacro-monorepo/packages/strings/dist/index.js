// src/index.ts
import * as ts from "typescript";
import { defineExpressionMacro, globalRegistry } from "@typemacro/core";
var regexMacro = defineExpressionMacro({
  name: "regex",
  description: "Create compile-time validated regular expressions",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "regex expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isNoSubstitutionTemplateLiteral(template)) {
      ctx.reportError(callExpr, "regex does not support interpolations");
      return callExpr;
    }
    const pattern = template.text;
    try {
      new RegExp(pattern);
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      ctx.reportError(callExpr, `Invalid regular expression: ${msg}`);
      return callExpr;
    }
    return factory.createNewExpression(
      factory.createIdentifier("RegExp"),
      void 0,
      [factory.createStringLiteral(pattern)]
    );
  }
});
var htmlMacro = defineExpressionMacro({
  name: "html",
  description: "Create HTML with automatic XSS escaping",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "html expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
      return factory.createStringLiteral(template.text);
    }
    if (ts.isTemplateExpression(template)) {
      let result = factory.createStringLiteral(
        template.head.text
      );
      for (const span of template.templateSpans) {
        const escapedValue = factory.createCallExpression(
          factory.createIdentifier("__typemacro_escapeHtml"),
          void 0,
          [span.expression]
        );
        result = factory.createBinaryExpression(
          result,
          factory.createToken(ts.SyntaxKind.PlusToken),
          escapedValue
        );
        if (span.literal.text) {
          result = factory.createBinaryExpression(
            result,
            factory.createToken(ts.SyntaxKind.PlusToken),
            factory.createStringLiteral(span.literal.text)
          );
        }
      }
      return result;
    }
    return callExpr;
  }
});
var fmtMacro = defineExpressionMacro({
  name: "fmt",
  description: "Printf-style formatting with type checking",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "fmt expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isTemplateExpression(template)) {
      if (ts.isNoSubstitutionTemplateLiteral(template)) {
        return factory.createStringLiteral(template.text);
      }
      return callExpr;
    }
    let result = factory.createStringLiteral("");
    const headParts = parseFormatString(template.head.text);
    for (const part of headParts) {
      if (part.type === "literal") {
        result = concatStrings(
          factory,
          result,
          factory.createStringLiteral(part.value)
        );
      }
    }
    for (let i = 0; i < template.templateSpans.length; i++) {
      const span = template.templateSpans[i];
      const formattedValue = factory.createCallExpression(
        factory.createIdentifier("String"),
        void 0,
        [span.expression]
      );
      result = concatStrings(factory, result, formattedValue);
      const literalParts = parseFormatString(span.literal.text);
      for (const part of literalParts) {
        if (part.type === "literal") {
          result = concatStrings(
            factory,
            result,
            factory.createStringLiteral(part.value)
          );
        }
      }
    }
    return result;
  }
});
function parseFormatString(str) {
  return [{ type: "literal", value: str }];
}
function concatStrings(factory, left, right) {
  if (ts.isStringLiteral(left) && left.text === "") {
    return right;
  }
  return factory.createBinaryExpression(
    left,
    factory.createToken(ts.SyntaxKind.PlusToken),
    right
  );
}
var jsonMacro = defineExpressionMacro({
  name: "json",
  description: "Parse and validate JSON at compile time",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "json expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (!ts.isNoSubstitutionTemplateLiteral(template)) {
      ctx.reportError(
        callExpr,
        "json does not support interpolations - use a regular object literal"
      );
      return callExpr;
    }
    const jsonString = template.text;
    let parsed;
    try {
      parsed = JSON.parse(jsonString);
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      ctx.reportError(callExpr, `Invalid JSON: ${msg}`);
      return callExpr;
    }
    return jsonToAst(factory, parsed);
  }
});
function jsonToAst(factory, value) {
  if (value === null) {
    return factory.createNull();
  }
  if (typeof value === "string") {
    return factory.createStringLiteral(value);
  }
  if (typeof value === "number") {
    return factory.createNumericLiteral(value);
  }
  if (typeof value === "boolean") {
    return value ? factory.createTrue() : factory.createFalse();
  }
  if (Array.isArray(value)) {
    return factory.createArrayLiteralExpression(
      value.map((v) => jsonToAst(factory, v))
    );
  }
  if (typeof value === "object") {
    const properties = Object.entries(value).map(
      ([key, val]) => factory.createPropertyAssignment(
        /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? factory.createIdentifier(key) : factory.createStringLiteral(key),
        jsonToAst(factory, val)
      )
    );
    return factory.createObjectLiteralExpression(properties, true);
  }
  return factory.createIdentifier("undefined");
}
var rawMacro = defineExpressionMacro({
  name: "raw",
  description: "Raw string without escape processing",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(callExpr, "raw expects a template literal");
      return callExpr;
    }
    const template = args[0];
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
      return factory.createStringLiteral(template.rawText ?? template.text);
    }
    if (ts.isTemplateExpression(template)) {
      let result = factory.createStringLiteral(
        template.head.rawText ?? template.head.text
      );
      for (const span of template.templateSpans) {
        result = concatStrings(factory, result, span.expression);
        result = concatStrings(
          factory,
          result,
          factory.createStringLiteral(
            span.literal.rawText ?? span.literal.text
          )
        );
      }
      return result;
    }
    return callExpr;
  }
});
function register() {
  globalRegistry.register(regexMacro);
  globalRegistry.register(htmlMacro);
  globalRegistry.register(fmtMacro);
  globalRegistry.register(jsonMacro);
  globalRegistry.register(rawMacro);
}
register();
function __typemacro_escapeHtml(str) {
  const s = String(str);
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
export {
  __typemacro_escapeHtml,
  fmtMacro,
  htmlMacro,
  jsonMacro,
  rawMacro,
  regexMacro,
  register
};
//# sourceMappingURL=index.js.map