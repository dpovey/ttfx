"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  clearRegistries: () => clearRegistries,
  derivingAttribute: () => derivingAttribute,
  extendMacro: () => extendMacro,
  findExtensionMethod: () => findExtensionMethod,
  getInstances: () => getInstances,
  getTypeclasses: () => getTypeclasses,
  instanceAttribute: () => instanceAttribute,
  register: () => register,
  summonMacro: () => summonMacro,
  typeclassAttribute: () => typeclassAttribute
});
module.exports = __toCommonJS(index_exports);
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var typeclassRegistry = /* @__PURE__ */ new Map();
var instanceRegistry = /* @__PURE__ */ new Map();
function instanceKey(typeclass, forType) {
  return `${typeclass}<${forType}>`;
}
function clearRegistries() {
  typeclassRegistry.clear();
  instanceRegistry.clear();
}
function getTypeclasses() {
  return new Map(typeclassRegistry);
}
function getInstances() {
  return new Map(instanceRegistry);
}
var typeclassAttribute = (0, import_core.defineAttributeMacro)({
  name: "typeclass",
  module: "@typemacro/typeclass",
  description: "Define a typeclass interface",
  validTargets: ["interface"],
  expand(ctx, decorator, target, _args) {
    if (!ts.isInterfaceDeclaration(target) || !target.name) {
      ctx.reportError(
        decorator,
        "@typeclass can only be applied to named interfaces"
      );
      return target;
    }
    const typeclassName = target.name.text;
    const methods = [];
    for (const member of target.members) {
      if (ts.isMethodSignature(member) && member.name) {
        const methodName = ts.isIdentifier(member.name) ? member.name.text : String(member.name);
        const typeParams = member.typeParameters?.map((tp) => tp.name.text) ?? [];
        const params = [];
        for (const param of member.parameters) {
          if (ts.isIdentifier(param.name)) {
            params.push({
              name: param.name.text,
              type: param.type ? ctx.typeChecker.typeToString(
                ctx.typeChecker.getTypeAtLocation(param.type)
              ) : "unknown"
            });
          }
        }
        const returnType = member.type ? ctx.typeChecker.typeToString(
          ctx.typeChecker.getTypeAtLocation(member.type)
        ) : "void";
        methods.push({
          name: methodName,
          typeParams,
          params,
          returnType
        });
      }
    }
    typeclassRegistry.set(typeclassName, {
      name: typeclassName,
      methods
    });
    return target;
  }
});
var instanceAttribute = (0, import_core.defineAttributeMacro)({
  name: "instance",
  module: "@typemacro/typeclass",
  description: "Define a typeclass instance",
  // Note: This macro handles variable declarations which aren't standard
  // decorator targets. Validation is done in expand().
  validTargets: ["property"],
  expand(ctx, decorator, target, args) {
    if (!ts.isVariableDeclaration(target)) {
      ctx.reportError(
        decorator,
        "@instance can only be applied to variable declarations"
      );
      return target;
    }
    if (args.length < 2) {
      ctx.reportError(
        decorator,
        "@instance requires typeclass name and type argument"
      );
      return target;
    }
    const typeclassExpr = args[0];
    const typeExpr = args[1];
    const typeclassName = ts.isIdentifier(typeclassExpr) ? typeclassExpr.text : void 0;
    const forType = ts.isIdentifier(typeExpr) ? typeExpr.text : void 0;
    if (!typeclassName || !forType) {
      ctx.reportError(
        decorator,
        "@instance requires identifier arguments: @instance(Typeclass, Type)"
      );
      return target;
    }
    if (!typeclassRegistry.has(typeclassName)) {
    }
    const initExpr = target.initializer;
    if (!initExpr) {
      ctx.reportError(
        decorator,
        "@instance variable must have an initializer"
      );
      return target;
    }
    const key = instanceKey(typeclassName, forType);
    instanceRegistry.set(key, {
      typeclass: typeclassName,
      forType,
      expression: initExpr
    });
    return target;
  }
});
var derivingAttribute = (0, import_core.defineAttributeMacro)({
  name: "deriving",
  module: "@typemacro/typeclass",
  description: "Auto-derive typeclass instances for a type",
  validTargets: ["interface", "class", "type"],
  expand(ctx, decorator, target, args) {
    let typeName;
    if (ts.isInterfaceDeclaration(target) && target.name) {
      typeName = target.name.text;
    } else if (ts.isClassDeclaration(target) && target.name) {
      typeName = target.name.text;
    } else if (ts.isTypeAliasDeclaration(target)) {
      typeName = target.name.text;
    }
    if (!typeName) {
      ctx.reportError(
        decorator,
        "@deriving can only be applied to named types"
      );
      return target;
    }
    const derivedStatements = [];
    for (const arg of args) {
      if (!ts.isIdentifier(arg)) continue;
      const typeclassName = arg.text;
      const typeclass = typeclassRegistry.get(typeclassName);
      if (!typeclass) {
        ctx.reportError(
          decorator,
          `Unknown typeclass: ${typeclassName}. Make sure it's defined with @typeclass`
        );
        continue;
      }
      const instanceCode = generateDerivedInstance(ctx, typeclass, typeName);
      if (instanceCode) {
        derivedStatements.push(...ctx.parseStatements(instanceCode));
        const key = instanceKey(typeclassName, typeName);
        instanceRegistry.set(key, {
          typeclass: typeclassName,
          forType: typeName,
          expression: ctx.factory.createIdentifier(
            `${uncapitalize(typeName)}${typeclassName}`
          )
        });
      }
    }
    return [target, ...derivedStatements];
  }
});
function generateDerivedInstance(_ctx, typeclass, typeName) {
  const instanceName = `${uncapitalize(typeName)}${typeclass.name}`;
  switch (typeclass.name) {
    case "Show":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  show: (a) => JSON.stringify(a)
};
`;
    case "Eq":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  equals: (a, b) => JSON.stringify(a) === JSON.stringify(b)
};
`;
    case "Ord":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  compare: (a, b) => {
    const aStr = JSON.stringify(a);
    const bStr = JSON.stringify(b);
    return aStr < bStr ? -1 : aStr > bStr ? 1 : 0;
  }
};
`;
    case "Hash":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  hash: (a) => {
    const str = JSON.stringify(a);
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
  }
};
`;
    default:
      return null;
  }
}
var summonMacro = (0, import_core.defineExpressionMacro)({
  name: "summon",
  module: "@typemacro/typeclass",
  description: "Summon a typeclass instance at compile time",
  expand(ctx, callExpr, _args) {
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "summon<T>() requires exactly one type argument"
      );
      return callExpr;
    }
    const typeArg = typeArgs[0];
    if (!ts.isTypeReferenceNode(typeArg) || !ts.isIdentifier(typeArg.typeName)) {
      ctx.reportError(
        callExpr,
        "summon<T>() type argument must be a typeclass application like Show<number>"
      );
      return callExpr;
    }
    const typeclassName = typeArg.typeName.text;
    const typeArgsOfTypeclass = typeArg.typeArguments;
    if (!typeArgsOfTypeclass || typeArgsOfTypeclass.length === 0) {
      ctx.reportError(
        callExpr,
        `summon<${typeclassName}>() requires a type argument, e.g., summon<${typeclassName}<number>>()`
      );
      return callExpr;
    }
    const forType = ctx.typeChecker.typeToString(
      ctx.typeChecker.getTypeAtLocation(typeArgsOfTypeclass[0])
    );
    const key = instanceKey(typeclassName, forType);
    const instance = instanceRegistry.get(key);
    if (!instance) {
      ctx.reportError(
        callExpr,
        `No instance found for ${typeclassName}<${forType}>. Define one with @instance`
      );
      return callExpr;
    }
    return instance.expression;
  }
});
var extendMacro = (0, import_core.defineExpressionMacro)({
  name: "extend",
  module: "@typemacro/typeclass",
  description: "Extend a value with typeclass methods (compile-time resolution)",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "extend() requires exactly one argument");
      return callExpr;
    }
    const value = args[0];
    const valueType = ctx.getTypeOf(value);
    const typeName = ctx.typeChecker.typeToString(valueType).split("<")[0].trim();
    const methods = [];
    for (const [key, instance] of instanceRegistry) {
      if (instance.forType === typeName) {
        const typeclass = typeclassRegistry.get(instance.typeclass);
        if (typeclass) {
          for (const method of typeclass.methods) {
            methods.push({ name: method.name, instance });
          }
        }
      }
    }
    if (methods.length === 0) {
      ctx.reportWarning?.(
        callExpr,
        `No typeclass instances found for type ${typeName}`
      );
      return value;
    }
    const factory = ctx.factory;
    const properties = methods.map(({ name, instance }) => {
      return factory.createPropertyAssignment(
        name,
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          factory.createCallExpression(
            factory.createPropertyAccessExpression(instance.expression, name),
            void 0,
            [value]
          )
        )
      );
    });
    properties.unshift(
      factory.createPropertyAssignment("value", value)
    );
    return factory.createObjectLiteralExpression(properties, true);
  }
});
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function findExtensionMethod(typeName, methodName) {
  for (const [, instance] of instanceRegistry) {
    if (instance.forType === typeName) {
      const typeclass = typeclassRegistry.get(instance.typeclass);
      if (typeclass) {
        const hasMethod = typeclass.methods.some((m) => m.name === methodName);
        if (hasMethod) {
          return { instance, typeclass };
        }
      }
    }
  }
  return void 0;
}
function register() {
  import_core.globalRegistry.register(typeclassAttribute);
  import_core.globalRegistry.register(instanceAttribute);
  import_core.globalRegistry.register(derivingAttribute);
  import_core.globalRegistry.register(summonMacro);
  import_core.globalRegistry.register(extendMacro);
}
register();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  clearRegistries,
  derivingAttribute,
  extendMacro,
  findExtensionMethod,
  getInstances,
  getTypeclasses,
  instanceAttribute,
  register,
  summonMacro,
  typeclassAttribute
});
//# sourceMappingURL=index.cjs.map