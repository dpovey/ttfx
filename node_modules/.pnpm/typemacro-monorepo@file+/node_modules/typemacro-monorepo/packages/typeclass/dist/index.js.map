{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Typeclass Macros - Scala 3-style typeclasses with auto-derivation\n *\n * Provides compile-time typeclass pattern support with:\n * - @typeclass decorator to define typeclass interfaces\n * - @instance decorator to provide instances\n * - @deriving decorator for auto-derivation\n * - summon<T>() to get instances at compile time\n * - extend<T>() to add extension methods\n *\n * Usage:\n *   @typeclass\n *   interface Show<A> {\n *     show(a: A): string;\n *   }\n *\n *   @instance(Show, Number)\n *   const numberShow: Show<number> = {\n *     show: (n) => String(n)\n *   };\n *\n *   // Extension method usage:\n *   extend(myValue).show() // Works if Show instance exists for myValue's type\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  defineAttributeMacro,\n  globalRegistry,\n  globalExtensionRegistry,\n  MacroContext,\n  AttributeTarget,\n} from \"@typemacro/core\";\n\n// ============================================================================\n// Registry for typeclasses and instances (compile-time)\n// ============================================================================\n\ninterface TypeclassInfo {\n  name: string;\n  methods: Array<{\n    name: string;\n    typeParams: string[];\n    params: Array<{ name: string; type: string }>;\n    returnType: string;\n  }>;\n}\n\ninterface InstanceInfo {\n  typeclass: string;\n  forType: string;\n  expression: ts.Expression;\n}\n\n/**\n * Registry of all typeclasses defined with @typeclass\n */\nconst typeclassRegistry = new Map<string, TypeclassInfo>();\n\n/**\n * Registry of all instances defined with @instance\n */\nconst instanceRegistry = new Map<string, InstanceInfo>();\n\n/**\n * Get the key for an instance: \"Show<number>\"\n */\nfunction instanceKey(typeclass: string, forType: string): string {\n  return `${typeclass}<${forType}>`;\n}\n\n/**\n * Clear registries (for testing)\n */\nexport function clearRegistries(): void {\n  typeclassRegistry.clear();\n  instanceRegistry.clear();\n}\n\n/**\n * Get all registered typeclasses\n */\nexport function getTypeclasses(): Map<string, TypeclassInfo> {\n  return new Map(typeclassRegistry);\n}\n\n/**\n * Get all registered instances\n */\nexport function getInstances(): Map<string, InstanceInfo> {\n  return new Map(instanceRegistry);\n}\n\n// ============================================================================\n// @typeclass Attribute Macro\n// ============================================================================\n\nexport const typeclassAttribute = defineAttributeMacro({\n  name: \"typeclass\",\n  module: \"@typemacro/typeclass\",\n  description: \"Define a typeclass interface\",\n  validTargets: [\"interface\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    _args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (!ts.isInterfaceDeclaration(target) || !target.name) {\n      ctx.reportError(\n        decorator,\n        \"@typeclass can only be applied to named interfaces\",\n      );\n      return target;\n    }\n\n    const typeclassName = target.name.text;\n\n    // Extract method signatures\n    const methods: TypeclassInfo[\"methods\"] = [];\n\n    for (const member of target.members) {\n      if (ts.isMethodSignature(member) && member.name) {\n        const methodName = ts.isIdentifier(member.name)\n          ? member.name.text\n          : String(member.name);\n\n        const typeParams =\n          member.typeParameters?.map((tp) => tp.name.text) ?? [];\n\n        const params: Array<{ name: string; type: string }> = [];\n        for (const param of member.parameters) {\n          if (ts.isIdentifier(param.name)) {\n            params.push({\n              name: param.name.text,\n              type: param.type\n                ? ctx.typeChecker.typeToString(\n                    ctx.typeChecker.getTypeAtLocation(param.type),\n                  )\n                : \"unknown\",\n            });\n          }\n        }\n\n        const returnType = member.type\n          ? ctx.typeChecker.typeToString(\n              ctx.typeChecker.getTypeAtLocation(member.type),\n            )\n          : \"void\";\n\n        methods.push({\n          name: methodName,\n          typeParams,\n          params,\n          returnType,\n        });\n\n        // Note: Extension methods are registered when instances are created,\n        // not when the typeclass is defined. The typeclass definition just\n        // describes the interface; actual extension methods require a concrete\n        // type binding from @instance or @deriving.\n      }\n    }\n\n    // Register the typeclass\n    typeclassRegistry.set(typeclassName, {\n      name: typeclassName,\n      methods,\n    });\n\n    // Return the interface unchanged\n    return target;\n  },\n});\n\n// ============================================================================\n// @instance Attribute Macro\n// ============================================================================\n\nexport const instanceAttribute = defineAttributeMacro({\n  name: \"instance\",\n  module: \"@typemacro/typeclass\",\n  description: \"Define a typeclass instance\",\n  // Note: This macro handles variable declarations which aren't standard\n  // decorator targets. Validation is done in expand().\n  validTargets: [\"property\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (!ts.isVariableDeclaration(target)) {\n      ctx.reportError(\n        decorator,\n        \"@instance can only be applied to variable declarations\",\n      );\n      return target;\n    }\n\n    // Expect: @instance(TypeclassName, TypeArg)\n    if (args.length < 2) {\n      ctx.reportError(\n        decorator,\n        \"@instance requires typeclass name and type argument\",\n      );\n      return target;\n    }\n\n    const typeclassExpr = args[0];\n    const typeExpr = args[1];\n\n    // Extract names\n    const typeclassName = ts.isIdentifier(typeclassExpr)\n      ? typeclassExpr.text\n      : undefined;\n\n    const forType = ts.isIdentifier(typeExpr) ? typeExpr.text : undefined;\n\n    if (!typeclassName || !forType) {\n      ctx.reportError(\n        decorator,\n        \"@instance requires identifier arguments: @instance(Typeclass, Type)\",\n      );\n      return target;\n    }\n\n    // Verify typeclass exists\n    if (!typeclassRegistry.has(typeclassName)) {\n      // Soft warning: typeclass may be defined in another file\n      // that hasn't been processed yet\n    }\n\n    // Store the initializer expression\n    const initExpr = target.initializer;\n    if (!initExpr) {\n      ctx.reportError(\n        decorator,\n        \"@instance variable must have an initializer\",\n      );\n      return target;\n    }\n\n    // Register the instance\n    const key = instanceKey(typeclassName, forType);\n    instanceRegistry.set(key, {\n      typeclass: typeclassName,\n      forType,\n      expression: initExpr,\n    });\n\n    // Return the variable unchanged\n    return target;\n  },\n});\n\n// ============================================================================\n// @deriving Attribute Macro - Auto-derive typeclass instances\n// ============================================================================\n\nexport const derivingAttribute = defineAttributeMacro({\n  name: \"deriving\",\n  module: \"@typemacro/typeclass\",\n  description: \"Auto-derive typeclass instances for a type\",\n  validTargets: [\"interface\", \"class\", \"type\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    let typeName: string | undefined;\n\n    if (ts.isInterfaceDeclaration(target) && target.name) {\n      typeName = target.name.text;\n    } else if (ts.isClassDeclaration(target) && target.name) {\n      typeName = target.name.text;\n    } else if (ts.isTypeAliasDeclaration(target)) {\n      typeName = target.name.text;\n    }\n\n    if (!typeName) {\n      ctx.reportError(\n        decorator,\n        \"@deriving can only be applied to named types\",\n      );\n      return target;\n    }\n\n    // Generate derived instances\n    const derivedStatements: ts.Statement[] = [];\n\n    for (const arg of args) {\n      if (!ts.isIdentifier(arg)) continue;\n\n      const typeclassName = arg.text;\n      const typeclass = typeclassRegistry.get(typeclassName);\n\n      if (!typeclass) {\n        ctx.reportError(\n          decorator,\n          `Unknown typeclass: ${typeclassName}. Make sure it's defined with @typeclass`,\n        );\n        continue;\n      }\n\n      // Generate a derived instance based on the typeclass\n      const instanceCode = generateDerivedInstance(ctx, typeclass, typeName);\n      if (instanceCode) {\n        derivedStatements.push(...ctx.parseStatements(instanceCode));\n\n        // Register the derived instance\n        const key = instanceKey(typeclassName, typeName);\n        instanceRegistry.set(key, {\n          typeclass: typeclassName,\n          forType: typeName,\n          expression: ctx.factory.createIdentifier(\n            `${uncapitalize(typeName)}${typeclassName}`,\n          ),\n        });\n      }\n    }\n\n    // Return target plus derived instance declarations\n    return [target, ...derivedStatements];\n  },\n});\n\n/**\n * Generate a derived instance implementation\n */\nfunction generateDerivedInstance(\n  _ctx: MacroContext,\n  typeclass: TypeclassInfo,\n  typeName: string,\n): string | null {\n  const instanceName = `${uncapitalize(typeName)}${typeclass.name}`;\n\n  // Generate method implementations based on typeclass\n  switch (typeclass.name) {\n    case \"Show\":\n      return `\nconst ${instanceName}: ${typeclass.name}<${typeName}> = {\n  show: (a) => JSON.stringify(a)\n};\n`;\n\n    case \"Eq\":\n      return `\nconst ${instanceName}: ${typeclass.name}<${typeName}> = {\n  equals: (a, b) => JSON.stringify(a) === JSON.stringify(b)\n};\n`;\n\n    case \"Ord\":\n      return `\nconst ${instanceName}: ${typeclass.name}<${typeName}> = {\n  compare: (a, b) => {\n    const aStr = JSON.stringify(a);\n    const bStr = JSON.stringify(b);\n    return aStr < bStr ? -1 : aStr > bStr ? 1 : 0;\n  }\n};\n`;\n\n    case \"Hash\":\n      return `\nconst ${instanceName}: ${typeclass.name}<${typeName}> = {\n  hash: (a) => {\n    const str = JSON.stringify(a);\n    let hash = 5381;\n    for (let i = 0; i < str.length; i++) {\n      hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    }\n    return hash >>> 0;\n  }\n};\n`;\n\n    default:\n      // For unknown typeclasses, we can't auto-derive\n      return null;\n  }\n}\n\n// ============================================================================\n// summon<TC>() - Get a typeclass instance at compile time\n// ============================================================================\n\nexport const summonMacro = defineExpressionMacro({\n  name: \"summon\",\n  module: \"@typemacro/typeclass\",\n  description: \"Summon a typeclass instance at compile time\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    // The type argument tells us which instance to summon\n    // summon<Show<number>>() -> numberShow\n\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"summon<T>() requires exactly one type argument\",\n      );\n      return callExpr;\n    }\n\n    const typeArg = typeArgs[0];\n\n    // Parse the type reference to extract typeclass and type\n    if (!ts.isTypeReferenceNode(typeArg) || !ts.isIdentifier(typeArg.typeName)) {\n      ctx.reportError(\n        callExpr,\n        \"summon<T>() type argument must be a typeclass application like Show<number>\",\n      );\n      return callExpr;\n    }\n\n    const typeclassName = typeArg.typeName.text;\n    const typeArgsOfTypeclass = typeArg.typeArguments;\n\n    if (!typeArgsOfTypeclass || typeArgsOfTypeclass.length === 0) {\n      ctx.reportError(\n        callExpr,\n        `summon<${typeclassName}>() requires a type argument, e.g., summon<${typeclassName}<number>>()`,\n      );\n      return callExpr;\n    }\n\n    const forType = ctx.typeChecker.typeToString(\n      ctx.typeChecker.getTypeAtLocation(typeArgsOfTypeclass[0]),\n    );\n\n    // Look up the instance\n    const key = instanceKey(typeclassName, forType);\n    const instance = instanceRegistry.get(key);\n\n    if (!instance) {\n      ctx.reportError(\n        callExpr,\n        `No instance found for ${typeclassName}<${forType}>. Define one with @instance`,\n      );\n      return callExpr;\n    }\n\n    // Return the instance expression\n    return instance.expression;\n  },\n});\n\n// ============================================================================\n// extend<T>() - Create an extension wrapper with typeclass methods\n// ============================================================================\n\nexport const extendMacro = defineExpressionMacro({\n  name: \"extend\",\n  module: \"@typemacro/typeclass\",\n  description:\n    \"Extend a value with typeclass methods (compile-time resolution)\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"extend() requires exactly one argument\");\n      return callExpr;\n    }\n\n    const value = args[0];\n    const valueType = ctx.getTypeOf(value);\n    const typeName = ctx.typeChecker\n      .typeToString(valueType)\n      .split(\"<\")[0]\n      .trim();\n\n    // Find all instances for this type\n    const methods: Array<{ name: string; instance: InstanceInfo }> = [];\n\n    for (const [key, instance] of instanceRegistry) {\n      if (instance.forType === typeName) {\n        const typeclass = typeclassRegistry.get(instance.typeclass);\n        if (typeclass) {\n          for (const method of typeclass.methods) {\n            methods.push({ name: method.name, instance });\n          }\n        }\n      }\n    }\n\n    if (methods.length === 0) {\n      // No instances found, return the value as-is with a warning\n      ctx.reportWarning?.(\n        callExpr,\n        `No typeclass instances found for type ${typeName}`,\n      );\n      return value;\n    }\n\n    // Generate an object that wraps the value with extension methods\n    const factory = ctx.factory;\n\n    const properties = methods.map(({ name, instance }) => {\n      // Create: methodName: () => instance.methodName(value)\n      return factory.createPropertyAssignment(\n        name,\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createCallExpression(\n            factory.createPropertyAccessExpression(instance.expression, name),\n            undefined,\n            [value],\n          ),\n        ),\n      );\n    });\n\n    // Also include the original value\n    properties.unshift(\n      factory.createPropertyAssignment(\"value\", value),\n    );\n\n    return factory.createObjectLiteralExpression(properties, true);\n  },\n});\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction uncapitalize(str: string): string {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\n/**\n * Find an extension method for a type and method name.\n * Used by the transformer to rewrite x.show() -> showInstance.show(x)\n */\nexport function findExtensionMethod(\n  typeName: string,\n  methodName: string,\n): { instance: InstanceInfo; typeclass: TypeclassInfo } | undefined {\n  for (const [, instance] of instanceRegistry) {\n    if (instance.forType === typeName) {\n      const typeclass = typeclassRegistry.get(instance.typeclass);\n      if (typeclass) {\n        const hasMethod = typeclass.methods.some((m) => m.name === methodName);\n        if (hasMethod) {\n          return { instance, typeclass };\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Register macros with the global registry.\n * Call this function to enable typeclass macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(typeclassAttribute);\n  globalRegistry.register(instanceAttribute);\n  globalRegistry.register(derivingAttribute);\n  globalRegistry.register(summonMacro);\n  globalRegistry.register(extendMacro);\n}\n\n// Auto-register when this module is imported\nregister();\n"],"mappings":"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","names":[]}