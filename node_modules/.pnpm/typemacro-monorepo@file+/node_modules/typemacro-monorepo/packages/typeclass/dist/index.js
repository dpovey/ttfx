// src/index.ts
import * as ts from "typescript";
import {
  defineExpressionMacro,
  defineAttributeMacro,
  globalRegistry
} from "@typemacro/core";
var typeclassRegistry = /* @__PURE__ */ new Map();
var instanceRegistry = /* @__PURE__ */ new Map();
function instanceKey(typeclass, forType) {
  return `${typeclass}<${forType}>`;
}
function clearRegistries() {
  typeclassRegistry.clear();
  instanceRegistry.clear();
}
function getTypeclasses() {
  return new Map(typeclassRegistry);
}
function getInstances() {
  return new Map(instanceRegistry);
}
var typeclassAttribute = defineAttributeMacro({
  name: "typeclass",
  module: "@typemacro/typeclass",
  description: "Define a typeclass interface",
  validTargets: ["interface"],
  expand(ctx, decorator, target, _args) {
    if (!ts.isInterfaceDeclaration(target) || !target.name) {
      ctx.reportError(
        decorator,
        "@typeclass can only be applied to named interfaces"
      );
      return target;
    }
    const typeclassName = target.name.text;
    const methods = [];
    for (const member of target.members) {
      if (ts.isMethodSignature(member) && member.name) {
        const methodName = ts.isIdentifier(member.name) ? member.name.text : String(member.name);
        const typeParams = member.typeParameters?.map((tp) => tp.name.text) ?? [];
        const params = [];
        for (const param of member.parameters) {
          if (ts.isIdentifier(param.name)) {
            params.push({
              name: param.name.text,
              type: param.type ? ctx.typeChecker.typeToString(
                ctx.typeChecker.getTypeAtLocation(param.type)
              ) : "unknown"
            });
          }
        }
        const returnType = member.type ? ctx.typeChecker.typeToString(
          ctx.typeChecker.getTypeAtLocation(member.type)
        ) : "void";
        methods.push({
          name: methodName,
          typeParams,
          params,
          returnType
        });
      }
    }
    typeclassRegistry.set(typeclassName, {
      name: typeclassName,
      methods
    });
    return target;
  }
});
var instanceAttribute = defineAttributeMacro({
  name: "instance",
  module: "@typemacro/typeclass",
  description: "Define a typeclass instance",
  // Note: This macro handles variable declarations which aren't standard
  // decorator targets. Validation is done in expand().
  validTargets: ["property"],
  expand(ctx, decorator, target, args) {
    if (!ts.isVariableDeclaration(target)) {
      ctx.reportError(
        decorator,
        "@instance can only be applied to variable declarations"
      );
      return target;
    }
    if (args.length < 2) {
      ctx.reportError(
        decorator,
        "@instance requires typeclass name and type argument"
      );
      return target;
    }
    const typeclassExpr = args[0];
    const typeExpr = args[1];
    const typeclassName = ts.isIdentifier(typeclassExpr) ? typeclassExpr.text : void 0;
    const forType = ts.isIdentifier(typeExpr) ? typeExpr.text : void 0;
    if (!typeclassName || !forType) {
      ctx.reportError(
        decorator,
        "@instance requires identifier arguments: @instance(Typeclass, Type)"
      );
      return target;
    }
    if (!typeclassRegistry.has(typeclassName)) {
    }
    const initExpr = target.initializer;
    if (!initExpr) {
      ctx.reportError(
        decorator,
        "@instance variable must have an initializer"
      );
      return target;
    }
    const key = instanceKey(typeclassName, forType);
    instanceRegistry.set(key, {
      typeclass: typeclassName,
      forType,
      expression: initExpr
    });
    return target;
  }
});
var derivingAttribute = defineAttributeMacro({
  name: "deriving",
  module: "@typemacro/typeclass",
  description: "Auto-derive typeclass instances for a type",
  validTargets: ["interface", "class", "type"],
  expand(ctx, decorator, target, args) {
    let typeName;
    if (ts.isInterfaceDeclaration(target) && target.name) {
      typeName = target.name.text;
    } else if (ts.isClassDeclaration(target) && target.name) {
      typeName = target.name.text;
    } else if (ts.isTypeAliasDeclaration(target)) {
      typeName = target.name.text;
    }
    if (!typeName) {
      ctx.reportError(
        decorator,
        "@deriving can only be applied to named types"
      );
      return target;
    }
    const derivedStatements = [];
    for (const arg of args) {
      if (!ts.isIdentifier(arg)) continue;
      const typeclassName = arg.text;
      const typeclass = typeclassRegistry.get(typeclassName);
      if (!typeclass) {
        ctx.reportError(
          decorator,
          `Unknown typeclass: ${typeclassName}. Make sure it's defined with @typeclass`
        );
        continue;
      }
      const instanceCode = generateDerivedInstance(ctx, typeclass, typeName);
      if (instanceCode) {
        derivedStatements.push(...ctx.parseStatements(instanceCode));
        const key = instanceKey(typeclassName, typeName);
        instanceRegistry.set(key, {
          typeclass: typeclassName,
          forType: typeName,
          expression: ctx.factory.createIdentifier(
            `${uncapitalize(typeName)}${typeclassName}`
          )
        });
      }
    }
    return [target, ...derivedStatements];
  }
});
function generateDerivedInstance(_ctx, typeclass, typeName) {
  const instanceName = `${uncapitalize(typeName)}${typeclass.name}`;
  switch (typeclass.name) {
    case "Show":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  show: (a) => JSON.stringify(a)
};
`;
    case "Eq":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  equals: (a, b) => JSON.stringify(a) === JSON.stringify(b)
};
`;
    case "Ord":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  compare: (a, b) => {
    const aStr = JSON.stringify(a);
    const bStr = JSON.stringify(b);
    return aStr < bStr ? -1 : aStr > bStr ? 1 : 0;
  }
};
`;
    case "Hash":
      return `
const ${instanceName}: ${typeclass.name}<${typeName}> = {
  hash: (a) => {
    const str = JSON.stringify(a);
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return hash >>> 0;
  }
};
`;
    default:
      return null;
  }
}
var summonMacro = defineExpressionMacro({
  name: "summon",
  module: "@typemacro/typeclass",
  description: "Summon a typeclass instance at compile time",
  expand(ctx, callExpr, _args) {
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "summon<T>() requires exactly one type argument"
      );
      return callExpr;
    }
    const typeArg = typeArgs[0];
    if (!ts.isTypeReferenceNode(typeArg) || !ts.isIdentifier(typeArg.typeName)) {
      ctx.reportError(
        callExpr,
        "summon<T>() type argument must be a typeclass application like Show<number>"
      );
      return callExpr;
    }
    const typeclassName = typeArg.typeName.text;
    const typeArgsOfTypeclass = typeArg.typeArguments;
    if (!typeArgsOfTypeclass || typeArgsOfTypeclass.length === 0) {
      ctx.reportError(
        callExpr,
        `summon<${typeclassName}>() requires a type argument, e.g., summon<${typeclassName}<number>>()`
      );
      return callExpr;
    }
    const forType = ctx.typeChecker.typeToString(
      ctx.typeChecker.getTypeAtLocation(typeArgsOfTypeclass[0])
    );
    const key = instanceKey(typeclassName, forType);
    const instance = instanceRegistry.get(key);
    if (!instance) {
      ctx.reportError(
        callExpr,
        `No instance found for ${typeclassName}<${forType}>. Define one with @instance`
      );
      return callExpr;
    }
    return instance.expression;
  }
});
var extendMacro = defineExpressionMacro({
  name: "extend",
  module: "@typemacro/typeclass",
  description: "Extend a value with typeclass methods (compile-time resolution)",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "extend() requires exactly one argument");
      return callExpr;
    }
    const value = args[0];
    const valueType = ctx.getTypeOf(value);
    const typeName = ctx.typeChecker.typeToString(valueType).split("<")[0].trim();
    const methods = [];
    for (const [key, instance] of instanceRegistry) {
      if (instance.forType === typeName) {
        const typeclass = typeclassRegistry.get(instance.typeclass);
        if (typeclass) {
          for (const method of typeclass.methods) {
            methods.push({ name: method.name, instance });
          }
        }
      }
    }
    if (methods.length === 0) {
      ctx.reportWarning?.(
        callExpr,
        `No typeclass instances found for type ${typeName}`
      );
      return value;
    }
    const factory = ctx.factory;
    const properties = methods.map(({ name, instance }) => {
      return factory.createPropertyAssignment(
        name,
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          factory.createCallExpression(
            factory.createPropertyAccessExpression(instance.expression, name),
            void 0,
            [value]
          )
        )
      );
    });
    properties.unshift(
      factory.createPropertyAssignment("value", value)
    );
    return factory.createObjectLiteralExpression(properties, true);
  }
});
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function findExtensionMethod(typeName, methodName) {
  for (const [, instance] of instanceRegistry) {
    if (instance.forType === typeName) {
      const typeclass = typeclassRegistry.get(instance.typeclass);
      if (typeclass) {
        const hasMethod = typeclass.methods.some((m) => m.name === methodName);
        if (hasMethod) {
          return { instance, typeclass };
        }
      }
    }
  }
  return void 0;
}
function register() {
  globalRegistry.register(typeclassAttribute);
  globalRegistry.register(instanceAttribute);
  globalRegistry.register(derivingAttribute);
  globalRegistry.register(summonMacro);
  globalRegistry.register(extendMacro);
}
register();
export {
  clearRegistries,
  derivingAttribute,
  extendMacro,
  findExtensionMethod,
  getInstances,
  getTypeclasses,
  instanceAttribute,
  register,
  summonMacro,
  typeclassAttribute
};
//# sourceMappingURL=index.js.map