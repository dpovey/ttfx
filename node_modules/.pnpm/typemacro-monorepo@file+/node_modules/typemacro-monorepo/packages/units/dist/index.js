// src/types.ts
var Unit = class _Unit {
  constructor(value, symbol = "") {
    this.value = value;
    this.symbol = symbol;
  }
  /**
   * Add two quantities with the same dimensions
   */
  add(other) {
    return new _Unit(this.value + other.value, this.symbol);
  }
  /**
   * Subtract two quantities with the same dimensions
   */
  sub(other) {
    return new _Unit(this.value - other.value, this.symbol);
  }
  /**
   * Multiply by another unit (dimensions add)
   */
  mul(other) {
    return new _Unit(this.value * other.value);
  }
  /**
   * Divide by another unit (dimensions subtract)
   */
  div(other) {
    return new _Unit(this.value / other.value);
  }
  /**
   * Scale by a dimensionless number
   */
  scale(factor) {
    return new _Unit(this.value * factor, this.symbol);
  }
  /**
   * Negate the value
   */
  neg() {
    return new _Unit(-this.value, this.symbol);
  }
  /**
   * Check equality with tolerance
   */
  equals(other, tolerance = 1e-10) {
    return Math.abs(this.value - other.value) < tolerance;
  }
  /**
   * Format as string
   */
  toString() {
    return this.symbol ? `${this.value} ${this.symbol}` : `${this.value}`;
  }
};
var meters = (v) => new Unit(v, "m");
var kilometers = (v) => new Unit(v * 1e3, "km");
var centimeters = (v) => new Unit(v / 100, "cm");
var millimeters = (v) => new Unit(v / 1e3, "mm");
var feet = (v) => new Unit(v * 0.3048, "ft");
var inches = (v) => new Unit(v * 0.0254, "in");
var miles = (v) => new Unit(v * 1609.344, "mi");
var kilograms = (v) => new Unit(v, "kg");
var grams = (v) => new Unit(v / 1e3, "g");
var milligrams = (v) => new Unit(v / 1e6, "mg");
var pounds = (v) => new Unit(v * 0.453592, "lb");
var seconds = (v) => new Unit(v, "s");
var minutes = (v) => new Unit(v * 60, "min");
var hours = (v) => new Unit(v * 3600, "h");
var days = (v) => new Unit(v * 86400, "d");
var milliseconds = (v) => new Unit(v / 1e3, "ms");
var metersPerSecond = (v) => new Unit(v, "m/s");
var kilometersPerHour = (v) => new Unit(v / 3.6, "km/h");
var milesPerHour = (v) => new Unit(v * 0.44704, "mph");
var metersPerSecondSquared = (v) => new Unit(v, "m/s\xB2");
var newtons = (v) => new Unit(v, "N");
var joules = (v) => new Unit(v, "J");
var kilojoules = (v) => new Unit(v * 1e3, "kJ");
var calories = (v) => new Unit(v * 4.184, "cal");
var kilocalories = (v) => new Unit(v * 4184, "kcal");
var watts = (v) => new Unit(v, "W");
var kilowatts = (v) => new Unit(v * 1e3, "kW");
var kelvin = (v) => new Unit(v, "K");
var celsius = (v) => new Unit(v, "\xB0C");
var pascals = (v) => new Unit(v, "Pa");
var kilopascals = (v) => new Unit(v * 1e3, "kPa");
var atmospheres = (v) => new Unit(v * 101325, "atm");
function assertSameDimensions(_a, _b) {
  return true;
}

// src/macro.ts
import * as ts from "typescript";
import { defineExpressionMacro, globalRegistry } from "@typemacro/core";
var UNIT_MAP = {
  // Length
  m: { fn: "meters", factor: 1 },
  meter: { fn: "meters", factor: 1 },
  meters: { fn: "meters", factor: 1 },
  km: { fn: "kilometers", factor: 1 },
  kilometer: { fn: "kilometers", factor: 1 },
  kilometers: { fn: "kilometers", factor: 1 },
  cm: { fn: "centimeters", factor: 1 },
  centimeter: { fn: "centimeters", factor: 1 },
  centimeters: { fn: "centimeters", factor: 1 },
  mm: { fn: "millimeters", factor: 1 },
  millimeter: { fn: "millimeters", factor: 1 },
  millimeters: { fn: "millimeters", factor: 1 },
  ft: { fn: "feet", factor: 1 },
  foot: { fn: "feet", factor: 1 },
  feet: { fn: "feet", factor: 1 },
  in: { fn: "inches", factor: 1 },
  inch: { fn: "inches", factor: 1 },
  inches: { fn: "inches", factor: 1 },
  mi: { fn: "miles", factor: 1 },
  mile: { fn: "miles", factor: 1 },
  miles: { fn: "miles", factor: 1 },
  // Mass
  kg: { fn: "kilograms", factor: 1 },
  kilogram: { fn: "kilograms", factor: 1 },
  kilograms: { fn: "kilograms", factor: 1 },
  g: { fn: "grams", factor: 1 },
  gram: { fn: "grams", factor: 1 },
  grams: { fn: "grams", factor: 1 },
  mg: { fn: "milligrams", factor: 1 },
  milligram: { fn: "milligrams", factor: 1 },
  milligrams: { fn: "milligrams", factor: 1 },
  lb: { fn: "pounds", factor: 1 },
  lbs: { fn: "pounds", factor: 1 },
  pound: { fn: "pounds", factor: 1 },
  pounds: { fn: "pounds", factor: 1 },
  // Time
  s: { fn: "seconds", factor: 1 },
  sec: { fn: "seconds", factor: 1 },
  second: { fn: "seconds", factor: 1 },
  seconds: { fn: "seconds", factor: 1 },
  min: { fn: "minutes", factor: 1 },
  minute: { fn: "minutes", factor: 1 },
  minutes: { fn: "minutes", factor: 1 },
  h: { fn: "hours", factor: 1 },
  hr: { fn: "hours", factor: 1 },
  hour: { fn: "hours", factor: 1 },
  hours: { fn: "hours", factor: 1 },
  d: { fn: "days", factor: 1 },
  day: { fn: "days", factor: 1 },
  days: { fn: "days", factor: 1 },
  ms: { fn: "milliseconds", factor: 1 },
  millisecond: { fn: "milliseconds", factor: 1 },
  milliseconds: { fn: "milliseconds", factor: 1 },
  // Velocity
  "m/s": { fn: "metersPerSecond", factor: 1 },
  "km/h": { fn: "kilometersPerHour", factor: 1 },
  kph: { fn: "kilometersPerHour", factor: 1 },
  mph: { fn: "milesPerHour", factor: 1 },
  // Acceleration
  "m/s\xB2": { fn: "metersPerSecondSquared", factor: 1 },
  "m/s^2": { fn: "metersPerSecondSquared", factor: 1 },
  // Force
  N: { fn: "newtons", factor: 1 },
  newton: { fn: "newtons", factor: 1 },
  newtons: { fn: "newtons", factor: 1 },
  // Energy
  J: { fn: "joules", factor: 1 },
  joule: { fn: "joules", factor: 1 },
  joules: { fn: "joules", factor: 1 },
  kJ: { fn: "kilojoules", factor: 1 },
  kilojoule: { fn: "kilojoules", factor: 1 },
  kilojoules: { fn: "kilojoules", factor: 1 },
  cal: { fn: "calories", factor: 1 },
  calorie: { fn: "calories", factor: 1 },
  calories: { fn: "calories", factor: 1 },
  kcal: { fn: "kilocalories", factor: 1 },
  kilocalorie: { fn: "kilocalories", factor: 1 },
  kilocalories: { fn: "kilocalories", factor: 1 },
  // Power
  W: { fn: "watts", factor: 1 },
  watt: { fn: "watts", factor: 1 },
  watts: { fn: "watts", factor: 1 },
  kW: { fn: "kilowatts", factor: 1 },
  kilowatt: { fn: "kilowatts", factor: 1 },
  kilowatts: { fn: "kilowatts", factor: 1 },
  // Temperature
  K: { fn: "kelvin", factor: 1 },
  kelvin: { fn: "kelvin", factor: 1 },
  "\xB0C": { fn: "celsius", factor: 1 },
  C: { fn: "celsius", factor: 1 },
  celsius: { fn: "celsius", factor: 1 },
  // Pressure
  Pa: { fn: "pascals", factor: 1 },
  pascal: { fn: "pascals", factor: 1 },
  pascals: { fn: "pascals", factor: 1 },
  kPa: { fn: "kilopascals", factor: 1 },
  kilopascal: { fn: "kilopascals", factor: 1 },
  kilopascals: { fn: "kilopascals", factor: 1 },
  atm: { fn: "atmospheres", factor: 1 },
  atmosphere: { fn: "atmospheres", factor: 1 },
  atmospheres: { fn: "atmospheres", factor: 1 }
};
function parseUnitLiteral(text) {
  const trimmed = text.trim();
  const match = trimmed.match(/^(-?\d+(?:\.\d+)?(?:e[+-]?\d+)?)\s*(.+)?$/i);
  if (!match) {
    return null;
  }
  const value = parseFloat(match[1]);
  const unit = match[2]?.trim() || "";
  return { value, unit };
}
var unitsMacro = defineExpressionMacro({
  name: "units",
  description: "Parse unit literals at compile time",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length === 1 && ts.isTemplateLiteral(args[0])) {
      const template = args[0];
      if (ts.isNoSubstitutionTemplateLiteral(template)) {
        return parseAndCreateUnit(ctx, template.text, callExpr);
      }
      ctx.reportError(
        callExpr,
        "units template literals with substitutions are not yet supported"
      );
      return callExpr;
    }
    if (args.length === 1 && ts.isStringLiteral(args[0])) {
      return parseAndCreateUnit(ctx, args[0].text, callExpr);
    }
    if (args.length === 2) {
      const valueArg = args[0];
      const unitArg = args[1];
      if (ts.isStringLiteral(unitArg)) {
        const unitText = unitArg.text.trim();
        const unitInfo = UNIT_MAP[unitText];
        if (!unitInfo) {
          ctx.reportError(callExpr, `Unknown unit: ${unitText}`);
          return callExpr;
        }
        if (ts.isNumericLiteral(valueArg)) {
          const value = parseFloat(valueArg.text) * unitInfo.factor;
          return factory.createCallExpression(
            factory.createIdentifier(unitInfo.fn),
            void 0,
            [factory.createNumericLiteral(value)]
          );
        }
        return factory.createCallExpression(
          factory.createIdentifier(unitInfo.fn),
          void 0,
          [valueArg]
        );
      }
    }
    ctx.reportError(
      callExpr,
      "Invalid units() call - expected a string literal or tagged template"
    );
    return callExpr;
  }
});
function parseAndCreateUnit(ctx, text, errorNode) {
  const factory = ctx.factory;
  const parsed = parseUnitLiteral(text);
  if (!parsed) {
    ctx.reportError(errorNode, `Invalid unit literal: ${text}`);
    return errorNode;
  }
  const { value, unit } = parsed;
  if (!unit) {
    return factory.createNumericLiteral(value);
  }
  const unitInfo = UNIT_MAP[unit];
  if (!unitInfo) {
    ctx.reportError(errorNode, `Unknown unit: ${unit}`);
    return errorNode;
  }
  const finalValue = value * unitInfo.factor;
  return factory.createCallExpression(
    factory.createIdentifier(unitInfo.fn),
    void 0,
    [factory.createNumericLiteral(finalValue)]
  );
}
function register() {
  globalRegistry.register(unitsMacro);
}
register();

// src/index.ts
var UNIT_CONSTRUCTORS = {
  m: meters,
  meter: meters,
  meters,
  km: kilometers,
  kilometer: kilometers,
  kilometers,
  cm: centimeters,
  centimeter: centimeters,
  centimeters,
  mm: millimeters,
  millimeter: millimeters,
  millimeters,
  ft: feet,
  foot: feet,
  feet,
  in: inches,
  inch: inches,
  inches,
  mi: miles,
  mile: miles,
  miles,
  kg: kilograms,
  kilogram: kilograms,
  kilograms,
  g: grams,
  gram: grams,
  grams,
  mg: milligrams,
  milligram: milligrams,
  milligrams,
  lb: pounds,
  lbs: pounds,
  pound: pounds,
  pounds,
  s: seconds,
  sec: seconds,
  second: seconds,
  seconds,
  min: minutes,
  minute: minutes,
  minutes,
  h: hours,
  hr: hours,
  hour: hours,
  hours,
  d: days,
  day: days,
  days,
  ms: milliseconds,
  millisecond: milliseconds,
  milliseconds,
  "m/s": metersPerSecond,
  "km/h": kilometersPerHour,
  kph: kilometersPerHour,
  mph: milesPerHour,
  "m/s\xB2": metersPerSecondSquared,
  "m/s^2": metersPerSecondSquared,
  N: newtons,
  newton: newtons,
  newtons,
  J: joules,
  joule: joules,
  joules,
  kJ: kilojoules,
  kilojoule: kilojoules,
  kilojoules,
  cal: calories,
  calorie: calories,
  calories,
  kcal: kilocalories,
  kilocalorie: kilocalories,
  kilocalories,
  W: watts,
  watt: watts,
  watts,
  kW: kilowatts,
  kilowatt: kilowatts,
  kilowatts,
  K: kelvin,
  kelvin,
  "\xB0C": celsius,
  C: celsius,
  celsius,
  Pa: pascals,
  pascal: pascals,
  pascals,
  kPa: kilopascals,
  kilopascal: kilopascals,
  kilopascals,
  atm: atmospheres,
  atmosphere: atmospheres,
  atmospheres
};
function units(strings) {
  const text = strings[0].trim();
  const match = text.match(/^(-?\d+(?:\.\d+)?(?:e[+-]?\d+)?)\s*(.+)?$/i);
  if (!match) {
    throw new Error(`Invalid unit literal: ${text}`);
  }
  const value = parseFloat(match[1]);
  const unitStr = match[2]?.trim() || "";
  if (!unitStr) {
    return new Unit(value);
  }
  const constructor = UNIT_CONSTRUCTORS[unitStr];
  if (!constructor) {
    throw new Error(`Unknown unit: ${unitStr}`);
  }
  return constructor(value);
}
export {
  Unit,
  assertSameDimensions,
  atmospheres,
  calories,
  celsius,
  centimeters,
  days,
  feet,
  grams,
  hours,
  inches,
  joules,
  kelvin,
  kilocalories,
  kilograms,
  kilojoules,
  kilometers,
  kilometersPerHour,
  kilopascals,
  kilowatts,
  meters,
  metersPerSecond,
  metersPerSecondSquared,
  miles,
  milesPerHour,
  milligrams,
  millimeters,
  milliseconds,
  minutes,
  newtons,
  pascals,
  pounds,
  register,
  seconds,
  units,
  unitsMacro,
  watts
};
//# sourceMappingURL=index.js.map