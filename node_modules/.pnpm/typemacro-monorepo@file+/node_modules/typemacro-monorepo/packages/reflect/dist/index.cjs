"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  fieldNamesMacro: () => fieldNamesMacro,
  reflectAttribute: () => reflectAttribute,
  register: () => register,
  typeInfoMacro: () => typeInfoMacro,
  validatorMacro: () => validatorMacro
});
module.exports = __toCommonJS(index_exports);
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var reflectAttribute = (0, import_core.defineAttributeMacro)({
  name: "reflect",
  module: "@typemacro/reflect",
  description: "Enable compile-time reflection for a type",
  validTargets: ["interface", "class", "type"],
  expand(ctx, decorator, target, _args) {
    const typeInfo = extractTypeInfo(ctx, target);
    if (typeInfo) {
      const metaName = `__${typeInfo.name}_meta__`;
      const metaDecl = generateTypeInfoDeclaration(ctx, metaName, typeInfo);
      return [target, metaDecl];
    }
    return target;
  }
});
function extractTypeInfo(ctx, node) {
  if (ts.isInterfaceDeclaration(node)) {
    return extractInterfaceInfo(ctx, node);
  }
  if (ts.isClassDeclaration(node)) {
    return extractClassInfo(ctx, node);
  }
  if (ts.isTypeAliasDeclaration(node)) {
    return extractTypeAliasInfo(ctx, node);
  }
  return null;
}
function extractInterfaceInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const properties = ctx.typeChecker.getPropertiesOfType(type);
  const fields = properties.map((prop) => {
    const decls = prop.getDeclarations();
    const decl = decls?.[0];
    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
      prop,
      decl || node
    );
    return {
      name: prop.name,
      type: ctx.typeChecker.typeToString(propType),
      optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,
      readonly: decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl)) ? decl.modifiers?.some(
        (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword
      ) ?? false : false
    };
  });
  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];
  const extendsTypes = node.heritageClauses?.filter((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword).flatMap((hc) => hc.types.map((t) => t.expression.getText())) ?? [];
  return {
    name: node.name.text,
    kind: "interface",
    fields,
    typeParameters,
    extends: extendsTypes
  };
}
function extractClassInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const properties = ctx.typeChecker.getPropertiesOfType(type);
  const fields = [];
  const methods = [];
  for (const prop of properties) {
    const decls = prop.getDeclarations();
    const decl = decls?.[0];
    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
      prop,
      decl || node
    );
    const typeStr = ctx.typeChecker.typeToString(propType);
    if (decl && ts.isMethodDeclaration(decl)) {
      const params = decl.parameters.map((p) => ({
        name: ts.isIdentifier(p.name) ? p.name.text : "param",
        type: p.type ? p.type.getText() : "unknown",
        optional: !!p.questionToken,
        defaultValue: p.initializer?.getText()
      }));
      methods.push({
        name: prop.name,
        parameters: params,
        returnType: decl.type?.getText() ?? "void",
        isAsync: !!decl.modifiers?.some(
          (m) => m.kind === ts.SyntaxKind.AsyncKeyword
        ),
        isStatic: !!decl.modifiers?.some(
          (m) => m.kind === ts.SyntaxKind.StaticKeyword
        )
      });
    } else {
      fields.push({
        name: prop.name,
        type: typeStr,
        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,
        readonly: decl && ts.isPropertyDeclaration(decl) ? decl.modifiers?.some(
          (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword
        ) ?? false : false
      });
    }
  }
  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];
  return {
    name: node.name?.text ?? "Anonymous",
    kind: "class",
    fields,
    methods,
    typeParameters
  };
}
function extractTypeAliasInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const typeString = ctx.typeChecker.typeToString(type);
  if (type.isClassOrInterface() || type.flags & ts.TypeFlags.Object) {
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    const fields = properties.map((prop) => {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, node);
      return {
        name: prop.name,
        type: ctx.typeChecker.typeToString(propType),
        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,
        readonly: false
      };
    });
    return {
      name: node.name.text,
      kind: "type",
      fields,
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  if (type.isUnion()) {
    return {
      name: node.name.text,
      kind: "union",
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  if (type.isIntersection()) {
    return {
      name: node.name.text,
      kind: "intersection",
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  return {
    name: node.name.text,
    kind: "type"
  };
}
function generateTypeInfoDeclaration(ctx, name, info) {
  const factory = ctx.factory;
  const fieldsArray = info.fields?.map(
    (f) => factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(f.name)
        ),
        factory.createPropertyAssignment(
          "type",
          factory.createStringLiteral(f.type)
        ),
        factory.createPropertyAssignment(
          "optional",
          f.optional ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "readonly",
          f.readonly ? factory.createTrue() : factory.createFalse()
        )
      ],
      true
    )
  ) ?? [];
  const methodsArray = info.methods?.map(
    (m) => factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(m.name)
        ),
        factory.createPropertyAssignment(
          "returnType",
          factory.createStringLiteral(m.returnType)
        ),
        factory.createPropertyAssignment(
          "isAsync",
          m.isAsync ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "isStatic",
          m.isStatic ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "parameters",
          factory.createArrayLiteralExpression(
            m.parameters.map(
              (p) => factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "name",
                    factory.createStringLiteral(p.name)
                  ),
                  factory.createPropertyAssignment(
                    "type",
                    factory.createStringLiteral(p.type)
                  ),
                  factory.createPropertyAssignment(
                    "optional",
                    p.optional ? factory.createTrue() : factory.createFalse()
                  )
                ],
                true
              )
            )
          )
        )
      ],
      true
    )
  ) ?? [];
  const infoObj = factory.createObjectLiteralExpression(
    [
      factory.createPropertyAssignment(
        "name",
        factory.createStringLiteral(info.name)
      ),
      factory.createPropertyAssignment(
        "kind",
        factory.createStringLiteral(info.kind)
      ),
      factory.createPropertyAssignment(
        "fields",
        factory.createArrayLiteralExpression(fieldsArray, true)
      ),
      factory.createPropertyAssignment(
        "methods",
        factory.createArrayLiteralExpression(methodsArray, true)
      ),
      factory.createPropertyAssignment(
        "typeParameters",
        factory.createArrayLiteralExpression(
          (info.typeParameters ?? []).map(
            (tp) => factory.createStringLiteral(tp)
          )
        )
      )
    ],
    true
  );
  return factory.createVariableStatement(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createVariableDeclarationList(
      [factory.createVariableDeclaration(name, void 0, void 0, infoObj)],
      ts.NodeFlags.Const
    )
  );
}
var typeInfoMacro = (0, import_core.defineExpressionMacro)({
  name: "typeInfo",
  module: "@typemacro/reflect",
  description: "Get compile-time type information",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(callExpr, "typeInfo requires exactly one type argument");
      return callExpr;
    }
    const typeArg = typeArgs[0];
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArg);
    const typeName = ctx.typeChecker.typeToString(type);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    let kind = "type";
    const symbol = type.getSymbol();
    if (symbol) {
      const decls = symbol.getDeclarations();
      if (decls && decls.length > 0) {
        const decl = decls[0];
        if (ts.isInterfaceDeclaration(decl)) kind = "interface";
        else if (ts.isClassDeclaration(decl)) kind = "class";
        else if (ts.isEnumDeclaration(decl)) kind = "enum";
      }
    }
    const fieldsArray = properties.map((prop) => {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
        prop,
        callExpr
      );
      const decls = prop.getDeclarations();
      const decl = decls?.[0];
      const isReadonly = decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl)) ? decl.modifiers?.some(
        (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword
      ) ?? false : false;
      return factory.createObjectLiteralExpression(
        [
          factory.createPropertyAssignment(
            "name",
            factory.createStringLiteral(prop.name)
          ),
          factory.createPropertyAssignment(
            "type",
            factory.createStringLiteral(ctx.typeChecker.typeToString(propType))
          ),
          factory.createPropertyAssignment(
            "optional",
            (prop.flags & ts.SymbolFlags.Optional) !== 0 ? factory.createTrue() : factory.createFalse()
          ),
          factory.createPropertyAssignment(
            "readonly",
            isReadonly ? factory.createTrue() : factory.createFalse()
          )
        ],
        true
      );
    });
    return factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(typeName)
        ),
        factory.createPropertyAssignment(
          "kind",
          factory.createStringLiteral(kind)
        ),
        factory.createPropertyAssignment(
          "fields",
          factory.createArrayLiteralExpression(fieldsArray, true)
        )
      ],
      true
    );
  }
});
var fieldNamesMacro = (0, import_core.defineExpressionMacro)({
  name: "fieldNames",
  module: "@typemacro/reflect",
  description: "Get field names of a type as an array",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "fieldNames requires exactly one type argument"
      );
      return callExpr;
    }
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    return factory.createArrayLiteralExpression(
      properties.map((prop) => factory.createStringLiteral(prop.name))
    );
  }
});
var validatorMacro = (0, import_core.defineExpressionMacro)({
  name: "validator",
  module: "@typemacro/reflect",
  description: "Generate a runtime validator for a type",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(callExpr, "validator requires exactly one type argument");
      return callExpr;
    }
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    const typeName = ctx.typeChecker.typeToString(type);
    const checks = [];
    for (const prop of properties) {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
        prop,
        callExpr
      );
      const propTypeStr = ctx.typeChecker.typeToString(propType);
      const isOptional = (prop.flags & ts.SymbolFlags.Optional) !== 0;
      let checkExpr;
      if (propTypeStr === "string") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("string")
        );
      } else if (propTypeStr === "number") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("number")
        );
      } else if (propTypeStr === "boolean") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("boolean")
        );
      } else {
        continue;
      }
      if (isOptional) {
        checkExpr = factory.createBinaryExpression(
          factory.createBinaryExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            ),
            factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),
            factory.createIdentifier("undefined")
          ),
          factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),
          checkExpr
        );
      }
      checks.push(
        factory.createIfStatement(
          checkExpr,
          factory.createBlock([
            factory.createExpressionStatement(
              factory.createCallExpression(
                factory.createPropertyAccessExpression(
                  factory.createIdentifier("errors"),
                  "push"
                ),
                void 0,
                [
                  factory.createStringLiteral(
                    `Invalid type for field '${prop.name}': expected ${propTypeStr}`
                  )
                ]
              )
            )
          ])
        )
      );
    }
    return factory.createArrowFunction(
      void 0,
      void 0,
      [
        factory.createParameterDeclaration(
          void 0,
          void 0,
          factory.createIdentifier("value"),
          void 0,
          factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
        )
      ],
      factory.createTypeReferenceNode("ValidationResult", [typeArgs[0]]),
      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
      factory.createBlock(
        [
          // const errors: string[] = [];
          factory.createVariableStatement(
            void 0,
            factory.createVariableDeclarationList(
              [
                factory.createVariableDeclaration(
                  "errors",
                  void 0,
                  factory.createArrayTypeNode(
                    factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)
                  ),
                  factory.createArrayLiteralExpression([])
                )
              ],
              ts.NodeFlags.Const
            )
          ),
          // Type check: if (typeof value !== "object" || value === null)
          factory.createIfStatement(
            factory.createBinaryExpression(
              factory.createBinaryExpression(
                factory.createTypeOfExpression(
                  factory.createIdentifier("value")
                ),
                factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),
                factory.createStringLiteral("object")
              ),
              factory.createToken(ts.SyntaxKind.BarBarToken),
              factory.createBinaryExpression(
                factory.createIdentifier("value"),
                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),
                factory.createNull()
              )
            ),
            factory.createBlock([
              factory.createReturnStatement(
                factory.createObjectLiteralExpression(
                  [
                    factory.createPropertyAssignment(
                      "success",
                      factory.createFalse()
                    ),
                    factory.createPropertyAssignment(
                      "errors",
                      factory.createArrayLiteralExpression([
                        factory.createStringLiteral(
                          `Expected object, got ${"object"}`
                        )
                      ])
                    )
                  ],
                  true
                )
              )
            ])
          ),
          ...checks,
          // Return result
          factory.createReturnStatement(
            factory.createConditionalExpression(
              factory.createBinaryExpression(
                factory.createPropertyAccessExpression(
                  factory.createIdentifier("errors"),
                  "length"
                ),
                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),
                factory.createNumericLiteral(0)
              ),
              factory.createToken(ts.SyntaxKind.QuestionToken),
              factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "success",
                    factory.createTrue()
                  ),
                  factory.createPropertyAssignment(
                    "value",
                    factory.createAsExpression(
                      factory.createIdentifier("value"),
                      typeArgs[0]
                    )
                  )
                ],
                true
              ),
              factory.createToken(ts.SyntaxKind.ColonToken),
              factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "success",
                    factory.createFalse()
                  ),
                  factory.createPropertyAssignment(
                    "errors",
                    factory.createIdentifier("errors")
                  )
                ],
                true
              )
            )
          )
        ],
        true
      )
    );
  }
});
function register() {
  import_core.globalRegistry.register(reflectAttribute);
  import_core.globalRegistry.register(typeInfoMacro);
  import_core.globalRegistry.register(fieldNamesMacro);
  import_core.globalRegistry.register(validatorMacro);
}
register();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  fieldNamesMacro,
  reflectAttribute,
  register,
  typeInfoMacro,
  validatorMacro
});
//# sourceMappingURL=index.cjs.map