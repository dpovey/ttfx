{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Compile-Time Reflection Macros\n *\n * Provides compile-time type introspection capabilities, allowing you to\n * examine types, generate code based on type information, and more.\n *\n * Inspired by:\n * - Rust's proc_macro with derive\n * - Java/C# reflection but at compile time\n * - Zig's @typeInfo\n *\n * @example\n * ```typescript\n * @reflect\n * interface User {\n *   id: number;\n *   name: string;\n *   email: string;\n * }\n *\n * // Get metadata at compile time\n * const userMeta = typeInfo<User>();\n * // { name: \"User\", fields: [{ name: \"id\", type: \"number\" }, ...] }\n *\n * // Generate a validator\n * const validateUser = validator<User>();\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  defineAttributeMacro,\n  globalRegistry,\n  MacroContext,\n  AttributeTarget,\n} from \"@typemacro/core\";\n\n// ============================================================================\n// Type Information Structures\n// ============================================================================\n\nexport interface TypeInfo {\n  name: string;\n  kind:\n    | \"interface\"\n    | \"class\"\n    | \"type\"\n    | \"enum\"\n    | \"primitive\"\n    | \"union\"\n    | \"intersection\"\n    | \"array\"\n    | \"tuple\"\n    | \"function\";\n  fields?: FieldInfo[];\n  methods?: MethodInfo[];\n  typeParameters?: string[];\n  extends?: string[];\n  modifiers?: string[];\n}\n\nexport interface FieldInfo {\n  name: string;\n  type: string;\n  optional: boolean;\n  readonly: boolean;\n  defaultValue?: string;\n}\n\nexport interface MethodInfo {\n  name: string;\n  parameters: ParameterInfo[];\n  returnType: string;\n  isAsync: boolean;\n  isStatic: boolean;\n}\n\nexport interface ParameterInfo {\n  name: string;\n  type: string;\n  optional: boolean;\n  defaultValue?: string;\n}\n\n// ============================================================================\n// @reflect Attribute Macro\n// ============================================================================\n\nexport const reflectAttribute = defineAttributeMacro({\n  name: \"reflect\",\n  module: \"@typemacro/reflect\",\n  description: \"Enable compile-time reflection for a type\",\n  validTargets: [\"interface\", \"class\", \"type\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    _args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    // Extract type information directly from the type checker\n    const typeInfo = extractTypeInfo(ctx, target);\n\n    if (typeInfo) {\n      // Generate metadata as an exported const alongside the original declaration\n      const metaName = `__${typeInfo.name}_meta__`;\n      const metaDecl = generateTypeInfoDeclaration(ctx, metaName, typeInfo);\n\n      return [target, metaDecl];\n    }\n\n    return target;\n  },\n});\n\n/**\n * Extract type information from a declaration\n */\nfunction extractTypeInfo(\n  ctx: MacroContext,\n  node: ts.Declaration,\n): TypeInfo | null {\n  if (ts.isInterfaceDeclaration(node)) {\n    return extractInterfaceInfo(ctx, node);\n  }\n\n  if (ts.isClassDeclaration(node)) {\n    return extractClassInfo(ctx, node);\n  }\n\n  if (ts.isTypeAliasDeclaration(node)) {\n    return extractTypeAliasInfo(ctx, node);\n  }\n\n  return null;\n}\n\nfunction extractInterfaceInfo(\n  ctx: MacroContext,\n  node: ts.InterfaceDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n  const fields: FieldInfo[] = properties.map((prop) => {\n    const decls = prop.getDeclarations();\n    const decl = decls?.[0];\n    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n      prop,\n      decl || node,\n    );\n\n    return {\n      name: prop.name,\n      type: ctx.typeChecker.typeToString(propType),\n      optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n      readonly:\n        decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl))\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false,\n    };\n  });\n\n  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];\n  const extendsTypes =\n    node.heritageClauses\n      ?.filter((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword)\n      .flatMap((hc) => hc.types.map((t) => t.expression.getText())) ?? [];\n\n  return {\n    name: node.name.text,\n    kind: \"interface\",\n    fields,\n    typeParameters,\n    extends: extendsTypes,\n  };\n}\n\nfunction extractClassInfo(\n  ctx: MacroContext,\n  node: ts.ClassDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n  const fields: FieldInfo[] = [];\n  const methods: MethodInfo[] = [];\n\n  for (const prop of properties) {\n    const decls = prop.getDeclarations();\n    const decl = decls?.[0];\n    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n      prop,\n      decl || node,\n    );\n    const typeStr = ctx.typeChecker.typeToString(propType);\n\n    // Check if it's a method\n    if (decl && ts.isMethodDeclaration(decl)) {\n      const params: ParameterInfo[] = decl.parameters.map((p) => ({\n        name: ts.isIdentifier(p.name) ? p.name.text : \"param\",\n        type: p.type ? p.type.getText() : \"unknown\",\n        optional: !!p.questionToken,\n        defaultValue: p.initializer?.getText(),\n      }));\n\n      methods.push({\n        name: prop.name,\n        parameters: params,\n        returnType: decl.type?.getText() ?? \"void\",\n        isAsync: !!decl.modifiers?.some(\n          (m) => m.kind === ts.SyntaxKind.AsyncKeyword,\n        ),\n        isStatic: !!decl.modifiers?.some(\n          (m) => m.kind === ts.SyntaxKind.StaticKeyword,\n        ),\n      });\n    } else {\n      fields.push({\n        name: prop.name,\n        type: typeStr,\n        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n        readonly:\n          decl && ts.isPropertyDeclaration(decl)\n            ? (decl.modifiers?.some(\n                (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n              ) ?? false)\n            : false,\n      });\n    }\n  }\n\n  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];\n\n  return {\n    name: node.name?.text ?? \"Anonymous\",\n    kind: \"class\",\n    fields,\n    methods,\n    typeParameters,\n  };\n}\n\nfunction extractTypeAliasInfo(\n  ctx: MacroContext,\n  node: ts.TypeAliasDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const typeString = ctx.typeChecker.typeToString(type);\n\n  // For object types, extract fields\n  if (type.isClassOrInterface() || type.flags & ts.TypeFlags.Object) {\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n    const fields: FieldInfo[] = properties.map((prop) => {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, node);\n      return {\n        name: prop.name,\n        type: ctx.typeChecker.typeToString(propType),\n        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n        readonly: false,\n      };\n    });\n\n    return {\n      name: node.name.text,\n      kind: \"type\",\n      fields,\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  // Union type\n  if (type.isUnion()) {\n    return {\n      name: node.name.text,\n      kind: \"union\",\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  // Intersection type\n  if (type.isIntersection()) {\n    return {\n      name: node.name.text,\n      kind: \"intersection\",\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  return {\n    name: node.name.text,\n    kind: \"type\",\n  };\n}\n\n/**\n * Generate a TypeInfo declaration\n */\nfunction generateTypeInfoDeclaration(\n  ctx: MacroContext,\n  name: string,\n  info: TypeInfo,\n): ts.Statement {\n  const factory = ctx.factory;\n\n  const fieldsArray =\n    info.fields?.map((f) =>\n      factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(f.name),\n          ),\n          factory.createPropertyAssignment(\n            \"type\",\n            factory.createStringLiteral(f.type),\n          ),\n          factory.createPropertyAssignment(\n            \"optional\",\n            f.optional ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"readonly\",\n            f.readonly ? factory.createTrue() : factory.createFalse(),\n          ),\n        ],\n        true,\n      ),\n    ) ?? [];\n\n  const methodsArray =\n    info.methods?.map((m) =>\n      factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(m.name),\n          ),\n          factory.createPropertyAssignment(\n            \"returnType\",\n            factory.createStringLiteral(m.returnType),\n          ),\n          factory.createPropertyAssignment(\n            \"isAsync\",\n            m.isAsync ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"isStatic\",\n            m.isStatic ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"parameters\",\n            factory.createArrayLiteralExpression(\n              m.parameters.map((p) =>\n                factory.createObjectLiteralExpression(\n                  [\n                    factory.createPropertyAssignment(\n                      \"name\",\n                      factory.createStringLiteral(p.name),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"type\",\n                      factory.createStringLiteral(p.type),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"optional\",\n                      p.optional ? factory.createTrue() : factory.createFalse(),\n                    ),\n                  ],\n                  true,\n                ),\n              ),\n            ),\n          ),\n        ],\n        true,\n      ),\n    ) ?? [];\n\n  const infoObj = factory.createObjectLiteralExpression(\n    [\n      factory.createPropertyAssignment(\n        \"name\",\n        factory.createStringLiteral(info.name),\n      ),\n      factory.createPropertyAssignment(\n        \"kind\",\n        factory.createStringLiteral(info.kind),\n      ),\n      factory.createPropertyAssignment(\n        \"fields\",\n        factory.createArrayLiteralExpression(fieldsArray, true),\n      ),\n      factory.createPropertyAssignment(\n        \"methods\",\n        factory.createArrayLiteralExpression(methodsArray, true),\n      ),\n      factory.createPropertyAssignment(\n        \"typeParameters\",\n        factory.createArrayLiteralExpression(\n          (info.typeParameters ?? []).map((tp) =>\n            factory.createStringLiteral(tp),\n          ),\n        ),\n      ),\n    ],\n    true,\n  );\n\n  return factory.createVariableStatement(\n    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n    factory.createVariableDeclarationList(\n      [factory.createVariableDeclaration(name, undefined, undefined, infoObj)],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\n// ============================================================================\n// typeInfo<T>() Expression Macro\n// ============================================================================\n\nexport const typeInfoMacro = defineExpressionMacro({\n  name: \"typeInfo\",\n  module: \"@typemacro/reflect\",\n  description: \"Get compile-time type information\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    // Get the type argument\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(callExpr, \"typeInfo requires exactly one type argument\");\n      return callExpr;\n    }\n\n    const typeArg = typeArgs[0];\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArg);\n    const typeName = ctx.typeChecker.typeToString(type);\n\n    // Always extract type info directly from the type checker.\n    // This avoids cross-file mutable state and works reliably\n    // regardless of file processing order or incremental builds.\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n    // Determine the kind\n    let kind = \"type\";\n    const symbol = type.getSymbol();\n    if (symbol) {\n      const decls = symbol.getDeclarations();\n      if (decls && decls.length > 0) {\n        const decl = decls[0];\n        if (ts.isInterfaceDeclaration(decl)) kind = \"interface\";\n        else if (ts.isClassDeclaration(decl)) kind = \"class\";\n        else if (ts.isEnumDeclaration(decl)) kind = \"enum\";\n      }\n    }\n\n    const fieldsArray = properties.map((prop) => {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        callExpr,\n      );\n      const decls = prop.getDeclarations();\n      const decl = decls?.[0];\n      const isReadonly =\n        decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl))\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false;\n\n      return factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(prop.name),\n          ),\n          factory.createPropertyAssignment(\n            \"type\",\n            factory.createStringLiteral(ctx.typeChecker.typeToString(propType)),\n          ),\n          factory.createPropertyAssignment(\n            \"optional\",\n            (prop.flags & ts.SymbolFlags.Optional) !== 0\n              ? factory.createTrue()\n              : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"readonly\",\n            isReadonly ? factory.createTrue() : factory.createFalse(),\n          ),\n        ],\n        true,\n      );\n    });\n\n    return factory.createObjectLiteralExpression(\n      [\n        factory.createPropertyAssignment(\n          \"name\",\n          factory.createStringLiteral(typeName),\n        ),\n        factory.createPropertyAssignment(\n          \"kind\",\n          factory.createStringLiteral(kind),\n        ),\n        factory.createPropertyAssignment(\n          \"fields\",\n          factory.createArrayLiteralExpression(fieldsArray, true),\n        ),\n      ],\n      true,\n    );\n  },\n});\n\n// ============================================================================\n// fieldNames<T>() - Get field names as a tuple type\n// ============================================================================\n\nexport const fieldNamesMacro = defineExpressionMacro({\n  name: \"fieldNames\",\n  module: \"@typemacro/reflect\",\n  description: \"Get field names of a type as an array\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n    const typeArgs = callExpr.typeArguments;\n\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"fieldNames requires exactly one type argument\",\n      );\n      return callExpr;\n    }\n\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n    return factory.createArrayLiteralExpression(\n      properties.map((prop) => factory.createStringLiteral(prop.name)),\n    );\n  },\n});\n\n// ============================================================================\n// validator<T>() - Generate a runtime validator\n// ============================================================================\n\nexport const validatorMacro = defineExpressionMacro({\n  name: \"validator\",\n  module: \"@typemacro/reflect\",\n  description: \"Generate a runtime validator for a type\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n    const typeArgs = callExpr.typeArguments;\n\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(callExpr, \"validator requires exactly one type argument\");\n      return callExpr;\n    }\n\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n    const typeName = ctx.typeChecker.typeToString(type);\n\n    // Generate validation checks for each property\n    const checks: ts.Statement[] = [];\n\n    for (const prop of properties) {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        callExpr,\n      );\n      const propTypeStr = ctx.typeChecker.typeToString(propType);\n      const isOptional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n\n      // Generate type check\n      let checkExpr: ts.Expression;\n\n      if (propTypeStr === \"string\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"string\"),\n        );\n      } else if (propTypeStr === \"number\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"number\"),\n        );\n      } else if (propTypeStr === \"boolean\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"boolean\"),\n        );\n      } else {\n        // Skip complex types for now\n        continue;\n      }\n\n      // Add optional check\n      if (isOptional) {\n        checkExpr = factory.createBinaryExpression(\n          factory.createBinaryExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n            factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n            factory.createIdentifier(\"undefined\"),\n          ),\n          factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),\n          checkExpr,\n        );\n      }\n\n      checks.push(\n        factory.createIfStatement(\n          checkExpr,\n          factory.createBlock([\n            factory.createExpressionStatement(\n              factory.createCallExpression(\n                factory.createPropertyAccessExpression(\n                  factory.createIdentifier(\"errors\"),\n                  \"push\",\n                ),\n                undefined,\n                [\n                  factory.createStringLiteral(\n                    `Invalid type for field '${prop.name}': expected ${propTypeStr}`,\n                  ),\n                ],\n              ),\n            ),\n          ]),\n        ),\n      );\n    }\n\n    // Build the validator function\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [\n        factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          factory.createIdentifier(\"value\"),\n          undefined,\n          factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n        ),\n      ],\n      factory.createTypeReferenceNode(\"ValidationResult\", [typeArgs[0]]),\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      factory.createBlock(\n        [\n          // const errors: string[] = [];\n          factory.createVariableStatement(\n            undefined,\n            factory.createVariableDeclarationList(\n              [\n                factory.createVariableDeclaration(\n                  \"errors\",\n                  undefined,\n                  factory.createArrayTypeNode(\n                    factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n                  ),\n                  factory.createArrayLiteralExpression([]),\n                ),\n              ],\n              ts.NodeFlags.Const,\n            ),\n          ),\n          // Type check: if (typeof value !== \"object\" || value === null)\n          factory.createIfStatement(\n            factory.createBinaryExpression(\n              factory.createBinaryExpression(\n                factory.createTypeOfExpression(\n                  factory.createIdentifier(\"value\"),\n                ),\n                factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n                factory.createStringLiteral(\"object\"),\n              ),\n              factory.createToken(ts.SyntaxKind.BarBarToken),\n              factory.createBinaryExpression(\n                factory.createIdentifier(\"value\"),\n                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n                factory.createNull(),\n              ),\n            ),\n            factory.createBlock([\n              factory.createReturnStatement(\n                factory.createObjectLiteralExpression(\n                  [\n                    factory.createPropertyAssignment(\n                      \"success\",\n                      factory.createFalse(),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"errors\",\n                      factory.createArrayLiteralExpression([\n                        factory.createStringLiteral(\n                          `Expected object, got ${typeof null}`,\n                        ),\n                      ]),\n                    ),\n                  ],\n                  true,\n                ),\n              ),\n            ]),\n          ),\n          ...checks,\n          // Return result\n          factory.createReturnStatement(\n            factory.createConditionalExpression(\n              factory.createBinaryExpression(\n                factory.createPropertyAccessExpression(\n                  factory.createIdentifier(\"errors\"),\n                  \"length\",\n                ),\n                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n                factory.createNumericLiteral(0),\n              ),\n              factory.createToken(ts.SyntaxKind.QuestionToken),\n              factory.createObjectLiteralExpression(\n                [\n                  factory.createPropertyAssignment(\n                    \"success\",\n                    factory.createTrue(),\n                  ),\n                  factory.createPropertyAssignment(\n                    \"value\",\n                    factory.createAsExpression(\n                      factory.createIdentifier(\"value\"),\n                      typeArgs[0],\n                    ),\n                  ),\n                ],\n                true,\n              ),\n              factory.createToken(ts.SyntaxKind.ColonToken),\n              factory.createObjectLiteralExpression(\n                [\n                  factory.createPropertyAssignment(\n                    \"success\",\n                    factory.createFalse(),\n                  ),\n                  factory.createPropertyAssignment(\n                    \"errors\",\n                    factory.createIdentifier(\"errors\"),\n                  ),\n                ],\n                true,\n              ),\n            ),\n          ),\n        ],\n        true,\n      ),\n    );\n  },\n});\n\n/**\n * Register macros with the global registry.\n * Call this function to enable reflection macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(reflectAttribute);\n  globalRegistry.register(typeInfoMacro);\n  globalRegistry.register(fieldNamesMacro);\n  globalRegistry.register(validatorMacro);\n}\n\n// Auto-register when this module is imported\nregister();\n\n// ============================================================================\n// Types for Runtime\n// ============================================================================\n\nexport type ValidationResult<T> =\n  | { success: true; value: T }\n  | { success: false; errors: string[] };\n"],"mappings":"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","names":[]}