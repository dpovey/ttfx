{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @typemacro/transformer - Main TypeScript transformer for macro expansion\n *\n * This transformer integrates with ts-patch to process macros during compilation.\n */\n\nimport * as ts from \"typescript\";\nimport {\n  MacroContextImpl,\n  createMacroContext,\n  globalRegistry,\n  globalExtensionRegistry,\n  ExpressionMacro,\n  AttributeMacro,\n  MacroDefinition,\n  DeriveTypeInfo,\n  DeriveFieldInfo,\n  LabeledBlockMacro,\n  TaggedTemplateMacroDef,\n  TypeMacro,\n} from \"@typemacro/core\";\n\n/**\n * Configuration for the transformer\n */\nexport interface MacroTransformerConfig {\n  /** Enable verbose logging */\n  verbose?: boolean;\n\n  /** Custom macro module paths to load */\n  macroModules?: string[];\n}\n\n/**\n * Create the TypeScript transformer factory\n * This is the entry point called by ts-patch\n */\nexport default function macroTransformerFactory(\n  program: ts.Program,\n  config?: MacroTransformerConfig,\n): ts.TransformerFactory<ts.SourceFile> {\n  const verbose = config?.verbose ?? false;\n\n  if (verbose) {\n    console.log(\"[typemacro] Initializing transformer\");\n    console.log(\n      `[typemacro] Registered macros: ${globalRegistry\n        .getAll()\n        .map((m) => m.name)\n        .join(\", \")}`,\n    );\n  }\n\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile) => {\n      if (verbose) {\n        console.log(`[typemacro] Processing: ${sourceFile.fileName}`);\n      }\n\n      const ctx = createMacroContext(program, sourceFile, context);\n      const transformer = new MacroTransformer(ctx, verbose);\n\n      const result = ts.visitNode(\n        sourceFile,\n        transformer.visit.bind(transformer),\n      );\n\n      // Report diagnostics through the TS diagnostic pipeline\n      const macroDiagnostics = ctx.getDiagnostics();\n      for (const diag of macroDiagnostics) {\n        const start = diag.node ? diag.node.getStart(sourceFile) : 0;\n        const length = diag.node ? diag.node.getWidth(sourceFile) : 0;\n\n        const tsDiag: ts.Diagnostic = {\n          file: sourceFile,\n          start,\n          length,\n          messageText: `[typemacro] ${diag.message}`,\n          category:\n            diag.severity === \"error\"\n              ? ts.DiagnosticCategory.Error\n              : ts.DiagnosticCategory.Warning,\n          code: 90000, // Custom diagnostic code range for typemacro\n          source: \"typemacro\",\n        };\n\n        // Use the transformation context's addDiagnostic if available (TS 5.x+)\n        const ctxWithDiag = context as ts.TransformationContext & {\n          addDiagnostic?: (diag: ts.Diagnostic) => void;\n        };\n        if (ctxWithDiag.addDiagnostic) {\n          ctxWithDiag.addDiagnostic(tsDiag);\n        }\n\n        // Also log for build tools that don't surface TS diagnostics\n        if (verbose) {\n          const prefix = diag.severity === \"error\" ? \"ERROR\" : \"WARNING\";\n          const loc = diag.node\n            ? ` at ${sourceFile.fileName}:${sourceFile.getLineAndCharacterOfPosition(start).line + 1}`\n            : \"\";\n          console.log(`[typemacro ${prefix}]${loc} ${diag.message}`);\n        }\n      }\n\n      return result as ts.SourceFile;\n    };\n  };\n}\n\n/**\n * The main transformer class that handles macro expansion\n */\nclass MacroTransformer {\n  private additionalStatements: ts.Statement[] = [];\n\n  /**\n   * Cache of resolved macro symbols for this source file.\n   * Maps a ts.Symbol id to the MacroDefinition it resolves to (or null if not a macro).\n   * Built lazily as identifiers are encountered.\n   */\n  private symbolMacroCache = new Map<number, MacroDefinition | null>();\n\n  constructor(\n    private ctx: MacroContextImpl,\n    private verbose: boolean,\n  ) {}\n\n  // ---------------------------------------------------------------------------\n  // Import-scoped macro resolution\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Resolve an identifier to a macro definition via import tracking.\n   */\n  private resolveMacroFromSymbol(\n    node: ts.Node,\n    macroName: string,\n    kind: MacroDefinition[\"kind\"],\n  ): MacroDefinition | undefined {\n    const symbol = this.ctx.typeChecker.getSymbolAtLocation(node);\n    if (!symbol) {\n      return this.fallbackNameLookup(macroName, kind);\n    }\n\n    const symbolId = (symbol as unknown as { id?: number }).id;\n    if (symbolId !== undefined && this.symbolMacroCache.has(symbolId)) {\n      return this.symbolMacroCache.get(symbolId) ?? undefined;\n    }\n\n    const result = this.resolveSymbolToMacro(symbol, macroName, kind);\n\n    if (symbolId !== undefined) {\n      this.symbolMacroCache.set(symbolId, result ?? null);\n    }\n\n    return result;\n  }\n\n  /**\n   * Core symbol resolution: follow aliases to find the original declaration,\n   * then check if it comes from a known macro module.\n   */\n  private resolveSymbolToMacro(\n    symbol: ts.Symbol,\n    macroName: string,\n    kind: MacroDefinition[\"kind\"],\n  ): MacroDefinition | undefined {\n    let resolved = symbol;\n    if (resolved.flags & ts.SymbolFlags.Alias) {\n      try {\n        resolved = this.ctx.typeChecker.getAliasedSymbol(resolved);\n      } catch {\n        // getAliasedSymbol can throw for unresolvable symbols\n      }\n    }\n\n    const declarations = resolved.getDeclarations();\n    if (!declarations || declarations.length === 0) {\n      return this.fallbackNameLookup(macroName, kind);\n    }\n\n    for (const decl of declarations) {\n      const sourceFile = decl.getSourceFile();\n      const fileName = sourceFile.fileName;\n\n      const moduleSpecifier = this.resolveModuleSpecifier(fileName);\n      if (moduleSpecifier) {\n        const exportName = resolved.name;\n        const macro = globalRegistry.getByModuleExport(\n          moduleSpecifier,\n          exportName,\n        );\n        if (macro && macro.kind === kind) {\n          return macro;\n        }\n        if (exportName !== macroName) {\n          const macroByName = globalRegistry.getByModuleExport(\n            moduleSpecifier,\n            macroName,\n          );\n          if (macroByName && macroByName.kind === kind) {\n            return macroByName;\n          }\n        }\n      }\n    }\n\n    return this.fallbackNameLookup(macroName, kind);\n  }\n\n  /**\n   * Map a file path back to a module specifier like \"typemacro\" or \"@typemacro/units\".\n   */\n  private resolveModuleSpecifier(fileName: string): string | undefined {\n    const normalized = fileName.replace(/\\\\/g, \"/\");\n\n    // Check for scoped packages in node_modules\n    const nodeModulesMatch = normalized.match(\n      /\\/node_modules\\/((?:@[^/]+\\/)?[^/]+)/,\n    );\n    if (nodeModulesMatch) {\n      const pkgName = nodeModulesMatch[1];\n      // Check for @typemacro scoped packages\n      if (pkgName.startsWith(\"@typemacro/\")) {\n        return pkgName;\n      }\n      if (pkgName === \"typemacro\") {\n        return \"typemacro\";\n      }\n      return pkgName;\n    }\n\n    // Development mode: detect from source tree structure\n    if (normalized.includes(\"/packages/units/\")) return \"@typemacro/units\";\n    if (normalized.includes(\"/packages/effect-do/\"))\n      return \"@typemacro/effect-do\";\n    if (normalized.includes(\"/packages/sql/\")) return \"@typemacro/sql\";\n    if (normalized.includes(\"/packages/strings/\")) return \"@typemacro/strings\";\n    if (normalized.includes(\"/packages/cats/\")) return \"@typemacro/cats\";\n    if (normalized.includes(\"/packages/comptime/\")) return \"@typemacro/comptime\";\n    if (normalized.includes(\"/packages/reflect/\")) return \"@typemacro/reflect\";\n    if (normalized.includes(\"/packages/derive/\")) return \"@typemacro/derive\";\n    if (normalized.includes(\"/packages/operators/\"))\n      return \"@typemacro/operators\";\n    if (normalized.includes(\"/packages/typeclass/\"))\n      return \"@typemacro/typeclass\";\n    if (normalized.includes(\"/packages/specialize/\"))\n      return \"@typemacro/specialize\";\n    if (normalized.includes(\"/packages/core/\")) return \"@typemacro/core\";\n    if (normalized.includes(\"/packages/typemacro/\")) return \"typemacro\";\n\n    // Legacy source tree paths (for backwards compatibility during migration)\n    if (normalized.includes(\"/src/use-cases/units/\")) return \"@typemacro/units\";\n    if (normalized.includes(\"/src/use-cases/effect-do/\"))\n      return \"@typemacro/effect-do\";\n    if (normalized.includes(\"/src/use-cases/sql/\")) return \"@typemacro/sql\";\n    if (normalized.includes(\"/src/use-cases/strings/\"))\n      return \"@typemacro/strings\";\n    if (\n      normalized.includes(\"/src/index.\") ||\n      normalized.includes(\"/src/macros/\") ||\n      normalized.includes(\"/src/core/\") ||\n      normalized.includes(\"/dist/\")\n    ) {\n      return \"typemacro\";\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Fall back to name-based lookup for macros without module requirement.\n   */\n  private fallbackNameLookup(\n    name: string,\n    kind: MacroDefinition[\"kind\"],\n  ): MacroDefinition | undefined {\n    let macro: MacroDefinition | undefined;\n    switch (kind) {\n      case \"expression\":\n        macro = globalRegistry.getExpression(name);\n        break;\n      case \"attribute\":\n        macro = globalRegistry.getAttribute(name);\n        break;\n      case \"derive\":\n        macro = globalRegistry.getDerive(name);\n        break;\n      case \"tagged-template\":\n        macro = globalRegistry.getTaggedTemplate(name);\n        break;\n      case \"type\":\n        macro = globalRegistry.getType(name);\n        break;\n      case \"labeled-block\":\n        macro = globalRegistry.getLabeledBlock(name);\n        break;\n    }\n\n    if (macro?.module) {\n      return undefined;\n    }\n\n    return macro;\n  }\n\n  /**\n   * Visit a node and potentially transform it\n   */\n  visit(node: ts.Node): ts.Node | ts.Node[] {\n    if (ts.isSourceFile(node) || ts.isBlock(node) || ts.isModuleBlock(node)) {\n      return this.visitStatementContainer(node);\n    }\n\n    const transformed = this.tryTransform(node);\n    if (transformed !== undefined) {\n      return transformed;\n    }\n\n    return ts.visitEachChild(\n      node,\n      this.visit.bind(this),\n      this.ctx.transformContext,\n    );\n  }\n\n  /**\n   * Visit a node that contains a statement list.\n   */\n  private visitStatementContainer(\n    node: ts.SourceFile | ts.Block | ts.ModuleBlock,\n  ): ts.SourceFile | ts.Block | ts.ModuleBlock {\n    const statements = Array.from(node.statements);\n    const newStatements: ts.Statement[] = [];\n    let modified = false;\n\n    for (let i = 0; i < statements.length; i++) {\n      const stmt = statements[i];\n\n      if (ts.isLabeledStatement(stmt)) {\n        const labelName = stmt.label.text;\n        const macro = globalRegistry.getLabeledBlock(labelName);\n\n        if (macro) {\n          if (this.verbose) {\n            console.log(\n              `[typemacro] Expanding labeled block macro: ${labelName}:`,\n            );\n          }\n\n          let continuation: ts.LabeledStatement | undefined;\n          if (macro.continuationLabels && i + 1 < statements.length) {\n            const next = statements[i + 1];\n            if (\n              ts.isLabeledStatement(next) &&\n              macro.continuationLabels.includes(next.label.text)\n            ) {\n              continuation = next;\n              i++;\n            }\n          }\n\n          try {\n            const result = macro.expand(this.ctx, stmt, continuation);\n            const expanded = Array.isArray(result) ? result : [result];\n\n            for (const s of expanded) {\n              const visited = ts.visitNode(s, this.visit.bind(this));\n              if (visited) {\n                if (Array.isArray(visited)) {\n                  newStatements.push(\n                    ...(visited as ts.Node[]).filter(ts.isStatement),\n                  );\n                } else {\n                  newStatements.push(visited as ts.Statement);\n                }\n              }\n            }\n          } catch (error) {\n            this.ctx.reportError(\n              stmt,\n              `Labeled block macro expansion failed: ${error}`,\n            );\n            newStatements.push(\n              this.createMacroErrorStatement(\n                `typemacro: labeled block '${labelName}:' expansion failed: ${error}`,\n              ),\n            );\n          }\n\n          modified = true;\n          continue;\n        }\n      }\n\n      const visited = ts.visitNode(stmt, this.visit.bind(this));\n      if (visited) {\n        if (Array.isArray(visited)) {\n          newStatements.push(...(visited as ts.Node[]).filter(ts.isStatement));\n        } else {\n          newStatements.push(visited as ts.Statement);\n        }\n      }\n    }\n\n    const factory = this.ctx.factory;\n    if (ts.isSourceFile(node)) {\n      return factory.updateSourceFile(node, newStatements);\n    } else if (ts.isBlock(node)) {\n      return factory.updateBlock(node, newStatements);\n    } else {\n      return factory.updateModuleBlock(node, newStatements);\n    }\n  }\n\n  /**\n   * Try to transform a node if it's a macro invocation\n   */\n  private tryTransform(node: ts.Node): ts.Node | ts.Node[] | undefined {\n    if (ts.isCallExpression(node)) {\n      const result = this.tryExpandExpressionMacro(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    if (this.hasDecorators(node)) {\n      const result = this.tryExpandAttributeMacros(node as ts.HasDecorators);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    if (ts.isTaggedTemplateExpression(node)) {\n      const result = this.tryExpandTaggedTemplate(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    if (ts.isTypeReferenceNode(node)) {\n      const result = this.tryExpandTypeMacro(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    if (\n      ts.isCallExpression(node) &&\n      ts.isPropertyAccessExpression(node.expression)\n    ) {\n      const result = this.tryRewriteExtensionMethod(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    return undefined;\n  }\n\n  private hasDecorators(node: ts.Node): node is ts.HasDecorators {\n    return ts.canHaveDecorators(node) && ts.getDecorators(node) !== undefined;\n  }\n\n  private tryExpandExpressionMacro(\n    node: ts.CallExpression,\n  ): ts.Expression | undefined {\n    let macroName: string | undefined;\n    let identNode: ts.Node | undefined;\n\n    if (ts.isIdentifier(node.expression)) {\n      macroName = node.expression.text;\n      identNode = node.expression;\n    } else if (ts.isPropertyAccessExpression(node.expression)) {\n      if (ts.isIdentifier(node.expression.expression)) {\n        if (node.expression.expression.text === \"macro\") {\n          macroName = node.expression.name.text;\n          identNode = node.expression.name;\n        } else {\n          macroName = node.expression.name.text;\n          identNode = node.expression;\n        }\n      }\n    }\n\n    if (!macroName || !identNode) return undefined;\n\n    const macro = this.resolveMacroFromSymbol(\n      identNode,\n      macroName,\n      \"expression\",\n    ) as ExpressionMacro | undefined;\n    if (!macro) return undefined;\n\n    if (this.verbose) {\n      console.log(`[typemacro] Expanding expression macro: ${macroName}`);\n    }\n\n    try {\n      const result = macro.expand(this.ctx, node, node.arguments);\n      return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n    } catch (error) {\n      this.ctx.reportError(node, `Macro expansion failed: ${error}`);\n      return this.createMacroErrorExpression(\n        `typemacro: expansion of '${macroName}' failed: ${error}`,\n      );\n    }\n  }\n\n  private tryExpandAttributeMacros(\n    node: ts.HasDecorators,\n  ): ts.Node | ts.Node[] | undefined {\n    const decorators = ts.getDecorators(node);\n    if (!decorators || decorators.length === 0) return undefined;\n\n    let currentNode: ts.Node = node;\n    const extraStatements: ts.Statement[] = [];\n    const remainingDecorators: ts.Decorator[] = [];\n    let wasTransformed = false;\n\n    for (const decorator of decorators) {\n      const { macroName, args, identNode } = this.parseDecorator(decorator);\n\n      if (macroName === \"derive\") {\n        const deriveMacroResolved = identNode\n          ? this.resolveMacroFromSymbol(identNode, \"derive\", \"attribute\")\n          : globalRegistry.getAttribute(\"derive\");\n        if (deriveMacroResolved) {\n          const derives = this.expandDeriveDecorator(decorator, node, args);\n          if (derives) {\n            extraStatements.push(...derives);\n            wasTransformed = true;\n            continue;\n          }\n        }\n      }\n\n      const macro = (\n        identNode\n          ? this.resolveMacroFromSymbol(identNode, macroName, \"attribute\")\n          : globalRegistry.getAttribute(macroName)\n      ) as AttributeMacro | undefined;\n      if (macro) {\n        if (this.verbose) {\n          console.log(`[typemacro] Expanding attribute macro: ${macroName}`);\n        }\n\n        try {\n          const result = macro.expand(\n            this.ctx,\n            decorator,\n            currentNode as ts.Declaration,\n            args,\n          );\n\n          if (Array.isArray(result)) {\n            if (result.length > 0) {\n              currentNode = result[0];\n              extraStatements.push(...result.slice(1).filter(ts.isStatement));\n            }\n          } else {\n            currentNode = result;\n          }\n          wasTransformed = true;\n        } catch (error) {\n          this.ctx.reportError(\n            decorator,\n            `Attribute macro expansion failed: ${error}`,\n          );\n          extraStatements.push(\n            this.createMacroErrorStatement(\n              `typemacro: attribute macro '${macroName}' failed: ${error}`,\n            ),\n          );\n          remainingDecorators.push(decorator);\n          wasTransformed = true;\n        }\n      } else {\n        remainingDecorators.push(decorator);\n      }\n    }\n\n    if (!wasTransformed) return undefined;\n\n    if (remainingDecorators.length !== decorators.length) {\n      currentNode = this.updateDecorators(currentNode, remainingDecorators);\n    }\n\n    const visited = ts.visitNode(currentNode, this.visit.bind(this));\n\n    if (extraStatements.length > 0) {\n      return [visited as ts.Node, ...extraStatements];\n    }\n\n    return visited as ts.Node;\n  }\n\n  private parseDecorator(decorator: ts.Decorator): {\n    macroName: string;\n    args: ts.Expression[];\n    identNode: ts.Node | undefined;\n  } {\n    const expr = decorator.expression;\n\n    if (ts.isIdentifier(expr)) {\n      return { macroName: expr.text, args: [], identNode: expr };\n    }\n\n    if (ts.isCallExpression(expr)) {\n      if (ts.isIdentifier(expr.expression)) {\n        return {\n          macroName: expr.expression.text,\n          args: Array.from(expr.arguments),\n          identNode: expr.expression,\n        };\n      }\n    }\n\n    return { macroName: \"\", args: [], identNode: undefined };\n  }\n\n  private expandDeriveDecorator(\n    decorator: ts.Decorator,\n    node: ts.Node,\n    args: ts.Expression[],\n  ): ts.Statement[] | undefined {\n    if (\n      !ts.isInterfaceDeclaration(node) &&\n      !ts.isClassDeclaration(node) &&\n      !ts.isTypeAliasDeclaration(node)\n    ) {\n      this.ctx.reportError(\n        decorator,\n        \"@derive can only be applied to interfaces, classes, or type aliases\",\n      );\n      return undefined;\n    }\n\n    const statements: ts.Statement[] = [];\n    const typeInfo = this.extractTypeInfo(node);\n\n    for (const arg of args) {\n      if (!ts.isIdentifier(arg)) {\n        this.ctx.reportError(arg, \"derive arguments must be identifiers\");\n        continue;\n      }\n\n      const deriveName = arg.text;\n      const macro = globalRegistry.getDerive(deriveName);\n\n      if (!macro) {\n        this.ctx.reportError(arg, `Unknown derive macro: ${deriveName}`);\n        continue;\n      }\n\n      if (this.verbose) {\n        console.log(`[typemacro] Expanding derive macro: ${deriveName}`);\n      }\n\n      try {\n        const result = macro.expand(this.ctx, node, typeInfo);\n        statements.push(...result);\n      } catch (error) {\n        this.ctx.reportError(arg, `Derive macro expansion failed: ${error}`);\n      }\n    }\n\n    return statements.length > 0 ? statements : undefined;\n  }\n\n  private extractTypeInfo(\n    node:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n  ): DeriveTypeInfo {\n    const name = node.name?.text ?? \"Anonymous\";\n    const type = this.ctx.typeChecker.getTypeAtLocation(node);\n    const typeParameters = node.typeParameters\n      ? Array.from(node.typeParameters)\n      : [];\n\n    const fields: DeriveFieldInfo[] = [];\n    const properties = this.ctx.typeChecker.getPropertiesOfType(type);\n\n    for (const prop of properties) {\n      const declarations = prop.getDeclarations();\n      if (!declarations || declarations.length === 0) continue;\n\n      const decl = declarations[0];\n      const propType = this.ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        decl,\n      );\n      const propTypeString = this.ctx.typeChecker.typeToString(propType);\n\n      const optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n      const readonly =\n        ts.isPropertyDeclaration(decl) || ts.isPropertySignature(decl)\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false;\n\n      fields.push({\n        name: prop.name,\n        typeString: propTypeString,\n        type: propType,\n        optional,\n        readonly,\n      });\n    }\n\n    return { name, fields, typeParameters, type };\n  }\n\n  private tryExpandTaggedTemplate(\n    node: ts.TaggedTemplateExpression,\n  ): ts.Expression | undefined {\n    if (!ts.isIdentifier(node.tag)) return undefined;\n\n    const tagName = node.tag.text;\n\n    const taggedMacro = this.resolveMacroFromSymbol(\n      node.tag,\n      tagName,\n      \"tagged-template\",\n    ) as TaggedTemplateMacroDef | undefined;\n    if (taggedMacro) {\n      if (this.verbose) {\n        console.log(`[typemacro] Expanding tagged template macro: ${tagName}`);\n      }\n\n      try {\n        if (taggedMacro.validate && !taggedMacro.validate(this.ctx, node)) {\n          this.ctx.reportError(\n            node,\n            `Tagged template validation failed for '${tagName}'`,\n          );\n          return this.createMacroErrorExpression(\n            `typemacro: tagged template '${tagName}' validation failed`,\n          );\n        }\n\n        const result = taggedMacro.expand(this.ctx, node);\n        return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n      } catch (error) {\n        this.ctx.reportError(\n          node,\n          `Tagged template macro expansion failed: ${error}`,\n        );\n        return this.createMacroErrorExpression(\n          `typemacro: tagged template '${tagName}' expansion failed: ${error}`,\n        );\n      }\n    }\n\n    const exprMacro = this.resolveMacroFromSymbol(\n      node.tag,\n      tagName,\n      \"expression\",\n    ) as ExpressionMacro | undefined;\n    if (!exprMacro) return undefined;\n\n    if (this.verbose) {\n      console.log(\n        `[typemacro] Expanding tagged template via expression macro: ${tagName}`,\n      );\n    }\n\n    try {\n      const result = exprMacro.expand(\n        this.ctx,\n        node as unknown as ts.CallExpression,\n        [node.template as unknown as ts.Expression],\n      );\n      return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n    } catch (error) {\n      this.ctx.reportError(\n        node,\n        `Tagged template macro expansion failed: ${error}`,\n      );\n      return this.createMacroErrorExpression(\n        `typemacro: tagged template '${tagName}' expansion failed: ${error}`,\n      );\n    }\n  }\n\n  private tryExpandTypeMacro(\n    node: ts.TypeReferenceNode,\n  ): ts.TypeNode | undefined {\n    let macroName: string | undefined;\n    let identNode: ts.Node | undefined;\n\n    if (ts.isIdentifier(node.typeName)) {\n      macroName = node.typeName.text;\n      identNode = node.typeName;\n    } else if (ts.isQualifiedName(node.typeName)) {\n      if (\n        ts.isIdentifier(node.typeName.left) &&\n        node.typeName.left.text === \"typemacro\"\n      ) {\n        macroName = node.typeName.right.text;\n        identNode = node.typeName;\n      }\n    }\n\n    if (!macroName || !identNode) return undefined;\n\n    const macro = this.resolveMacroFromSymbol(identNode, macroName, \"type\") as\n      | TypeMacro\n      | undefined;\n    if (!macro) return undefined;\n\n    if (this.verbose) {\n      console.log(`[typemacro] Expanding type macro: ${macroName}`);\n    }\n\n    try {\n      const typeArgs = node.typeArguments ? Array.from(node.typeArguments) : [];\n      const result = macro.expand(this.ctx, node, typeArgs);\n      return ts.visitNode(result, this.visit.bind(this)) as ts.TypeNode;\n    } catch (error) {\n      this.ctx.reportError(node, `Type macro expansion failed: ${error}`);\n      return node;\n    }\n  }\n\n  /**\n   * Try to rewrite an implicit extension method call.\n   */\n  private tryRewriteExtensionMethod(\n    node: ts.CallExpression,\n  ): ts.Expression | undefined {\n    const propAccess = node.expression as ts.PropertyAccessExpression;\n    const methodName = propAccess.name.text;\n    const receiver = propAccess.expression;\n\n    if (ts.isCallExpression(receiver) && ts.isIdentifier(receiver.expression)) {\n      const calleeName = receiver.expression.text;\n      const calleeMacro = this.resolveMacroFromSymbol(\n        receiver.expression,\n        calleeName,\n        \"expression\",\n      );\n      if (calleeMacro) {\n        return undefined;\n      }\n    }\n\n    const receiverType = this.ctx.typeChecker.getTypeAtLocation(receiver);\n    const existingProp = receiverType.getProperty(methodName);\n\n    if (existingProp) {\n      return undefined;\n    }\n\n    const typeName = this.ctx.typeChecker.typeToString(receiverType);\n\n    // Use the global extension registry\n    let extension = globalExtensionRegistry.find(methodName, typeName);\n\n    // Try without generic parameters\n    if (!extension) {\n      const baseTypeName = typeName.replace(/<.*>$/, \"\");\n      if (baseTypeName !== typeName) {\n        extension = globalExtensionRegistry.find(methodName, baseTypeName);\n      }\n    }\n\n    if (!extension) {\n      return undefined;\n    }\n\n    if (this.verbose) {\n      console.log(\n        `[typemacro] Rewriting implicit extension: ${typeName}.${methodName}() â†’ ${extension.typeclassName}.summon<${typeName}>(\"${typeName}\").${methodName}(...)`,\n      );\n    }\n\n    const receiverText = receiver.getText\n      ? receiver.getText()\n      : ts\n          .createPrinter()\n          .printNode(ts.EmitHint.Expression, receiver, this.ctx.sourceFile);\n\n    const extraArgs = Array.from(node.arguments)\n      .map((a) =>\n        a.getText\n          ? a.getText()\n          : ts\n              .createPrinter()\n              .printNode(ts.EmitHint.Expression, a, this.ctx.sourceFile),\n      )\n      .join(\", \");\n\n    const allArgs = extraArgs ? `${receiverText}, ${extraArgs}` : receiverText;\n\n    const code = `${extension.typeclassName}.summon<${typeName}>(\"${typeName}\").${methodName}(${allArgs})`;\n\n    try {\n      const result = this.ctx.parseExpression(code);\n      return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n    } catch (error) {\n      this.ctx.reportError(node, `Extension method rewrite failed: ${error}`);\n      return undefined;\n    }\n  }\n\n  private createMacroErrorExpression(message: string): ts.Expression {\n    const factory = this.ctx.factory;\n    return factory.createCallExpression(\n      factory.createParenthesizedExpression(\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createBlock([\n            factory.createThrowStatement(\n              factory.createNewExpression(\n                factory.createIdentifier(\"Error\"),\n                undefined,\n                [factory.createStringLiteral(message)],\n              ),\n            ),\n          ]),\n        ),\n      ),\n      undefined,\n      [],\n    );\n  }\n\n  private createMacroErrorStatement(message: string): ts.Statement {\n    const factory = this.ctx.factory;\n    return factory.createThrowStatement(\n      factory.createNewExpression(\n        factory.createIdentifier(\"Error\"),\n        undefined,\n        [factory.createStringLiteral(message)],\n      ),\n    );\n  }\n\n  private updateDecorators(node: ts.Node, decorators: ts.Decorator[]): ts.Node {\n    const modifiers = decorators.length > 0 ? decorators : undefined;\n    const factory = this.ctx.factory;\n\n    if (ts.isClassDeclaration(node)) {\n      return factory.updateClassDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.name,\n        node.typeParameters,\n        node.heritageClauses,\n        node.members,\n      );\n    }\n\n    if (ts.isFunctionDeclaration(node)) {\n      return factory.updateFunctionDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.asteriskToken,\n        node.name,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.body,\n      );\n    }\n\n    if (ts.isMethodDeclaration(node)) {\n      return factory.updateMethodDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.asteriskToken,\n        node.name,\n        node.questionToken,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.body,\n      );\n    }\n\n    if (ts.isInterfaceDeclaration(node)) {\n      return node;\n    }\n\n    return node;\n  }\n}\n\n// Also export for programmatic use\nexport { MacroTransformer };\n"],"mappings":"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","names":["visited"]}