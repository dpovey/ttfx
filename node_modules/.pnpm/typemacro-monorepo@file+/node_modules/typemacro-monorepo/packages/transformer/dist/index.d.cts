import * as ts from 'typescript';
import { MacroContextImpl } from '@typemacro/core';

/**
 * @typemacro/transformer - Main TypeScript transformer for macro expansion
 *
 * This transformer integrates with ts-patch to process macros during compilation.
 */

/**
 * Configuration for the transformer
 */
interface MacroTransformerConfig {
    /** Enable verbose logging */
    verbose?: boolean;
    /** Custom macro module paths to load */
    macroModules?: string[];
}
/**
 * Create the TypeScript transformer factory
 * This is the entry point called by ts-patch
 */
declare function macroTransformerFactory(program: ts.Program, config?: MacroTransformerConfig): ts.TransformerFactory<ts.SourceFile>;
/**
 * The main transformer class that handles macro expansion
 */
declare class MacroTransformer {
    private ctx;
    private verbose;
    private additionalStatements;
    /**
     * Cache of resolved macro symbols for this source file.
     * Maps a ts.Symbol id to the MacroDefinition it resolves to (or null if not a macro).
     * Built lazily as identifiers are encountered.
     */
    private symbolMacroCache;
    constructor(ctx: MacroContextImpl, verbose: boolean);
    /**
     * Resolve an identifier to a macro definition via import tracking.
     */
    private resolveMacroFromSymbol;
    /**
     * Core symbol resolution: follow aliases to find the original declaration,
     * then check if it comes from a known macro module.
     */
    private resolveSymbolToMacro;
    /**
     * Map a file path back to a module specifier like "typemacro" or "@typemacro/units".
     */
    private resolveModuleSpecifier;
    /**
     * Fall back to name-based lookup for macros without module requirement.
     */
    private fallbackNameLookup;
    /**
     * Visit a node and potentially transform it
     */
    visit(node: ts.Node): ts.Node | ts.Node[];
    /**
     * Visit a node that contains a statement list.
     */
    private visitStatementContainer;
    /**
     * Try to transform a node if it's a macro invocation
     */
    private tryTransform;
    private hasDecorators;
    private tryExpandExpressionMacro;
    private tryExpandAttributeMacros;
    private parseDecorator;
    private expandDeriveDecorator;
    private extractTypeInfo;
    private tryExpandTaggedTemplate;
    private tryExpandTypeMacro;
    /**
     * Try to rewrite an implicit extension method call.
     */
    private tryRewriteExtensionMethod;
    private createMacroErrorExpression;
    private createMacroErrorStatement;
    private updateDecorators;
}

// @ts-ignore
export = macroTransformerFactory;
export { MacroTransformer, type MacroTransformerConfig };
