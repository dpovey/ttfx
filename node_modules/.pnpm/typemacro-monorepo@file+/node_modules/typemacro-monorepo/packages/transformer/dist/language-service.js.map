{"version":3,"sources":["../src/language-service.ts"],"sourcesContent":["/**\n * typemacro TypeScript Language Service Plugin\n *\n * Provides IDE integration for typemacro:\n * - Suppresses false-positive diagnostics from macro invocations\n * - Adds custom diagnostics for macro errors\n * - Provides completions inside @derive() decorators\n * - Shows macro expansion info on hover\n *\n * Configure in tsconfig.json:\n * {\n *   \"compilerOptions\": {\n *     \"plugins\": [{ \"name\": \"@typemacro/transformer/language-service\" }]\n *   }\n * }\n */\n\nimport type * as ts from \"typescript\";\n\n/** Known expression macro names from the typemacro core */\nconst EXPRESSION_MACROS = new Set([\n  \"comptime\",\n  \"ops\",\n  \"pipe\",\n  \"compose\",\n  \"summon\",\n  \"extend\",\n  \"typeInfo\",\n  \"fieldNames\",\n  \"validator\",\n]);\n\n/**\n * Known typeclass method names and their providing typeclasses.\n */\nconst TYPECLASS_EXTENSION_METHODS: Record<\n  string,\n  { typeclass: string; description: string; returnType: string }\n> = {\n  show: {\n    typeclass: \"Show\",\n    description: \"Convert to a human-readable string representation\",\n    returnType: \"string\",\n  },\n  eq: {\n    typeclass: \"Eq\",\n    description: \"Check equality with another value\",\n    returnType: \"boolean\",\n  },\n  neq: {\n    typeclass: \"Eq\",\n    description: \"Check inequality with another value\",\n    returnType: \"boolean\",\n  },\n  compare: {\n    typeclass: \"Ord\",\n    description: \"Compare ordering with another value (-1, 0, or 1)\",\n    returnType: \"-1 | 0 | 1\",\n  },\n  hash: {\n    typeclass: \"Hash\",\n    description: \"Compute a hash code for this value\",\n    returnType: \"number\",\n  },\n  combine: {\n    typeclass: \"Semigroup\",\n    description: \"Combine with another value using the Semigroup operation\",\n    returnType: \"self\",\n  },\n  empty: {\n    typeclass: \"Monoid\",\n    description: \"Get the identity element for this type\",\n    returnType: \"self\",\n  },\n  map: {\n    typeclass: \"Functor\",\n    description: \"Apply a function to the contained value(s)\",\n    returnType: \"self\",\n  },\n};\n\nconst EXTENSION_METHOD_NAMES = new Set(\n  Object.keys(TYPECLASS_EXTENSION_METHODS),\n);\n\nconst DECORATOR_MACROS = new Set([\n  \"derive\",\n  \"operators\",\n  \"reflect\",\n  \"typeclass\",\n  \"instance\",\n  \"deriving\",\n  \"inline\",\n]);\n\nconst DERIVE_MACROS = [\n  { name: \"Eq\", description: \"Generate equality comparison function\" },\n  { name: \"Ord\", description: \"Generate ordering/comparison function\" },\n  { name: \"Clone\", description: \"Generate deep clone function\" },\n  { name: \"Debug\", description: \"Generate debug string representation\" },\n  { name: \"Hash\", description: \"Generate hash function\" },\n  { name: \"Default\", description: \"Generate default value factory\" },\n  { name: \"Json\", description: \"Generate JSON serialization/deserialization\" },\n  { name: \"Builder\", description: \"Generate builder pattern class\" },\n];\n\nconst TAGGED_TEMPLATE_MACROS = new Set([\n  \"sql\",\n  \"regex\",\n  \"html\",\n  \"fmt\",\n  \"json\",\n  \"raw\",\n  \"units\",\n]);\n\nconst SUPPRESSED_DIAGNOSTIC_CODES = new Set([\n  1206, // Decorators are not valid here\n  1345, // Expression of type void cannot be tested\n  6133, // Declared but never read\n  2304, // Cannot find name\n  2339, // Property does not exist\n]);\n\nfunction init(modules: { typescript: typeof ts }) {\n  const tsModule = modules.typescript;\n\n  function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n    const log = (msg: string) => {\n      info.project.projectService.logger.info(`[typemacro] ${msg}`);\n    };\n\n    log(\"Language service plugin initialized\");\n\n    const proxy = Object.create(null) as ts.LanguageService;\n    const oldLS = info.languageService;\n\n    for (const k of Object.keys(oldLS)) {\n      const prop = (oldLS as unknown as Record<string, unknown>)[k];\n      if (typeof prop === \"function\") {\n        (proxy as unknown as Record<string, unknown>)[k] = (\n          ...args: unknown[]\n        ): unknown => {\n          return (prop as Function).apply(oldLS, args);\n        };\n      }\n    }\n\n    proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n      const diagnostics = oldLS.getSemanticDiagnostics(fileName);\n      const program = oldLS.getProgram();\n      if (!program) return diagnostics;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return diagnostics;\n\n      return diagnostics.filter((diag) => {\n        if (!SUPPRESSED_DIAGNOSTIC_CODES.has(diag.code)) return true;\n        if (diag.start === undefined) return true;\n\n        const node = findNodeAtPosition(tsModule, sourceFile, diag.start);\n        if (!node) return true;\n\n        if (diag.code === 1206) {\n          const decorator = findAncestor(tsModule, node, tsModule.isDecorator);\n          if (decorator && tsModule.isDecorator(decorator)) {\n            const name = getDecoratorName(tsModule, decorator as ts.Decorator);\n            if (name && DECORATOR_MACROS.has(name)) {\n              log(`Suppressed diagnostic ${diag.code} for @${name}`);\n              return false;\n            }\n          }\n        }\n\n        if (diag.code === 2304) {\n          if (isNearMacroInvocation(tsModule, sourceFile, node)) {\n            log(`Suppressed diagnostic ${diag.code} near macro invocation`);\n            return false;\n          }\n        }\n\n        if (diag.code === 2339) {\n          if (isExtensionMethodCall(tsModule, sourceFile, node)) {\n            log(`Suppressed diagnostic ${diag.code} for extension method call`);\n            return false;\n          }\n        }\n\n        return true;\n      });\n    };\n\n    proxy.getCompletionsAtPosition = (\n      fileName: string,\n      position: number,\n      options: ts.GetCompletionsAtPositionOptions | undefined,\n    ): ts.WithMetadata<ts.CompletionInfo> | undefined => {\n      const prior = oldLS.getCompletionsAtPosition(fileName, position, options);\n\n      const program = oldLS.getProgram();\n      if (!program) return prior;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return prior;\n\n      const node = findNodeAtPosition(tsModule, sourceFile, position);\n      if (!node) return prior;\n\n      const deriveContext = findDeriveContext(tsModule, node);\n      if (deriveContext) {\n        const deriveEntries: ts.CompletionEntry[] = DERIVE_MACROS.map(\n          (macro) => ({\n            name: macro.name,\n            kind: tsModule.ScriptElementKind.constElement,\n            kindModifiers: \"\",\n            sortText: `0${macro.name}`,\n            labelDetails: {\n              description: macro.description,\n            },\n          }),\n        );\n\n        if (prior) {\n          return {\n            ...prior,\n            entries: [...deriveEntries, ...prior.entries],\n          };\n        }\n\n        return {\n          isGlobalCompletion: false,\n          isMemberCompletion: false,\n          isNewIdentifierLocation: false,\n          entries: deriveEntries,\n        };\n      }\n\n      const extensionEntries = getExtensionMethodCompletions(\n        tsModule,\n        sourceFile,\n        node,\n        program,\n      );\n      if (extensionEntries.length > 0) {\n        if (prior) {\n          return {\n            ...prior,\n            entries: [...extensionEntries, ...prior.entries],\n          };\n        }\n\n        return {\n          isGlobalCompletion: false,\n          isMemberCompletion: true,\n          isNewIdentifierLocation: false,\n          entries: extensionEntries,\n        };\n      }\n\n      return prior;\n    };\n\n    proxy.getQuickInfoAtPosition = (\n      fileName: string,\n      position: number,\n    ): ts.QuickInfo | undefined => {\n      const prior = oldLS.getQuickInfoAtPosition(fileName, position);\n\n      const program = oldLS.getProgram();\n      if (!program) return prior;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return prior;\n\n      const node = findNodeAtPosition(tsModule, sourceFile, position);\n      if (!node) return prior;\n\n      if (tsModule.isIdentifier(node)) {\n        const name = node.text;\n\n        if (EXPRESSION_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro expression macro) ${name}`,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This call is expanded at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n\n        if (DECORATOR_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro decorator macro) @${name}`,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This decorator is processed at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n\n        if (TAGGED_TEMPLATE_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro tagged template macro) ${name}\\`...\\``,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This tagged template is processed at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n\n        const extInfo = getExtensionMethodHoverInfo(\n          tsModule,\n          sourceFile,\n          node,\n          program,\n        );\n        if (extInfo) {\n          return {\n            kind: tsModule.ScriptElementKind.memberFunctionElement,\n            kindModifiers: \"typemacro extension\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: extInfo.displayText,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: extInfo.documentation,\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n      }\n\n      return prior;\n    };\n\n    return proxy;\n  }\n\n  return { create };\n}\n\nfunction findNodeAtPosition(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  position: number,\n): ts.Node | undefined {\n  function find(node: ts.Node): ts.Node | undefined {\n    if (position >= node.getStart(sourceFile) && position < node.getEnd()) {\n      return ts.forEachChild(node, find) ?? node;\n    }\n    return undefined;\n  }\n  return find(sourceFile);\n}\n\nfunction findAncestor(\n  ts: typeof import(\"typescript\"),\n  node: ts.Node,\n  predicate: (node: ts.Node) => boolean,\n): ts.Node | undefined {\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (predicate(current)) return current;\n    current = current.parent;\n  }\n  return undefined;\n}\n\nfunction getDecoratorName(\n  ts: typeof import(\"typescript\"),\n  decorator: ts.Decorator,\n): string | undefined {\n  const expr = decorator.expression;\n  if (ts.isIdentifier(expr)) return expr.text;\n  if (ts.isCallExpression(expr) && ts.isIdentifier(expr.expression)) {\n    return expr.expression.text;\n  }\n  return undefined;\n}\n\nfunction findDeriveContext(\n  ts: typeof import(\"typescript\"),\n  node: ts.Node,\n): boolean {\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (ts.isCallExpression(current)) {\n      if (\n        ts.isIdentifier(current.expression) &&\n        current.expression.text === \"derive\"\n      ) {\n        return true;\n      }\n    }\n    if (ts.isDecorator(current)) {\n      const name = getDecoratorName(ts, current);\n      if (name === \"derive\") return true;\n    }\n    current = current.parent;\n  }\n  return false;\n}\n\nfunction isNearMacroInvocation(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  node: ts.Node,\n): boolean {\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (ts.isCallExpression(current)) {\n      if (ts.isIdentifier(current.expression)) {\n        if (EXPRESSION_MACROS.has(current.expression.text)) return true;\n      }\n    }\n    if (ts.isTaggedTemplateExpression(current)) {\n      if (ts.isIdentifier(current.tag)) {\n        if (TAGGED_TEMPLATE_MACROS.has(current.tag.text)) return true;\n      }\n    }\n    if (ts.isBlock(current) || ts.isSourceFile(current)) {\n      for (const stmt of current.statements ?? []) {\n        if (\n          ts.isExpressionStatement(stmt) &&\n          ts.isCallExpression(stmt.expression)\n        ) {\n          if (ts.isIdentifier(stmt.expression.expression)) {\n            if (EXPRESSION_MACROS.has(stmt.expression.expression.text))\n              return true;\n          }\n        }\n      }\n    }\n    current = current.parent;\n  }\n  return false;\n}\n\nfunction isExtensionMethodCall(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  node: ts.Node,\n): boolean {\n  if (ts.isIdentifier(node) && EXTENSION_METHOD_NAMES.has(node.text)) {\n    const parent = node.parent;\n    if (parent && ts.isPropertyAccessExpression(parent)) {\n      const grandParent = parent.parent;\n      if (grandParent && ts.isCallExpression(grandParent)) {\n        return true;\n      }\n      return true;\n    }\n  }\n\n  if (ts.isPropertyAccessExpression(node)) {\n    if (EXTENSION_METHOD_NAMES.has(node.name.text)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getExtensionMethodCompletions(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  node: ts.Node,\n  program: ts.Program | undefined,\n): ts.CompletionEntry[] {\n  if (!program) return [];\n\n  let propAccess: ts.PropertyAccessExpression | undefined;\n\n  if (ts.isPropertyAccessExpression(node)) {\n    propAccess = node;\n  } else if (node.parent && ts.isPropertyAccessExpression(node.parent)) {\n    propAccess = node.parent;\n  }\n\n  if (!propAccess) return [];\n\n  const checker = program.getTypeChecker();\n  const receiverType = checker.getTypeAtLocation(propAccess.expression);\n\n  const entries: ts.CompletionEntry[] = [];\n\n  for (const [methodName, info] of Object.entries(\n    TYPECLASS_EXTENSION_METHODS,\n  )) {\n    const existingProp = receiverType.getProperty(methodName);\n    if (existingProp) continue;\n\n    const returnType =\n      info.returnType === \"self\"\n        ? checker.typeToString(receiverType)\n        : info.returnType;\n\n    entries.push({\n      name: methodName,\n      kind: ts.ScriptElementKind.memberFunctionElement,\n      kindModifiers: \"typemacro\",\n      sortText: `1_ext_${methodName}`,\n      labelDetails: {\n        description: `(extension via ${info.typeclass}) â†’ ${returnType}`,\n      },\n    });\n  }\n\n  return entries;\n}\n\nfunction getExtensionMethodHoverInfo(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  node: ts.Identifier,\n  program: ts.Program | undefined,\n): { displayText: string; documentation: string } | undefined {\n  if (!program) return undefined;\n\n  const methodName = node.text;\n  const info = TYPECLASS_EXTENSION_METHODS[methodName];\n  if (!info) return undefined;\n\n  const parent = node.parent;\n  if (!parent || !ts.isPropertyAccessExpression(parent)) return undefined;\n\n  const checker = program.getTypeChecker();\n  const receiverType = checker.getTypeAtLocation(parent.expression);\n  const existingProp = receiverType.getProperty(methodName);\n  if (existingProp) return undefined;\n\n  const typeName = checker.typeToString(receiverType);\n  const returnType = info.returnType === \"self\" ? typeName : info.returnType;\n\n  return {\n    displayText: `(extension method via ${info.typeclass}) ${typeName}.${methodName}(): ${returnType}`,\n    documentation:\n      `${info.description}\\n\\n` +\n      `Provided by the ${info.typeclass} typeclass. ` +\n      `At compile time, this is rewritten to:\\n` +\n      `  ${info.typeclass}.summon<${typeName}>(\"${typeName}\").${methodName}(...)`,\n  };\n}\n\nexport default init;\n"],"mappings":"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","names":[]}