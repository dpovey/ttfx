// src/index.ts
import * as ts from "typescript";
import {
  defineExpressionMacro,
  defineAttributeMacro,
  globalRegistry
} from "@typemacro/core";
var operatorMappings = /* @__PURE__ */ new Map();
function clearOperatorMappings() {
  operatorMappings.clear();
}
function registerOperators(typeName, mappings) {
  const typeMap = operatorMappings.get(typeName) ?? /* @__PURE__ */ new Map();
  for (const [op, method] of Object.entries(mappings)) {
    typeMap.set(op, method);
  }
  operatorMappings.set(typeName, typeMap);
}
function getOperatorMethod(typeName, operator) {
  const explicit = operatorMappings.get(typeName)?.get(operator);
  if (explicit) return explicit;
  return void 0;
}
var operatorsAttribute = defineAttributeMacro({
  name: "operators",
  module: "@typemacro/operators",
  description: "Define operator overloading mappings for a class",
  validTargets: ["class"],
  expand(ctx, decorator, target, args) {
    if (!ts.isClassDeclaration(target) || !target.name) {
      ctx.reportError(
        decorator,
        "@operators can only be applied to named classes"
      );
      return target;
    }
    const className = target.name.text;
    if (args.length !== 1 || !ts.isObjectLiteralExpression(args[0])) {
      ctx.reportError(
        decorator,
        "@operators requires an object literal argument"
      );
      return target;
    }
    const mappings = {};
    for (const prop of args[0].properties) {
      if (ts.isPropertyAssignment(prop)) {
        let keyName;
        if (ts.isStringLiteral(prop.name)) {
          keyName = prop.name.text;
        } else if (ts.isIdentifier(prop.name)) {
          keyName = prop.name.text;
        }
        if (keyName && ts.isStringLiteral(prop.initializer)) {
          mappings[keyName] = prop.initializer.text;
        }
      }
    }
    registerOperators(className, mappings);
    return target;
  }
});
var opsMacro = defineExpressionMacro({
  name: "ops",
  module: "@typemacro/operators",
  description: "Transform operators into method calls",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "ops() expects exactly one expression argument"
      );
      return callExpr;
    }
    const expr = args[0];
    return transformExpression(ctx, expr);
  }
});
function transformExpression(ctx, expr) {
  const factory = ctx.factory;
  if (ts.isBinaryExpression(expr)) {
    const operator = getOperatorString(expr.operatorToken.kind);
    if (!operator) {
      return factory.updateBinaryExpression(
        expr,
        transformExpression(ctx, expr.left),
        expr.operatorToken,
        transformExpression(ctx, expr.right)
      );
    }
    const leftType = ctx.getTypeOf(expr.left);
    const typeName = ctx.typeChecker.typeToString(leftType);
    const baseTypeName = typeName.split("<")[0].trim();
    const method = getOperatorMethod(baseTypeName, operator);
    if (method) {
      const left = transformExpression(ctx, expr.left);
      const right = transformExpression(ctx, expr.right);
      return factory.createCallExpression(
        factory.createPropertyAccessExpression(left, method),
        void 0,
        [right]
      );
    }
    return factory.updateBinaryExpression(
      expr,
      transformExpression(ctx, expr.left),
      expr.operatorToken,
      transformExpression(ctx, expr.right)
    );
  }
  if (ts.isPrefixUnaryExpression(expr)) {
    const operator = getPrefixOperatorString(expr.operator);
    if (operator) {
      const operandType = ctx.getTypeOf(expr.operand);
      const typeName = ctx.typeChecker.typeToString(operandType).split("<")[0].trim();
      const method = getOperatorMethod(typeName, operator);
      if (method) {
        const operand = transformExpression(ctx, expr.operand);
        return factory.createCallExpression(
          factory.createPropertyAccessExpression(operand, method),
          void 0,
          []
        );
      }
    }
    return factory.updatePrefixUnaryExpression(
      expr,
      transformExpression(ctx, expr.operand)
    );
  }
  if (ts.isParenthesizedExpression(expr)) {
    return factory.updateParenthesizedExpression(
      expr,
      transformExpression(ctx, expr.expression)
    );
  }
  if (ts.isCallExpression(expr)) {
    return factory.updateCallExpression(
      expr,
      transformExpression(ctx, expr.expression),
      expr.typeArguments,
      expr.arguments.map((arg) => transformExpression(ctx, arg))
    );
  }
  if (ts.isPropertyAccessExpression(expr)) {
    return factory.updatePropertyAccessExpression(
      expr,
      transformExpression(ctx, expr.expression),
      expr.name
    );
  }
  return expr;
}
function getOperatorString(kind) {
  switch (kind) {
    case ts.SyntaxKind.PlusToken:
      return "+";
    case ts.SyntaxKind.MinusToken:
      return "-";
    case ts.SyntaxKind.AsteriskToken:
      return "*";
    case ts.SyntaxKind.SlashToken:
      return "/";
    case ts.SyntaxKind.PercentToken:
      return "%";
    case ts.SyntaxKind.AsteriskAsteriskToken:
      return "**";
    case ts.SyntaxKind.LessThanToken:
      return "<";
    case ts.SyntaxKind.LessThanEqualsToken:
      return "<=";
    case ts.SyntaxKind.GreaterThanToken:
      return ">";
    case ts.SyntaxKind.GreaterThanEqualsToken:
      return ">=";
    case ts.SyntaxKind.EqualsEqualsToken:
      return "==";
    case ts.SyntaxKind.EqualsEqualsEqualsToken:
      return "===";
    case ts.SyntaxKind.ExclamationEqualsToken:
      return "!=";
    case ts.SyntaxKind.ExclamationEqualsEqualsToken:
      return "!==";
    case ts.SyntaxKind.AmpersandToken:
      return "&";
    case ts.SyntaxKind.BarToken:
      return "|";
    case ts.SyntaxKind.CaretToken:
      return "^";
    case ts.SyntaxKind.LessThanLessThanToken:
      return "<<";
    case ts.SyntaxKind.GreaterThanGreaterThanToken:
      return ">>";
    default:
      return void 0;
  }
}
function getPrefixOperatorString(kind) {
  switch (kind) {
    case ts.SyntaxKind.MinusToken:
      return "-unary";
    case ts.SyntaxKind.PlusToken:
      return "+unary";
    case ts.SyntaxKind.ExclamationToken:
      return "!";
    case ts.SyntaxKind.TildeToken:
      return "~";
    default:
      return void 0;
  }
}
var pipeMacro = defineExpressionMacro({
  name: "pipe",
  module: "@typemacro/operators",
  description: "Pipe a value through a series of functions",
  expand(ctx, callExpr, args) {
    if (args.length < 2) {
      ctx.reportError(
        callExpr,
        "pipe() requires at least an initial value and one function"
      );
      return callExpr;
    }
    const factory = ctx.factory;
    let result = args[0];
    for (let i = 1; i < args.length; i++) {
      result = factory.createCallExpression(args[i], void 0, [result]);
    }
    return result;
  }
});
var composeMacro = defineExpressionMacro({
  name: "compose",
  module: "@typemacro/operators",
  description: "Compose functions right-to-left",
  expand(ctx, callExpr, args) {
    if (args.length < 1) {
      ctx.reportError(callExpr, "compose() requires at least one function");
      return callExpr;
    }
    const factory = ctx.factory;
    const paramName = ctx.generateUniqueName("x");
    let body = paramName;
    for (let i = args.length - 1; i >= 0; i--) {
      body = factory.createCallExpression(args[i], void 0, [body]);
    }
    return factory.createArrowFunction(
      void 0,
      void 0,
      [factory.createParameterDeclaration(void 0, void 0, paramName)],
      void 0,
      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
      body
    );
  }
});
function register() {
  globalRegistry.register(operatorsAttribute);
  globalRegistry.register(opsMacro);
  globalRegistry.register(pipeMacro);
  globalRegistry.register(composeMacro);
}
register();
export {
  clearOperatorMappings,
  composeMacro,
  getOperatorMethod,
  operatorsAttribute,
  opsMacro,
  pipeMacro,
  register,
  registerOperators
};
//# sourceMappingURL=index.js.map