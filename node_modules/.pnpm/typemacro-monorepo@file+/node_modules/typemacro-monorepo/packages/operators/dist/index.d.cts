import * as _typemacro_core from '@typemacro/core';

/**
 * Operator Overloading Macros
 *
 * Provides operator overloading for TypeScript through macro expansion.
 * This transforms operator usage into method calls at compile time.
 *
 * Usage:
 *   @operators({ "+": "add", "-": "sub", "*": "mul", "/": "div" })
 *   class Vector {
 *     add(other: Vector): Vector { ... }
 *   }
 *
 *   // Usage:
 *   const c = ops(a + b);  // Expands to: a.add(b)
 */
/**
 * Clear all operator mappings (for testing)
 */
declare function clearOperatorMappings(): void;
/**
 * Register operator mappings for a type
 */
declare function registerOperators(typeName: string, mappings: Record<string, string>): void;
/**
 * Get the method name for an operator on a type.
 * Falls back to checking well-known method names by convention
 * if no explicit mapping is registered.
 */
declare function getOperatorMethod(typeName: string, operator: string): string | undefined;
declare const operatorsAttribute: _typemacro_core.AttributeMacro;
declare const opsMacro: _typemacro_core.ExpressionMacro;
declare const pipeMacro: _typemacro_core.ExpressionMacro;
declare const composeMacro: _typemacro_core.ExpressionMacro;
/**
 * Register macros with the global registry.
 * Call this function to enable operator macros in your project.
 */
declare function register(): void;

export { clearOperatorMappings, composeMacro, getOperatorMethod, operatorsAttribute, opsMacro, pipeMacro, register, registerOperators };
