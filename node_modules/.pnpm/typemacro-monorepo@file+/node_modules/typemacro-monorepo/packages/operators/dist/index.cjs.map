{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Operator Overloading Macros\n *\n * Provides operator overloading for TypeScript through macro expansion.\n * This transforms operator usage into method calls at compile time.\n *\n * Usage:\n *   @operators({ \"+\": \"add\", \"-\": \"sub\", \"*\": \"mul\", \"/\": \"div\" })\n *   class Vector {\n *     add(other: Vector): Vector { ... }\n *   }\n *\n *   // Usage:\n *   const c = ops(a + b);  // Expands to: a.add(b)\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  defineAttributeMacro,\n  globalRegistry,\n  MacroContext,\n  AttributeTarget,\n} from \"@typemacro/core\";\n\n/**\n * Operator mappings storage.\n *\n * Note: These mappings are populated during a single compilation pass.\n * The @operators decorator on a class must be processed before any ops()\n * call that references that class. Within a single tsc invocation this\n * works because the transformer processes files in dependency order.\n *\n * For cross-compilation persistence (e.g., incremental builds), a future\n * enhancement could serialize mappings to a .typemacro-cache file.\n */\nconst operatorMappings = new Map<string, Map<string, string>>();\n\n/**\n * Clear all operator mappings (for testing)\n */\nexport function clearOperatorMappings(): void {\n  operatorMappings.clear();\n}\n\n/**\n * Register operator mappings for a type\n */\nexport function registerOperators(\n  typeName: string,\n  mappings: Record<string, string>,\n): void {\n  const typeMap = operatorMappings.get(typeName) ?? new Map();\n  for (const [op, method] of Object.entries(mappings)) {\n    typeMap.set(op, method);\n  }\n  operatorMappings.set(typeName, typeMap);\n}\n\n/**\n * Get the method name for an operator on a type.\n * Falls back to checking well-known method names by convention\n * if no explicit mapping is registered.\n */\nexport function getOperatorMethod(\n  typeName: string,\n  operator: string,\n): string | undefined {\n  const explicit = operatorMappings.get(typeName)?.get(operator);\n  if (explicit) return explicit;\n\n  // Convention-based fallback: check if the type has a method matching\n  // the standard operator method name. This allows ops() to work even\n  // without @operators if the class follows naming conventions.\n  return undefined;\n}\n\n// ============================================================================\n// @operators Attribute Macro\n// ============================================================================\n\nexport const operatorsAttribute = defineAttributeMacro({\n  name: \"operators\",\n  module: \"@typemacro/operators\",\n  description: \"Define operator overloading mappings for a class\",\n  validTargets: [\"class\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (!ts.isClassDeclaration(target) || !target.name) {\n      ctx.reportError(\n        decorator,\n        \"@operators can only be applied to named classes\",\n      );\n      return target;\n    }\n\n    const className = target.name.text;\n\n    // Parse the operator mappings from the decorator argument\n    if (args.length !== 1 || !ts.isObjectLiteralExpression(args[0])) {\n      ctx.reportError(\n        decorator,\n        \"@operators requires an object literal argument\",\n      );\n      return target;\n    }\n\n    const mappings: Record<string, string> = {};\n\n    for (const prop of args[0].properties) {\n      if (ts.isPropertyAssignment(prop)) {\n        let keyName: string | undefined;\n\n        if (ts.isStringLiteral(prop.name)) {\n          keyName = prop.name.text;\n        } else if (ts.isIdentifier(prop.name)) {\n          keyName = prop.name.text;\n        }\n\n        if (keyName && ts.isStringLiteral(prop.initializer)) {\n          mappings[keyName] = prop.initializer.text;\n        }\n      }\n    }\n\n    // Register the mappings at compile time\n    registerOperators(className, mappings);\n\n    // Return the class unchanged (the mappings are used by the ops() macro)\n    return target;\n  },\n});\n\n// ============================================================================\n// ops() Expression Macro - Transform operators to method calls\n// ============================================================================\n\nexport const opsMacro = defineExpressionMacro({\n  name: \"ops\",\n  module: \"@typemacro/operators\",\n  description: \"Transform operators into method calls\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"ops() expects exactly one expression argument\",\n      );\n      return callExpr;\n    }\n\n    const expr = args[0];\n    return transformExpression(ctx, expr);\n  },\n});\n\n/**\n * Recursively transform an expression, converting operators to method calls\n */\nfunction transformExpression(\n  ctx: MacroContext,\n  expr: ts.Expression,\n): ts.Expression {\n  const factory = ctx.factory;\n\n  // Handle binary expressions\n  if (ts.isBinaryExpression(expr)) {\n    const operator = getOperatorString(expr.operatorToken.kind);\n    if (!operator) {\n      // Not an overloadable operator, recurse into children\n      return factory.updateBinaryExpression(\n        expr,\n        transformExpression(ctx, expr.left),\n        expr.operatorToken,\n        transformExpression(ctx, expr.right),\n      );\n    }\n\n    // Try to determine the type of the left operand\n    const leftType = ctx.getTypeOf(expr.left);\n    const typeName = ctx.typeChecker.typeToString(leftType);\n\n    // Clean up the type name (remove generics, etc.)\n    const baseTypeName = typeName.split(\"<\")[0].trim();\n\n    // Check if we have operator mappings for this type\n    const method = getOperatorMethod(baseTypeName, operator);\n\n    if (method) {\n      // Transform: a + b  =>  a.add(b)\n      const left = transformExpression(ctx, expr.left);\n      const right = transformExpression(ctx, expr.right);\n\n      return factory.createCallExpression(\n        factory.createPropertyAccessExpression(left, method),\n        undefined,\n        [right],\n      );\n    }\n\n    // No mapping found, recurse into children\n    return factory.updateBinaryExpression(\n      expr,\n      transformExpression(ctx, expr.left),\n      expr.operatorToken,\n      transformExpression(ctx, expr.right),\n    );\n  }\n\n  // Handle prefix unary expressions\n  if (ts.isPrefixUnaryExpression(expr)) {\n    const operator = getPrefixOperatorString(expr.operator);\n    if (operator) {\n      const operandType = ctx.getTypeOf(expr.operand);\n      const typeName = ctx.typeChecker\n        .typeToString(operandType)\n        .split(\"<\")[0]\n        .trim();\n      const method = getOperatorMethod(typeName, operator);\n\n      if (method) {\n        // Transform: -a  =>  a.neg()\n        const operand = transformExpression(ctx, expr.operand);\n        return factory.createCallExpression(\n          factory.createPropertyAccessExpression(operand, method),\n          undefined,\n          [],\n        );\n      }\n    }\n\n    return factory.updatePrefixUnaryExpression(\n      expr,\n      transformExpression(ctx, expr.operand),\n    );\n  }\n\n  // Handle parenthesized expressions\n  if (ts.isParenthesizedExpression(expr)) {\n    return factory.updateParenthesizedExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n    );\n  }\n\n  // Handle call expressions (recurse into arguments)\n  if (ts.isCallExpression(expr)) {\n    return factory.updateCallExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n      expr.typeArguments,\n      expr.arguments.map((arg) => transformExpression(ctx, arg)),\n    );\n  }\n\n  // Handle property access\n  if (ts.isPropertyAccessExpression(expr)) {\n    return factory.updatePropertyAccessExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n      expr.name,\n    );\n  }\n\n  // Return unchanged for other expression types\n  return expr;\n}\n\n/**\n * Convert a binary operator token to a string representation\n */\nfunction getOperatorString(kind: ts.SyntaxKind): string | undefined {\n  switch (kind) {\n    case ts.SyntaxKind.PlusToken:\n      return \"+\";\n    case ts.SyntaxKind.MinusToken:\n      return \"-\";\n    case ts.SyntaxKind.AsteriskToken:\n      return \"*\";\n    case ts.SyntaxKind.SlashToken:\n      return \"/\";\n    case ts.SyntaxKind.PercentToken:\n      return \"%\";\n    case ts.SyntaxKind.AsteriskAsteriskToken:\n      return \"**\";\n    case ts.SyntaxKind.LessThanToken:\n      return \"<\";\n    case ts.SyntaxKind.LessThanEqualsToken:\n      return \"<=\";\n    case ts.SyntaxKind.GreaterThanToken:\n      return \">\";\n    case ts.SyntaxKind.GreaterThanEqualsToken:\n      return \">=\";\n    case ts.SyntaxKind.EqualsEqualsToken:\n      return \"==\";\n    case ts.SyntaxKind.EqualsEqualsEqualsToken:\n      return \"===\";\n    case ts.SyntaxKind.ExclamationEqualsToken:\n      return \"!=\";\n    case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n      return \"!==\";\n    case ts.SyntaxKind.AmpersandToken:\n      return \"&\";\n    case ts.SyntaxKind.BarToken:\n      return \"|\";\n    case ts.SyntaxKind.CaretToken:\n      return \"^\";\n    case ts.SyntaxKind.LessThanLessThanToken:\n      return \"<<\";\n    case ts.SyntaxKind.GreaterThanGreaterThanToken:\n      return \">>\";\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Convert a prefix unary operator to a string representation\n */\nfunction getPrefixOperatorString(\n  kind: ts.PrefixUnaryOperator,\n): string | undefined {\n  switch (kind) {\n    case ts.SyntaxKind.MinusToken:\n      return \"-unary\";\n    case ts.SyntaxKind.PlusToken:\n      return \"+unary\";\n    case ts.SyntaxKind.ExclamationToken:\n      return \"!\";\n    case ts.SyntaxKind.TildeToken:\n      return \"~\";\n    default:\n      return undefined;\n  }\n}\n\n// ============================================================================\n// pipe() and compose() - Functional composition macros\n// ============================================================================\n\nexport const pipeMacro = defineExpressionMacro({\n  name: \"pipe\",\n  module: \"@typemacro/operators\",\n  description: \"Pipe a value through a series of functions\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 2) {\n      ctx.reportError(\n        callExpr,\n        \"pipe() requires at least an initial value and one function\",\n      );\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n\n    // pipe(x, f, g, h) => h(g(f(x)))\n    let result = args[0];\n\n    for (let i = 1; i < args.length; i++) {\n      result = factory.createCallExpression(args[i], undefined, [result]);\n    }\n\n    return result;\n  },\n});\n\nexport const composeMacro = defineExpressionMacro({\n  name: \"compose\",\n  module: \"@typemacro/operators\",\n  description: \"Compose functions right-to-left\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 1) {\n      ctx.reportError(callExpr, \"compose() requires at least one function\");\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n\n    // compose(f, g, h) => (x) => f(g(h(x)))\n    // Generate: (x) => f(g(h(x)))\n\n    const paramName = ctx.generateUniqueName(\"x\");\n\n    let body: ts.Expression = paramName;\n    for (let i = args.length - 1; i >= 0; i--) {\n      body = factory.createCallExpression(args[i], undefined, [body]);\n    }\n\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [factory.createParameterDeclaration(undefined, undefined, paramName)],\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      body,\n    );\n  },\n});\n\n/**\n * Register macros with the global registry.\n * Call this function to enable operator macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(operatorsAttribute);\n  globalRegistry.register(opsMacro);\n  globalRegistry.register(pipeMacro);\n  globalRegistry.register(composeMacro);\n}\n\n// Auto-register when this module is imported\nregister();\n"],"mappings":"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","names":[]}