import * as _typemacro_core from '@typemacro/core';

/**
 * Zero-Cost Option<T> - Compiles to null/undefined checks
 *
 * At the type level, Option<T> provides a rich monadic API (map, flatMap,
 * unwrapOr, match, etc.). The macro transforms all method chains into
 * inlined null checks — no wrapper objects, no allocations, no vtable dispatch.
 *
 * @example
 * ```typescript
 * // Source (what you write):
 * const name = Option.from(user.name)
 *   .map(n => n.trim())
 *   .filter(n => n.length > 0)
 *   .unwrapOr("Anonymous");
 *
 * // Compiled output (what runs):
 * const __opt_0 = user.name;
 * const __opt_1 = __opt_0 != null ? __opt_0.trim() : null;
 * const __opt_2 = __opt_1 != null ? (__opt_1.length > 0 ? __opt_1 : null) : null;
 * const name = __opt_2 != null ? __opt_2 : "Anonymous";
 * ```
 */
/** Represents an optional value — either Some(T) or None */
type Option<T> = T | null;
/** Option namespace with constructors and utilities */
declare const Option: {
    /** Wrap a nullable value into an Option */
    readonly from: <T>(value: T | null | undefined) => Option<T>;
    /** Create a Some value */
    readonly some: <T>(value: T) => Option<T>;
    /** The None value */
    readonly none: Option<never>;
    /** Check if an Option is Some */
    readonly isSome: <T>(opt: Option<T>) => opt is T;
    /** Check if an Option is None */
    readonly isNone: <T>(opt: Option<T>) => opt is null;
};
declare const optionMacro: _typemacro_core.ExpressionMacro;

/**
 * Zero-Cost Result<T, E> - Compiles to discriminated union checks
 *
 * Result<T, E> represents either success (Ok<T>) or failure (Err<E>).
 * The macro inlines all method chains into direct property access and
 * conditional checks — no wrapper classes, no allocations.
 *
 * The runtime representation is a plain object: { ok: true, value: T } | { ok: false, error: E }
 * The macro compiles away all method calls into direct field access.
 *
 * @example
 * ```typescript
 * // Source (what you write):
 * const parsed = Result.try(() => JSON.parse(input))
 *   .map(data => data.name)
 *   .mapErr(e => `Parse failed: ${e.message}`)
 *   .unwrapOr("unknown");
 *
 * // Compiled output (what runs):
 * let __res_0;
 * try { __res_0 = { ok: true, value: JSON.parse(input) }; }
 * catch (__e) { __res_0 = { ok: false, error: __e }; }
 * const __res_1 = __res_0.ok ? { ok: true, value: __res_0.value.name } : __res_0;
 * const __res_2 = __res_1.ok ? __res_1 : { ok: false, error: `Parse failed: ${__res_1.error.message}` };
 * const parsed = __res_2.ok ? __res_2.value : "unknown";
 * ```
 */
/** A successful result */
interface Ok<T> {
    readonly ok: true;
    readonly value: T;
}
/** A failed result */
interface Err<E> {
    readonly ok: false;
    readonly error: E;
}
/** Discriminated union of Ok and Err */
type Result<T, E> = Ok<T> | Err<E>;
/** Result namespace with constructors */
declare const Result: {
    /** Create a successful result */
    readonly ok: <T>(value: T) => Result<T, never>;
    /** Create a failed result */
    readonly err: <E>(error: E) => Result<never, E>;
    /** Wrap a throwing function into a Result */
    readonly try: <T>(fn: () => T) => Result<T, Error>;
    /** Wrap a Promise into a Result */
    readonly fromPromise: <T>(promise: Promise<T>) => Promise<Result<T, Error>>;
    /** Check if a Result is Ok */
    readonly isOk: <T, E>(result: Result<T, E>) => result is Ok<T>;
    /** Check if a Result is Err */
    readonly isErr: <T, E>(result: Result<T, E>) => result is Err<E>;
    /** Collect an array of Results into a Result of array */
    readonly all: <T, E>(results: Result<T, E>[]) => Result<T[], E>;
};
declare const resultMacro: _typemacro_core.ExpressionMacro;

/**
 * Zero-Cost Newtype - Branded types that compile away completely
 *
 * Newtypes provide type-safe wrappers around primitive types at zero runtime
 * cost. The brand exists only in the type system — at runtime, the value is
 * just the underlying primitive. The macro erases all wrap/unwrap calls.
 *
 * Inspired by Haskell's newtype and Rust's newtype pattern.
 *
 * @example
 * ```typescript
 * // Define branded types:
 * type UserId = Newtype<number, "UserId">;
 * type Email = Newtype<string, "Email">;
 * type Meters = Newtype<number, "Meters">;
 * type Seconds = Newtype<number, "Seconds">;
 *
 * // Source (what you write):
 * const id = wrap<UserId>(42);
 * const raw = unwrap(id);
 * const email = wrap<Email>("user@example.com");
 *
 * // Compiled output (what runs):
 * const id = 42;
 * const raw = id;
 * const email = "user@example.com";
 *
 * // Type errors at compile time:
 * function getUser(id: UserId): User { ... }
 * getUser(42);                    // Error: number is not UserId
 * getUser(wrap<UserId>(42));      // OK — compiles to getUser(42)
 *
 * // Prevent mixing up similar types:
 * function move(distance: Meters, duration: Seconds): void { ... }
 * const d = wrap<Meters>(100);
 * const t = wrap<Seconds>(10);
 * move(d, t);  // OK
 * move(t, d);  // Error: Seconds is not Meters
 * ```
 */
/** Brand symbol for newtype discrimination */
declare const __brand: unique symbol;
/**
 * A branded type that wraps Base with a phantom Brand tag.
 * At runtime this is just Base — the brand exists only in the type system.
 */
type Newtype<Base, Brand extends string> = Base & {
    readonly [__brand]: Brand;
};
/**
 * Extract the base type from a Newtype.
 */
type UnwrapNewtype<T> = T extends Newtype<infer Base, string> ? Base : T;
/**
 * Wrap a value in a Newtype. Compiles away to nothing.
 *
 * @example
 * const userId = wrap<UserId>(42); // Compiles to: const userId = 42;
 */
declare function wrap<T>(value: UnwrapNewtype<T>): T;
/**
 * Unwrap a Newtype to its base value. Compiles away to nothing.
 *
 * @example
 * const raw = unwrap(userId); // Compiles to: const raw = userId;
 */
declare function unwrap<T>(value: T): UnwrapNewtype<T>;
/**
 * Create a constructor function for a Newtype.
 * The constructor itself compiles away — it's just the identity function.
 *
 * @example
 * const UserId = newtypeCtor<UserId>();
 * const id = UserId(42); // Compiles to: const id = 42;
 */
declare function newtypeCtor<T>(): (value: UnwrapNewtype<T>) => T;
/**
 * Create a validated constructor for a Newtype.
 * The validation runs at runtime, but the wrapping is zero-cost.
 *
 * @example
 * const Email = validatedNewtype<Email>((s: string) => s.includes("@"));
 * const email = Email("user@example.com"); // Validates then returns the string
 */
declare function validatedNewtype<T>(validate: (value: UnwrapNewtype<T>) => boolean, errorMessage?: string): (value: UnwrapNewtype<T>) => T;
declare const wrapMacro: _typemacro_core.ExpressionMacro;
declare const unwrapMacro: _typemacro_core.ExpressionMacro;
declare const newtypeCtorMacro: _typemacro_core.ExpressionMacro;

/**
 * Zero-Cost pipe/flow - Inlined function composition
 *
 * pipe() and flow() provide point-free function composition that compiles
 * to direct nested calls — no intermediate arrays, no reduce, no closures.
 *
 * Inspired by fp-ts pipe, Ramda, and F# |> operator.
 *
 * @example
 * ```typescript
 * // Source (what you write):
 * const result = pipe(
 *   rawInput,
 *   trim,
 *   toLowerCase,
 *   x => x.split(","),
 *   xs => xs.filter(Boolean),
 * );
 *
 * // Compiled output (what runs):
 * const result = ((x) => x.filter(Boolean))(
 *   ((x) => x.split(","))(
 *     toLowerCase(
 *       trim(rawInput)
 *     )
 *   )
 * );
 *
 * // With simple named functions, even simpler:
 * const result = pipe(users, filterActive, sortByName, take(10));
 * // Compiles to:
 * const result = take(10)(sortByName(filterActive(users)));
 * ```
 *
 * @example
 * ```typescript
 * // flow() creates a reusable pipeline (compiles to a single composed function):
 * const processUser = flow(
 *   validateEmail,
 *   normalizeCase,
 *   addTimestamp,
 * );
 *
 * // Compiled output:
 * const processUser = (__x) => addTimestamp(normalizeCase(validateEmail(__x)));
 * ```
 */
/** pipe: Apply a value through a chain of functions left-to-right */
declare function pipe<A>(value: A): A;
declare function pipe<A, B>(value: A, f1: (a: A) => B): B;
declare function pipe<A, B, C>(value: A, f1: (a: A) => B, f2: (b: B) => C): C;
declare function pipe<A, B, C, D>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D): D;
declare function pipe<A, B, C, D, E>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E): E;
declare function pipe<A, B, C, D, E, F>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F): F;
declare function pipe<A, B, C, D, E, F, G>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G): G;
declare function pipe<A, B, C, D, E, F, G, H>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H): H;
declare function pipe<A, B, C, D, E, F, G, H, I>(value: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H, f8: (h: H) => I): I;
/** flow: Compose functions left-to-right into a single function */
declare function flow<A, B>(f1: (a: A) => B): (a: A) => B;
declare function flow<A, B, C>(f1: (a: A) => B, f2: (b: B) => C): (a: A) => C;
declare function flow<A, B, C, D>(f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D): (a: A) => D;
declare function flow<A, B, C, D, E>(f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E): (a: A) => E;
declare function flow<A, B, C, D, E, F>(f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F): (a: A) => F;
declare function flow<A, B, C, D, E, F, G>(f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G): (a: A) => G;
declare const pipeMacro: _typemacro_core.ExpressionMacro;
declare const flowMacro: _typemacro_core.ExpressionMacro;

/**
 * Zero-Cost Compile-Time Assertions and Invariants
 *
 * Provides compile-time checks that either:
 * 1. Disappear completely in production (staticAssert, typeAssert)
 * 2. Compile to minimal runtime checks (invariant, unreachable)
 *
 * Inspired by Rust's compile_error!, static_assert, unreachable!, and C++'s static_assert.
 *
 * @example
 * ```typescript
 * // staticAssert — evaluates condition at compile time, emits nothing
 * staticAssert(sizeof<User>() <= 1024, "User struct too large");
 * // Compiled output: (nothing — completely erased)
 *
 * // typeAssert — compile-time type relationship check
 * typeAssert<Extends<Dog, Animal>>();
 * typeAssert<Equals<Option<number>, number | null>>();
 * // Compiled output: (nothing)
 *
 * // invariant — kept in dev, stripped in prod
 * invariant(users.length > 0, "Expected at least one user");
 * // Dev output:  if (!(users.length > 0)) throw new Error("Expected at least one user");
 * // Prod output: (nothing)
 *
 * // unreachable — marks code paths that should never execute
 * switch (shape.kind) {
 *   case "circle": return circleArea(shape);
 *   case "square": return squareArea(shape);
 *   default: unreachable(shape); // Compile error if shape isn't exhausted
 * }
 * // Compiled output: throw new Error("Unreachable")
 *
 * // debugOnly — wraps code that should only run in development
 * debugOnly(() => {
 *   console.log("Debug info:", state);
 *   validateInternalState(state);
 * });
 * // Dev output:  (() => { console.log(...); validateInternalState(state); })()
 * // Prod output: (nothing)
 * ```
 */
/** Compile-time type equality check */
type Equals<A, B> = [A] extends [B] ? [B] extends [A] ? true : false : false;
/** Compile-time subtype check */
type Extends<A, B> = A extends B ? true : false;
/** Compile-time "not" */
type Not<T extends boolean> = T extends true ? false : true;
/** Compile-time "and" */
type And<A extends boolean, B extends boolean> = A extends true ? B extends true ? true : false : false;
/** Compile-time "or" */
type Or<A extends boolean, B extends boolean> = A extends true ? true : B extends true ? true : false;
/**
 * Assert a condition at compile time. Completely erased from output.
 * If the condition is false, emits a compile error.
 */
declare function staticAssert(_condition: true, _message?: string): void;
/**
 * Assert a type-level predicate. Completely erased from output.
 * Usage: typeAssert<Equals<A, B>>()
 */
declare function typeAssert<_T extends true>(): void;
/**
 * Runtime invariant check. Stripped in production builds.
 */
declare function invariant(condition: boolean, message?: string): asserts condition;
/**
 * Mark a code path as unreachable. Useful for exhaustiveness checking.
 * At runtime, throws if somehow reached.
 */
declare function unreachable(_value?: never): never;
/**
 * Code that only runs in development. Completely erased in production.
 */
declare function debugOnly(fn: () => void): void;
/**
 * Compile-time sizeof — returns the number of properties on a type.
 * Useful for compile-time assertions about type size.
 */
declare function sizeof<_T>(): number;
declare const staticAssertMacro: _typemacro_core.ExpressionMacro;
declare const typeAssertMacro: _typemacro_core.ExpressionMacro;
declare const invariantMacro: _typemacro_core.ExpressionMacro;
declare const unreachableMacro: _typemacro_core.ExpressionMacro;
declare const debugOnlyMacro: _typemacro_core.ExpressionMacro;
declare const sizeofMacro: _typemacro_core.ExpressionMacro;

/**
 * Zero-Cost Exhaustive Pattern Matching
 *
 * Compiles match expressions into optimized if/else chains or switch
 * statements — no closures, no arrays of patterns, no runtime matching engine.
 *
 * Supports:
 * - Discriminated unions (tagged unions)
 * - Literal matching (string, number, boolean)
 * - Predicate guards
 * - Wildcard/default cases
 * - Nested destructuring
 *
 * Inspired by Rust's match, Scala's pattern matching, and ts-pattern.
 *
 * @example
 * ```typescript
 * // Source (what you write):
 * type Shape =
 *   | { kind: "circle"; radius: number }
 *   | { kind: "rect"; width: number; height: number }
 *   | { kind: "triangle"; base: number; height: number };
 *
 * const area = match(shape, {
 *   circle: (s) => Math.PI * s.radius ** 2,
 *   rect: (s) => s.width * s.height,
 *   triangle: (s) => 0.5 * s.base * s.height,
 * });
 *
 * // Compiled output (what runs):
 * const area =
 *   shape.kind === "circle" ? ((s) => Math.PI * s.radius ** 2)(shape)
 *   : shape.kind === "rect" ? ((s) => s.width * s.height)(shape)
 *   : ((s) => 0.5 * s.base * s.height)(shape);
 * ```
 *
 * @example
 * ```typescript
 * // matchLiteral for simple value matching:
 * const label = matchLiteral(statusCode, {
 *   200: () => "OK",
 *   404: () => "Not Found",
 *   500: () => "Server Error",
 *   _: () => "Unknown",
 * });
 *
 * // Compiled output:
 * const label =
 *   statusCode === 200 ? "OK"
 *   : statusCode === 404 ? "Not Found"
 *   : statusCode === 500 ? "Server Error"
 *   : "Unknown";
 * ```
 *
 * @example
 * ```typescript
 * // matchGuard for predicate-based matching:
 * const category = matchGuard(score, [
 *   [s => s >= 90, () => "A"],
 *   [s => s >= 80, () => "B"],
 *   [s => s >= 70, () => "C"],
 *   [() => true,   () => "F"],
 * ]);
 *
 * // Compiled output:
 * const category =
 *   score >= 90 ? "A"
 *   : score >= 80 ? "B"
 *   : score >= 70 ? "C"
 *   : "F";
 * ```
 */
/** Extract the discriminant values from a union type */
type DiscriminantOf<T, K extends keyof T> = T extends Record<K, infer V> ? (V extends string ? V : never) : never;
/** Handler map for discriminated union matching */
type MatchHandlers<T, K extends keyof T, R> = {
    [V in DiscriminantOf<T, K>]: (value: Extract<T, Record<K, V>>) => R;
};
/** Handler map for literal matching (with optional wildcard) */
type LiteralHandlers<T extends string | number, R> = {
    [K in T]?: () => R;
} & {
    _?: () => R;
};
/** Guard-based match arm */
type GuardArm<T, R> = [(value: T) => boolean, (value: T) => R];
/**
 * Match on a discriminated union. Exhaustive by default.
 *
 * @param value - The value to match on
 * @param handlers - Object mapping discriminant values to handler functions
 * @param discriminant - The discriminant key (default: "kind")
 */
declare function match<T extends Record<string, unknown>, K extends keyof T, R>(value: T, handlers: MatchHandlers<T, K, R>, discriminant?: K): R;
/**
 * Match on literal values (strings, numbers).
 * Use _ for the default/wildcard case.
 */
declare function matchLiteral<T extends string | number, R>(value: T, handlers: LiteralHandlers<T, R>): R;
/**
 * Match with predicate guards. First matching guard wins.
 */
declare function matchGuard<T, R>(value: T, arms: GuardArm<T, R>[]): R;
declare const matchMacro: _typemacro_core.ExpressionMacro;
declare const matchLiteralMacro: _typemacro_core.ExpressionMacro;
declare const matchGuardMacro: _typemacro_core.ExpressionMacro;

export { type And, type Equals, type Err, type Extends, type Newtype, type Not, type Ok, Option, Option as OptionType, type Or, Result, Result as ResultType, type UnwrapNewtype, debugOnly, debugOnlyMacro, flow, flowMacro, invariant, invariantMacro, match, matchGuard, matchGuardMacro, matchLiteral, matchLiteralMacro, matchMacro, newtypeCtor, newtypeCtorMacro, optionMacro, pipe, pipeMacro, resultMacro, sizeof, sizeofMacro, staticAssert, staticAssertMacro, typeAssert, typeAssertMacro, unreachable, unreachableMacro, unwrap, unwrapMacro, validatedNewtype, wrap, wrapMacro };
