{"version":3,"sources":["../src/index.ts","../src/option.ts","../src/result.ts","../src/newtype.ts","../src/pipe.ts","../src/assert.ts","../src/match.ts"],"sourcesContent":["/**\n * Zero-Cost Abstractions for typemacro\n *\n * A collection of compile-time macros that provide rich, type-safe APIs\n * that compile away to minimal or zero runtime overhead.\n *\n * ## Abstractions\n *\n * ### Option<T> — Nullable values with monadic API\n * Rich method chains (map, flatMap, filter, match, zip, unwrapOr...)\n * that compile to inlined null checks. No wrapper objects.\n *\n * ### Result<T, E> — Error handling without exceptions\n * Ok/Err discriminated union with method chains (map, mapErr, flatMap,\n * match, unwrapOr...) that compile to inlined .ok property checks.\n *\n * ### Newtype<Base, Brand> — Branded primitives\n * Type-safe wrappers (UserId, Email, Meters...) where wrap/unwrap\n * compile away completely. Zero runtime cost, full type safety.\n *\n * ### pipe() / flow() — Function composition\n * pipe(x, f, g, h) compiles to h(g(f(x))). No arrays, no reduce.\n * flow(f, g, h) compiles to (x) => h(g(f(x))).\n *\n * ### Assertions — Compile-time and runtime checks\n * staticAssert() and typeAssert() erase completely.\n * invariant() compiles to a conditional throw.\n * unreachable() marks impossible code paths.\n * debugOnly() wraps dev-only code that can be stripped.\n * sizeof<T>() returns property count as a literal.\n *\n * ### Pattern Matching — Exhaustive match expressions\n * match() for discriminated unions compiles to if/else chains.\n * matchLiteral() for string/number matching.\n * matchGuard() for predicate-based matching.\n *\n * @example\n * ```typescript\n * import {\n *   Option, Result, pipe, flow, match,\n *   wrap, unwrap, invariant, unreachable,\n *   type Newtype, type Equals,\n * } from \"typemacro/zero-cost\";\n *\n * // Compose zero-cost abstractions:\n * type UserId = Newtype<number, \"UserId\">;\n *\n * const result = pipe(\n *   getUserById(wrap<UserId>(42)),          // Result<User, Error>\n *   r => Result.map(r, u => u.email),       // Result<string, Error>\n *   r => Result.unwrapOr(r, \"unknown\"),     // string\n * );\n * ```\n */\n\n// Option type and macro\nexport { Option, optionMacro, type Option as OptionType } from \"./option.js\";\n\n// Result type and macro\nexport {\n  Result,\n  resultMacro,\n  type Ok,\n  type Err,\n  type Result as ResultType,\n} from \"./result.js\";\n\n// Newtype pattern\nexport {\n  wrap,\n  unwrap,\n  newtypeCtor,\n  validatedNewtype,\n  wrapMacro,\n  unwrapMacro,\n  newtypeCtorMacro,\n  type Newtype,\n  type UnwrapNewtype,\n} from \"./newtype.js\";\n\n// Pipe and flow\nexport { pipe, flow, pipeMacro, flowMacro } from \"./pipe.js\";\n\n// Assertions\nexport {\n  staticAssert,\n  typeAssert,\n  invariant,\n  unreachable,\n  debugOnly,\n  sizeof,\n  staticAssertMacro,\n  typeAssertMacro,\n  invariantMacro,\n  unreachableMacro,\n  debugOnlyMacro,\n  sizeofMacro,\n  type Equals,\n  type Extends,\n  type Not,\n  type And,\n  type Or,\n} from \"./assert.js\";\n\n// Pattern matching\nexport {\n  match,\n  matchLiteral,\n  matchGuard,\n  matchMacro,\n  matchLiteralMacro,\n  matchGuardMacro,\n} from \"./match.js\";\n","/**\n * Zero-Cost Option<T> - Compiles to null/undefined checks\n *\n * At the type level, Option<T> provides a rich monadic API (map, flatMap,\n * unwrapOr, match, etc.). The macro transforms all method chains into\n * inlined null checks — no wrapper objects, no allocations, no vtable dispatch.\n *\n * @example\n * ```typescript\n * // Source (what you write):\n * const name = Option.from(user.name)\n *   .map(n => n.trim())\n *   .filter(n => n.length > 0)\n *   .unwrapOr(\"Anonymous\");\n *\n * // Compiled output (what runs):\n * const __opt_0 = user.name;\n * const __opt_1 = __opt_0 != null ? __opt_0.trim() : null;\n * const __opt_2 = __opt_1 != null ? (__opt_1.length > 0 ? __opt_1 : null) : null;\n * const name = __opt_2 != null ? __opt_2 : \"Anonymous\";\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API (for IDE support — these types guide the user)\n// ============================================================================\n\n/** Represents an optional value — either Some(T) or None */\nexport type Option<T> = T | null;\n\n/** Option namespace with constructors and utilities */\nexport const Option = {\n  /** Wrap a nullable value into an Option */\n  from<T>(value: T | null | undefined): Option<T> {\n    return value ?? null;\n  },\n\n  /** Create a Some value */\n  some<T>(value: T): Option<T> {\n    return value;\n  },\n\n  /** The None value */\n  none: null as Option<never>,\n\n  /** Check if an Option is Some */\n  isSome<T>(opt: Option<T>): opt is T {\n    return opt != null;\n  },\n\n  /** Check if an Option is None */\n  isNone<T>(opt: Option<T>): opt is null {\n    return opt == null;\n  },\n} as const;\n\n// ============================================================================\n// Chain Step Types (internal representation during macro expansion)\n// ============================================================================\n\ninterface ChainStep {\n  kind:\n    | \"from\"\n    | \"map\"\n    | \"flatMap\"\n    | \"filter\"\n    | \"unwrapOr\"\n    | \"unwrap\"\n    | \"match\"\n    | \"zip\"\n    | \"and\"\n    | \"or\"\n    | \"tap\";\n  args: readonly ts.Expression[];\n}\n\n// ============================================================================\n// Option Macro - Inlines Option chains into null checks\n// ============================================================================\n\n/**\n * Parse a method chain on Option and extract steps.\n * Walks the chain from outermost call inward.\n */\nfunction parseOptionChain(\n  node: ts.Expression,\n): { root: ts.Expression; steps: ChainStep[] } | null {\n  const steps: ChainStep[] = [];\n  let current = node;\n\n  while (ts.isCallExpression(current)) {\n    const expr = current.expression;\n\n    if (!ts.isPropertyAccessExpression(expr)) {\n      break;\n    }\n\n    const methodName = expr.name.text;\n    const validMethods = [\n      \"map\",\n      \"flatMap\",\n      \"filter\",\n      \"unwrapOr\",\n      \"unwrap\",\n      \"match\",\n      \"zip\",\n      \"and\",\n      \"or\",\n      \"tap\",\n    ];\n\n    if (!validMethods.includes(methodName)) {\n      break;\n    }\n\n    steps.unshift({\n      kind: methodName as ChainStep[\"kind\"],\n      args: current.arguments,\n    });\n\n    current = expr.expression;\n  }\n\n  // Check if the root is Option.from(...) or Option.some(...)\n  if (ts.isCallExpression(current)) {\n    const expr = current.expression;\n    if (\n      ts.isPropertyAccessExpression(expr) &&\n      ts.isIdentifier(expr.expression) &&\n      expr.expression.text === \"Option\"\n    ) {\n      const method = expr.name.text;\n      if (method === \"from\" || method === \"some\") {\n        steps.unshift({\n          kind: \"from\",\n          args: current.arguments,\n        });\n        return { root: current, steps };\n      }\n    }\n  }\n\n  if (steps.length === 0) {\n    return null;\n  }\n\n  return { root: current, steps };\n}\n\n/**\n * Generate inlined null-check code for an Option chain.\n */\nfunction expandOptionChain(\n  ctx: MacroContext,\n  chain: { root: ts.Expression; steps: ChainStep[] },\n): ts.Expression {\n  const factory = ctx.factory;\n  let counter = 0;\n\n  function tempName(): ts.Identifier {\n    return ctx.generateUniqueName(`__opt_${counter++}`);\n  }\n\n  function nullCheck(\n    value: ts.Expression,\n    thenExpr: ts.Expression,\n    elseExpr?: ts.Expression,\n  ): ts.Expression {\n    return factory.createConditionalExpression(\n      factory.createBinaryExpression(\n        value,\n        factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),\n        factory.createNull(),\n      ),\n      factory.createToken(ts.SyntaxKind.QuestionToken),\n      thenExpr,\n      factory.createToken(ts.SyntaxKind.ColonToken),\n      elseExpr ?? factory.createNull(),\n    );\n  }\n\n  let currentExpr: ts.Expression | null = null;\n\n  for (const step of chain.steps) {\n    switch (step.kind) {\n      case \"from\": {\n        // Option.from(x) => x ?? null (coerce undefined to null)\n        const arg = step.args[0];\n        currentExpr = factory.createBinaryExpression(\n          arg,\n          factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n          factory.createNull(),\n        );\n        break;\n      }\n\n      case \"map\": {\n        // .map(f) => x != null ? f(x) : null\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        if (ts.isArrowFunction(fn) || ts.isFunctionExpression(fn)) {\n          // Inline the function body: replace parameter with prev value\n          const param = fn.parameters[0];\n          if (param && ts.isIdentifier(param.name)) {\n            const body =\n              ts.isArrowFunction(fn) && !ts.isBlock(fn.body) ? fn.body : null;\n            if (body) {\n              // Simple arrow: (x) => expr  =>  expr[x := prev]\n              currentExpr = nullCheck(prev, inlineArrowBody(factory, fn, prev));\n            } else {\n              // Complex body — call the function\n              currentExpr = nullCheck(\n                prev,\n                factory.createCallExpression(fn, undefined, [prev]),\n              );\n            }\n          } else {\n            currentExpr = nullCheck(\n              prev,\n              factory.createCallExpression(fn, undefined, [prev]),\n            );\n          }\n        } else {\n          // Named function reference\n          currentExpr = nullCheck(\n            prev,\n            factory.createCallExpression(fn, undefined, [prev]),\n          );\n        }\n        break;\n      }\n\n      case \"flatMap\": {\n        // .flatMap(f) => x != null ? f(x) : null\n        // (f already returns Option<U>, i.e. U | null)\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        if (ts.isArrowFunction(fn) && !ts.isBlock(fn.body)) {\n          currentExpr = nullCheck(prev, inlineArrowBody(factory, fn, prev));\n        } else {\n          currentExpr = nullCheck(\n            prev,\n            factory.createCallExpression(fn, undefined, [prev]),\n          );\n        }\n        break;\n      }\n\n      case \"filter\": {\n        // .filter(pred) => x != null ? (pred(x) ? x : null) : null\n        const pred = step.args[0];\n        const prev = currentExpr!;\n        const predCall =\n          ts.isArrowFunction(pred) && !ts.isBlock(pred.body)\n            ? inlineArrowBody(factory, pred, prev)\n            : factory.createCallExpression(pred, undefined, [prev]);\n\n        currentExpr = nullCheck(\n          prev,\n          factory.createConditionalExpression(\n            predCall,\n            factory.createToken(ts.SyntaxKind.QuestionToken),\n            prev,\n            factory.createToken(ts.SyntaxKind.ColonToken),\n            factory.createNull(),\n          ),\n        );\n        break;\n      }\n\n      case \"unwrapOr\": {\n        // .unwrapOr(default) => x != null ? x : default\n        const defaultVal = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = nullCheck(prev, prev, defaultVal);\n        break;\n      }\n\n      case \"unwrap\": {\n        // .unwrap() => x != null ? x : throw\n        const prev = currentExpr!;\n        currentExpr = nullCheck(\n          prev,\n          prev,\n          factory.createCallExpression(\n            factory.createParenthesizedExpression(\n              factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                undefined,\n                factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n                factory.createBlock([\n                  factory.createThrowStatement(\n                    factory.createNewExpression(\n                      factory.createIdentifier(\"Error\"),\n                      undefined,\n                      [factory.createStringLiteral(\"Called unwrap() on None\")],\n                    ),\n                  ),\n                ]),\n              ),\n            ),\n            undefined,\n            [],\n          ),\n        );\n        break;\n      }\n\n      case \"match\": {\n        // .match({ some: f, none: g }) => x != null ? f(x) : g()\n        // Or .match(someHandler, noneHandler)\n        const prev = currentExpr!;\n        if (step.args.length === 2) {\n          const someFn = step.args[0];\n          const noneFn = step.args[1];\n          const someCall =\n            ts.isArrowFunction(someFn) && !ts.isBlock(someFn.body)\n              ? inlineArrowBody(factory, someFn, prev)\n              : factory.createCallExpression(someFn, undefined, [prev]);\n          const noneCall =\n            ts.isArrowFunction(noneFn) && !ts.isBlock(noneFn.body)\n              ? (noneFn.body as ts.Expression)\n              : factory.createCallExpression(noneFn, undefined, []);\n          currentExpr = nullCheck(prev, someCall, noneCall);\n        } else if (\n          step.args.length === 1 &&\n          ts.isObjectLiteralExpression(step.args[0])\n        ) {\n          const obj = step.args[0];\n          let someFn: ts.Expression | undefined;\n          let noneFn: ts.Expression | undefined;\n          for (const prop of obj.properties) {\n            if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {\n              if (prop.name.text === \"some\") someFn = prop.initializer;\n              if (prop.name.text === \"none\") noneFn = prop.initializer;\n            }\n          }\n          if (someFn && noneFn) {\n            const someCall =\n              ts.isArrowFunction(someFn) && !ts.isBlock(someFn.body)\n                ? inlineArrowBody(factory, someFn, prev)\n                : factory.createCallExpression(someFn, undefined, [prev]);\n            const noneCall =\n              ts.isArrowFunction(noneFn) && !ts.isBlock(noneFn.body)\n                ? (noneFn.body as ts.Expression)\n                : factory.createCallExpression(noneFn, undefined, []);\n            currentExpr = nullCheck(prev, someCall, noneCall);\n          }\n        }\n        break;\n      }\n\n      case \"zip\": {\n        // .zip(other) => x != null && other != null ? [x, other] : null\n        const other = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = factory.createConditionalExpression(\n          factory.createBinaryExpression(\n            factory.createBinaryExpression(\n              prev,\n              factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),\n              factory.createNull(),\n            ),\n            factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),\n            factory.createBinaryExpression(\n              other,\n              factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),\n              factory.createNull(),\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.QuestionToken),\n          factory.createArrayLiteralExpression([prev, other]),\n          factory.createToken(ts.SyntaxKind.ColonToken),\n          factory.createNull(),\n        );\n        break;\n      }\n\n      case \"and\": {\n        // .and(other) => x != null ? other : null\n        const other = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = nullCheck(prev, other);\n        break;\n      }\n\n      case \"or\": {\n        // .or(other) => x != null ? x : other\n        const other = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = nullCheck(prev, prev, other);\n        break;\n      }\n\n      case \"tap\": {\n        // .tap(f) => (f(x), x)  — side effect, returns same value\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = nullCheck(\n          prev,\n          factory.createParenthesizedExpression(\n            factory.createCommaListExpression([\n              factory.createCallExpression(fn, undefined, [prev]),\n              prev,\n            ]),\n          ),\n        );\n        break;\n      }\n    }\n  }\n\n  return currentExpr ?? factory.createNull();\n}\n\n/**\n * Inline a simple arrow function body by substituting the parameter.\n * For (x) => x.trim(), with arg `prev`, produces `prev.trim()`.\n */\nfunction inlineArrowBody(\n  factory: ts.NodeFactory,\n  fn: ts.ArrowFunction | ts.FunctionExpression,\n  arg: ts.Expression,\n): ts.Expression {\n  if (!ts.isArrowFunction(fn) || ts.isBlock(fn.body)) {\n    return factory.createCallExpression(fn, undefined, [arg]);\n  }\n\n  // For now, just call the function — full inlining requires\n  // AST substitution which is a separate optimization pass\n  return factory.createCallExpression(fn, undefined, [arg]);\n}\n\n// ============================================================================\n// Register the Option macro\n// ============================================================================\n\nexport const optionMacro = defineExpressionMacro({\n  name: \"Option\",\n  description:\n    \"Zero-cost Option type — compiles method chains to inlined null checks\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    // Try to parse as an Option chain\n    const chain = parseOptionChain(callExpr);\n    if (chain) {\n      return expandOptionChain(ctx, chain);\n    }\n\n    // If not a chain, check for Option.from / Option.some\n    const expr = callExpr.expression;\n    if (\n      ts.isPropertyAccessExpression(expr) &&\n      ts.isIdentifier(expr.expression) &&\n      expr.expression.text === \"Option\"\n    ) {\n      const method = expr.name.text;\n\n      if (method === \"from\" && args.length === 1) {\n        // Option.from(x) => x ?? null\n        return ctx.factory.createBinaryExpression(\n          args[0],\n          ctx.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n          ctx.factory.createNull(),\n        );\n      }\n\n      if (method === \"some\" && args.length === 1) {\n        // Option.some(x) => x\n        return args[0];\n      }\n\n      if (method === \"isSome\" && args.length === 1) {\n        // Option.isSome(x) => x != null\n        return ctx.factory.createBinaryExpression(\n          args[0],\n          ctx.factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),\n          ctx.factory.createNull(),\n        );\n      }\n\n      if (method === \"isNone\" && args.length === 1) {\n        // Option.isNone(x) => x == null\n        return ctx.factory.createBinaryExpression(\n          args[0],\n          ctx.factory.createToken(ts.SyntaxKind.EqualsEqualsToken),\n          ctx.factory.createNull(),\n        );\n      }\n    }\n\n    return callExpr;\n  },\n});\n\nglobalRegistry.register(optionMacro);\n","/**\n * Zero-Cost Result<T, E> - Compiles to discriminated union checks\n *\n * Result<T, E> represents either success (Ok<T>) or failure (Err<E>).\n * The macro inlines all method chains into direct property access and\n * conditional checks — no wrapper classes, no allocations.\n *\n * The runtime representation is a plain object: { ok: true, value: T } | { ok: false, error: E }\n * The macro compiles away all method calls into direct field access.\n *\n * @example\n * ```typescript\n * // Source (what you write):\n * const parsed = Result.try(() => JSON.parse(input))\n *   .map(data => data.name)\n *   .mapErr(e => `Parse failed: ${e.message}`)\n *   .unwrapOr(\"unknown\");\n *\n * // Compiled output (what runs):\n * let __res_0;\n * try { __res_0 = { ok: true, value: JSON.parse(input) }; }\n * catch (__e) { __res_0 = { ok: false, error: __e }; }\n * const __res_1 = __res_0.ok ? { ok: true, value: __res_0.value.name } : __res_0;\n * const __res_2 = __res_1.ok ? __res_1 : { ok: false, error: `Parse failed: ${__res_1.error.message}` };\n * const parsed = __res_2.ok ? __res_2.value : \"unknown\";\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry } from \"@typemacro/core\";\nimport { MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API\n// ============================================================================\n\n/** A successful result */\nexport interface Ok<T> {\n  readonly ok: true;\n  readonly value: T;\n}\n\n/** A failed result */\nexport interface Err<E> {\n  readonly ok: false;\n  readonly error: E;\n}\n\n/** Discriminated union of Ok and Err */\nexport type Result<T, E> = Ok<T> | Err<E>;\n\n/** Result namespace with constructors */\nexport const Result = {\n  /** Create a successful result */\n  ok<T>(value: T): Result<T, never> {\n    return { ok: true, value };\n  },\n\n  /** Create a failed result */\n  err<E>(error: E): Result<never, E> {\n    return { ok: false, error };\n  },\n\n  /** Wrap a throwing function into a Result */\n  try<T>(fn: () => T): Result<T, Error> {\n    try {\n      return { ok: true, value: fn() };\n    } catch (e) {\n      return {\n        ok: false,\n        error: e instanceof Error ? e : new Error(String(e)),\n      };\n    }\n  },\n\n  /** Wrap a Promise into a Result */\n  async fromPromise<T>(promise: Promise<T>): Promise<Result<T, Error>> {\n    try {\n      return { ok: true, value: await promise };\n    } catch (e) {\n      return {\n        ok: false,\n        error: e instanceof Error ? e : new Error(String(e)),\n      };\n    }\n  },\n\n  /** Check if a Result is Ok */\n  isOk<T, E>(result: Result<T, E>): result is Ok<T> {\n    return result.ok;\n  },\n\n  /** Check if a Result is Err */\n  isErr<T, E>(result: Result<T, E>): result is Err<E> {\n    return !result.ok;\n  },\n\n  /** Collect an array of Results into a Result of array */\n  all<T, E>(results: Result<T, E>[]): Result<T[], E> {\n    const values: T[] = [];\n    for (const r of results) {\n      if (!r.ok) return r;\n      values.push(r.value);\n    }\n    return { ok: true, value: values };\n  },\n} as const;\n\n// ============================================================================\n// Chain Step Types\n// ============================================================================\n\ninterface ResultChainStep {\n  kind:\n    | \"ok\"\n    | \"err\"\n    | \"try\"\n    | \"map\"\n    | \"mapErr\"\n    | \"flatMap\"\n    | \"unwrapOr\"\n    | \"unwrap\"\n    | \"unwrapErr\"\n    | \"match\"\n    | \"and\"\n    | \"or\"\n    | \"tap\"\n    | \"tapErr\"\n    | \"isOk\"\n    | \"isErr\";\n  args: readonly ts.Expression[];\n}\n\n// ============================================================================\n// Result Macro\n// ============================================================================\n\nfunction parseResultChain(\n  node: ts.Expression,\n): { root: ts.Expression; steps: ResultChainStep[] } | null {\n  const steps: ResultChainStep[] = [];\n  let current = node;\n\n  const validMethods = [\n    \"map\",\n    \"mapErr\",\n    \"flatMap\",\n    \"unwrapOr\",\n    \"unwrap\",\n    \"unwrapErr\",\n    \"match\",\n    \"and\",\n    \"or\",\n    \"tap\",\n    \"tapErr\",\n    \"isOk\",\n    \"isErr\",\n  ];\n\n  while (ts.isCallExpression(current)) {\n    const expr = current.expression;\n    if (!ts.isPropertyAccessExpression(expr)) break;\n\n    const methodName = expr.name.text;\n    if (!validMethods.includes(methodName)) break;\n\n    steps.unshift({\n      kind: methodName as ResultChainStep[\"kind\"],\n      args: current.arguments,\n    });\n    current = expr.expression;\n  }\n\n  // Check for Result.ok(...), Result.err(...), Result.try(...)\n  if (ts.isCallExpression(current)) {\n    const expr = current.expression;\n    if (\n      ts.isPropertyAccessExpression(expr) &&\n      ts.isIdentifier(expr.expression) &&\n      expr.expression.text === \"Result\"\n    ) {\n      const method = expr.name.text;\n      if (method === \"ok\" || method === \"err\" || method === \"try\") {\n        steps.unshift({\n          kind: method as ResultChainStep[\"kind\"],\n          args: current.arguments,\n        });\n        return { root: current, steps };\n      }\n    }\n  }\n\n  if (steps.length === 0) return null;\n  return { root: current, steps };\n}\n\nfunction expandResultChain(\n  ctx: MacroContext,\n  chain: { root: ts.Expression; steps: ResultChainStep[] },\n): ts.Expression {\n  const factory = ctx.factory;\n\n  function okObj(value: ts.Expression): ts.Expression {\n    return factory.createObjectLiteralExpression([\n      factory.createPropertyAssignment(\"ok\", factory.createTrue()),\n      factory.createPropertyAssignment(\"value\", value),\n    ]);\n  }\n\n  function errObj(error: ts.Expression): ts.Expression {\n    return factory.createObjectLiteralExpression([\n      factory.createPropertyAssignment(\"ok\", factory.createFalse()),\n      factory.createPropertyAssignment(\"error\", error),\n    ]);\n  }\n\n  function okCheck(\n    result: ts.Expression,\n    thenExpr: ts.Expression,\n    elseExpr: ts.Expression,\n  ): ts.Expression {\n    return factory.createConditionalExpression(\n      factory.createPropertyAccessExpression(result, \"ok\"),\n      factory.createToken(ts.SyntaxKind.QuestionToken),\n      thenExpr,\n      factory.createToken(ts.SyntaxKind.ColonToken),\n      elseExpr,\n    );\n  }\n\n  let currentExpr: ts.Expression | null = null;\n\n  for (const step of chain.steps) {\n    switch (step.kind) {\n      case \"ok\": {\n        // Result.ok(x) => { ok: true, value: x }\n        currentExpr = okObj(step.args[0]);\n        break;\n      }\n\n      case \"err\": {\n        // Result.err(e) => { ok: false, error: e }\n        currentExpr = errObj(step.args[0]);\n        break;\n      }\n\n      case \"try\": {\n        // Result.try(fn) => try { { ok: true, value: fn() } } catch(e) { { ok: false, error: e } }\n        const fn = step.args[0];\n        const tempErr = ctx.generateUniqueName(\"__e\");\n        // We emit an IIFE with try/catch\n        currentExpr = factory.createCallExpression(\n          factory.createParenthesizedExpression(\n            factory.createArrowFunction(\n              undefined,\n              undefined,\n              [],\n              undefined,\n              factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n              factory.createBlock([\n                factory.createTryStatement(\n                  factory.createBlock([\n                    factory.createReturnStatement(\n                      okObj(factory.createCallExpression(fn, undefined, [])),\n                    ),\n                  ]),\n                  factory.createCatchClause(\n                    factory.createVariableDeclaration(tempErr),\n                    factory.createBlock([\n                      factory.createReturnStatement(errObj(tempErr)),\n                    ]),\n                  ),\n                  undefined,\n                ),\n              ]),\n            ),\n          ),\n          undefined,\n          [],\n        );\n        break;\n      }\n\n      case \"map\": {\n        // .map(f) => r.ok ? { ok: true, value: f(r.value) } : r\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        const valueAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"value\",\n        );\n        const mapped = factory.createCallExpression(fn, undefined, [\n          valueAccess,\n        ]);\n        currentExpr = okCheck(prev, okObj(mapped), prev);\n        break;\n      }\n\n      case \"mapErr\": {\n        // .mapErr(f) => r.ok ? r : { ok: false, error: f(r.error) }\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        const errorAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"error\",\n        );\n        const mapped = factory.createCallExpression(fn, undefined, [\n          errorAccess,\n        ]);\n        currentExpr = okCheck(prev, prev, errObj(mapped));\n        break;\n      }\n\n      case \"flatMap\": {\n        // .flatMap(f) => r.ok ? f(r.value) : r\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        const valueAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"value\",\n        );\n        const chained = factory.createCallExpression(fn, undefined, [\n          valueAccess,\n        ]);\n        currentExpr = okCheck(prev, chained, prev);\n        break;\n      }\n\n      case \"unwrapOr\": {\n        // .unwrapOr(default) => r.ok ? r.value : default\n        const defaultVal = step.args[0];\n        const prev = currentExpr!;\n        const valueAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"value\",\n        );\n        currentExpr = okCheck(prev, valueAccess, defaultVal);\n        break;\n      }\n\n      case \"unwrap\": {\n        // .unwrap() => r.ok ? r.value : throw r.error\n        const prev = currentExpr!;\n        const valueAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"value\",\n        );\n        currentExpr = okCheck(\n          prev,\n          valueAccess,\n          factory.createCallExpression(\n            factory.createParenthesizedExpression(\n              factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                undefined,\n                factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n                factory.createBlock([\n                  factory.createThrowStatement(\n                    factory.createPropertyAccessExpression(prev, \"error\"),\n                  ),\n                ]),\n              ),\n            ),\n            undefined,\n            [],\n          ),\n        );\n        break;\n      }\n\n      case \"unwrapErr\": {\n        // .unwrapErr() => r.ok ? throw \"Expected Err\" : r.error\n        const prev = currentExpr!;\n        const errorAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"error\",\n        );\n        currentExpr = okCheck(\n          prev,\n          factory.createCallExpression(\n            factory.createParenthesizedExpression(\n              factory.createArrowFunction(\n                undefined,\n                undefined,\n                [],\n                undefined,\n                factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n                factory.createBlock([\n                  factory.createThrowStatement(\n                    factory.createNewExpression(\n                      factory.createIdentifier(\"Error\"),\n                      undefined,\n                      [factory.createStringLiteral(\"Called unwrapErr() on Ok\")],\n                    ),\n                  ),\n                ]),\n              ),\n            ),\n            undefined,\n            [],\n          ),\n          errorAccess,\n        );\n        break;\n      }\n\n      case \"match\": {\n        // .match({ ok: f, err: g }) or .match(okFn, errFn)\n        const prev = currentExpr!;\n        if (step.args.length === 2) {\n          const okFn = step.args[0];\n          const errFn = step.args[1];\n          const valueAccess = factory.createPropertyAccessExpression(\n            prev,\n            \"value\",\n          );\n          const errorAccess = factory.createPropertyAccessExpression(\n            prev,\n            \"error\",\n          );\n          currentExpr = okCheck(\n            prev,\n            factory.createCallExpression(okFn, undefined, [valueAccess]),\n            factory.createCallExpression(errFn, undefined, [errorAccess]),\n          );\n        } else if (\n          step.args.length === 1 &&\n          ts.isObjectLiteralExpression(step.args[0])\n        ) {\n          const obj = step.args[0];\n          let okFn: ts.Expression | undefined;\n          let errFn: ts.Expression | undefined;\n          for (const prop of obj.properties) {\n            if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {\n              if (prop.name.text === \"ok\") okFn = prop.initializer;\n              if (prop.name.text === \"err\") errFn = prop.initializer;\n            }\n          }\n          if (okFn && errFn) {\n            const valueAccess = factory.createPropertyAccessExpression(\n              prev,\n              \"value\",\n            );\n            const errorAccess = factory.createPropertyAccessExpression(\n              prev,\n              \"error\",\n            );\n            currentExpr = okCheck(\n              prev,\n              factory.createCallExpression(okFn, undefined, [valueAccess]),\n              factory.createCallExpression(errFn, undefined, [errorAccess]),\n            );\n          }\n        }\n        break;\n      }\n\n      case \"and\": {\n        // .and(other) => r.ok ? other : r\n        const other = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = okCheck(prev, other, prev);\n        break;\n      }\n\n      case \"or\": {\n        // .or(other) => r.ok ? r : other\n        const other = step.args[0];\n        const prev = currentExpr!;\n        currentExpr = okCheck(prev, prev, other);\n        break;\n      }\n\n      case \"tap\": {\n        // .tap(f) => (r.ok && f(r.value), r)\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        const valueAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"value\",\n        );\n        currentExpr = factory.createParenthesizedExpression(\n          factory.createCommaListExpression([\n            factory.createBinaryExpression(\n              factory.createPropertyAccessExpression(prev, \"ok\"),\n              factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),\n              factory.createCallExpression(fn, undefined, [valueAccess]),\n            ),\n            prev,\n          ]),\n        );\n        break;\n      }\n\n      case \"tapErr\": {\n        // .tapErr(f) => (!r.ok && f(r.error), r)\n        const fn = step.args[0];\n        const prev = currentExpr!;\n        const errorAccess = factory.createPropertyAccessExpression(\n          prev,\n          \"error\",\n        );\n        currentExpr = factory.createParenthesizedExpression(\n          factory.createCommaListExpression([\n            factory.createBinaryExpression(\n              factory.createPrefixUnaryExpression(\n                ts.SyntaxKind.ExclamationToken,\n                factory.createPropertyAccessExpression(prev, \"ok\"),\n              ),\n              factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),\n              factory.createCallExpression(fn, undefined, [errorAccess]),\n            ),\n            prev,\n          ]),\n        );\n        break;\n      }\n\n      case \"isOk\": {\n        // .isOk() => r.ok\n        const prev = currentExpr!;\n        currentExpr = factory.createPropertyAccessExpression(prev, \"ok\");\n        break;\n      }\n\n      case \"isErr\": {\n        // .isErr() => !r.ok\n        const prev = currentExpr!;\n        currentExpr = factory.createPrefixUnaryExpression(\n          ts.SyntaxKind.ExclamationToken,\n          factory.createPropertyAccessExpression(prev, \"ok\"),\n        );\n        break;\n      }\n    }\n  }\n\n  return currentExpr ?? chain.root;\n}\n\n// ============================================================================\n// Register\n// ============================================================================\n\nexport const resultMacro = defineExpressionMacro({\n  name: \"Result\",\n  description:\n    \"Zero-cost Result type — compiles method chains to inlined ok/error checks\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const chain = parseResultChain(callExpr);\n    if (chain) {\n      return expandResultChain(ctx, chain);\n    }\n\n    // Handle standalone Result.ok / Result.err\n    const expr = callExpr.expression;\n    if (\n      ts.isPropertyAccessExpression(expr) &&\n      ts.isIdentifier(expr.expression) &&\n      expr.expression.text === \"Result\"\n    ) {\n      const method = expr.name.text;\n      const factory = ctx.factory;\n\n      if (method === \"ok\" && args.length === 1) {\n        return factory.createObjectLiteralExpression([\n          factory.createPropertyAssignment(\"ok\", factory.createTrue()),\n          factory.createPropertyAssignment(\"value\", args[0]),\n        ]);\n      }\n\n      if (method === \"err\" && args.length === 1) {\n        return factory.createObjectLiteralExpression([\n          factory.createPropertyAssignment(\"ok\", factory.createFalse()),\n          factory.createPropertyAssignment(\"error\", args[0]),\n        ]);\n      }\n\n      if (method === \"isOk\" && args.length === 1) {\n        return factory.createPropertyAccessExpression(args[0], \"ok\");\n      }\n\n      if (method === \"isErr\" && args.length === 1) {\n        return factory.createPrefixUnaryExpression(\n          ts.SyntaxKind.ExclamationToken,\n          factory.createPropertyAccessExpression(args[0], \"ok\"),\n        );\n      }\n    }\n\n    return callExpr;\n  },\n});\n\nglobalRegistry.register(resultMacro);\n","/**\n * Zero-Cost Newtype - Branded types that compile away completely\n *\n * Newtypes provide type-safe wrappers around primitive types at zero runtime\n * cost. The brand exists only in the type system — at runtime, the value is\n * just the underlying primitive. The macro erases all wrap/unwrap calls.\n *\n * Inspired by Haskell's newtype and Rust's newtype pattern.\n *\n * @example\n * ```typescript\n * // Define branded types:\n * type UserId = Newtype<number, \"UserId\">;\n * type Email = Newtype<string, \"Email\">;\n * type Meters = Newtype<number, \"Meters\">;\n * type Seconds = Newtype<number, \"Seconds\">;\n *\n * // Source (what you write):\n * const id = wrap<UserId>(42);\n * const raw = unwrap(id);\n * const email = wrap<Email>(\"user@example.com\");\n *\n * // Compiled output (what runs):\n * const id = 42;\n * const raw = id;\n * const email = \"user@example.com\";\n *\n * // Type errors at compile time:\n * function getUser(id: UserId): User { ... }\n * getUser(42);                    // Error: number is not UserId\n * getUser(wrap<UserId>(42));      // OK — compiles to getUser(42)\n *\n * // Prevent mixing up similar types:\n * function move(distance: Meters, duration: Seconds): void { ... }\n * const d = wrap<Meters>(100);\n * const t = wrap<Seconds>(10);\n * move(d, t);  // OK\n * move(t, d);  // Error: Seconds is not Meters\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API\n// ============================================================================\n\n/** Brand symbol for newtype discrimination */\ndeclare const __brand: unique symbol;\n\n/**\n * A branded type that wraps Base with a phantom Brand tag.\n * At runtime this is just Base — the brand exists only in the type system.\n */\nexport type Newtype<Base, Brand extends string> = Base & {\n  readonly [__brand]: Brand;\n};\n\n/**\n * Extract the base type from a Newtype.\n */\nexport type UnwrapNewtype<T> = T extends Newtype<infer Base, string> ? Base : T;\n\n/**\n * Wrap a value in a Newtype. Compiles away to nothing.\n *\n * @example\n * const userId = wrap<UserId>(42); // Compiles to: const userId = 42;\n */\nexport function wrap<T>(value: UnwrapNewtype<T>): T {\n  return value as T;\n}\n\n/**\n * Unwrap a Newtype to its base value. Compiles away to nothing.\n *\n * @example\n * const raw = unwrap(userId); // Compiles to: const raw = userId;\n */\nexport function unwrap<T>(value: T): UnwrapNewtype<T> {\n  return value as UnwrapNewtype<T>;\n}\n\n/**\n * Create a constructor function for a Newtype.\n * The constructor itself compiles away — it's just the identity function.\n *\n * @example\n * const UserId = newtypeCtor<UserId>();\n * const id = UserId(42); // Compiles to: const id = 42;\n */\nexport function newtypeCtor<T>(): (value: UnwrapNewtype<T>) => T {\n  return (value) => value as T;\n}\n\n/**\n * Create a validated constructor for a Newtype.\n * The validation runs at runtime, but the wrapping is zero-cost.\n *\n * @example\n * const Email = validatedNewtype<Email>((s: string) => s.includes(\"@\"));\n * const email = Email(\"user@example.com\"); // Validates then returns the string\n */\nexport function validatedNewtype<T>(\n  validate: (value: UnwrapNewtype<T>) => boolean,\n  errorMessage?: string,\n): (value: UnwrapNewtype<T>) => T {\n  return (value) => {\n    if (!validate(value)) {\n      throw new Error(errorMessage ?? `Invalid value for newtype: ${value}`);\n    }\n    return value as T;\n  };\n}\n\n// ============================================================================\n// Newtype Macro - Erases wrap/unwrap at compile time\n// ============================================================================\n\nexport const wrapMacro = defineExpressionMacro({\n  name: \"wrap\",\n  description: \"Zero-cost newtype wrap — compiles away to the raw value\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"wrap() expects exactly one argument\");\n      return callExpr;\n    }\n    // wrap<UserId>(42) => 42\n    return args[0];\n  },\n});\n\nexport const unwrapMacro = defineExpressionMacro({\n  name: \"unwrap\",\n  description: \"Zero-cost newtype unwrap — compiles away to the raw value\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"unwrap() expects exactly one argument\");\n      return callExpr;\n    }\n    // unwrap(userId) => userId\n    return args[0];\n  },\n});\n\nexport const newtypeCtorMacro = defineExpressionMacro({\n  name: \"newtypeCtor\",\n  description:\n    \"Zero-cost newtype constructor factory — the returned function compiles to identity\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    // newtypeCtor<UserId>() => (v) => v\n    // Which further inlines at call sites\n    const factory = ctx.factory;\n    const param = factory.createParameterDeclaration(\n      undefined,\n      undefined,\n      factory.createIdentifier(\"__v\"),\n    );\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [param],\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      factory.createIdentifier(\"__v\"),\n    );\n  },\n});\n\nglobalRegistry.register(wrapMacro);\nglobalRegistry.register(unwrapMacro);\n","/**\n * Zero-Cost pipe/flow - Inlined function composition\n *\n * pipe() and flow() provide point-free function composition that compiles\n * to direct nested calls — no intermediate arrays, no reduce, no closures.\n *\n * Inspired by fp-ts pipe, Ramda, and F# |> operator.\n *\n * @example\n * ```typescript\n * // Source (what you write):\n * const result = pipe(\n *   rawInput,\n *   trim,\n *   toLowerCase,\n *   x => x.split(\",\"),\n *   xs => xs.filter(Boolean),\n * );\n *\n * // Compiled output (what runs):\n * const result = ((x) => x.filter(Boolean))(\n *   ((x) => x.split(\",\"))(\n *     toLowerCase(\n *       trim(rawInput)\n *     )\n *   )\n * );\n *\n * // With simple named functions, even simpler:\n * const result = pipe(users, filterActive, sortByName, take(10));\n * // Compiles to:\n * const result = take(10)(sortByName(filterActive(users)));\n * ```\n *\n * @example\n * ```typescript\n * // flow() creates a reusable pipeline (compiles to a single composed function):\n * const processUser = flow(\n *   validateEmail,\n *   normalizeCase,\n *   addTimestamp,\n * );\n *\n * // Compiled output:\n * const processUser = (__x) => addTimestamp(normalizeCase(validateEmail(__x)));\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry } from \"@typemacro/core\";\nimport { MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API\n// ============================================================================\n\n/** pipe: Apply a value through a chain of functions left-to-right */\nexport function pipe<A>(value: A): A;\nexport function pipe<A, B>(value: A, f1: (a: A) => B): B;\nexport function pipe<A, B, C>(value: A, f1: (a: A) => B, f2: (b: B) => C): C;\nexport function pipe<A, B, C, D>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n): D;\nexport function pipe<A, B, C, D, E>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n): E;\nexport function pipe<A, B, C, D, E, F>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n): F;\nexport function pipe<A, B, C, D, E, F, G>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n  f6: (f: F) => G,\n): G;\nexport function pipe<A, B, C, D, E, F, G, H>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n  f6: (f: F) => G,\n  f7: (g: G) => H,\n): H;\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  value: A,\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n  f6: (f: F) => G,\n  f7: (g: G) => H,\n  f8: (h: H) => I,\n): I;\nexport function pipe(\n  value: unknown,\n  ...fns: Array<(x: unknown) => unknown>\n): unknown {\n  return fns.reduce((acc, fn) => fn(acc), value);\n}\n\n/** flow: Compose functions left-to-right into a single function */\nexport function flow<A, B>(f1: (a: A) => B): (a: A) => B;\nexport function flow<A, B, C>(f1: (a: A) => B, f2: (b: B) => C): (a: A) => C;\nexport function flow<A, B, C, D>(\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n): (a: A) => D;\nexport function flow<A, B, C, D, E>(\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n): (a: A) => E;\nexport function flow<A, B, C, D, E, F>(\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n): (a: A) => F;\nexport function flow<A, B, C, D, E, F, G>(\n  f1: (a: A) => B,\n  f2: (b: B) => C,\n  f3: (c: C) => D,\n  f4: (d: D) => E,\n  f5: (e: E) => F,\n  f6: (f: F) => G,\n): (a: A) => G;\nexport function flow(\n  ...fns: Array<(x: unknown) => unknown>\n): (x: unknown) => unknown {\n  return (x) => fns.reduce((acc, fn) => fn(acc), x);\n}\n\n// ============================================================================\n// Pipe Macro - Inlines function composition\n// ============================================================================\n\nexport const pipeMacro = defineExpressionMacro({\n  name: \"pipe\",\n  description:\n    \"Zero-cost pipe — inlines function composition into nested calls\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length === 0) {\n      ctx.reportError(callExpr, \"pipe() requires at least one argument\");\n      return callExpr;\n    }\n\n    if (args.length === 1) {\n      // pipe(x) => x\n      return args[0];\n    }\n\n    // pipe(value, f1, f2, f3) => f3(f2(f1(value)))\n    let result: ts.Expression = args[0];\n    for (let i = 1; i < args.length; i++) {\n      result = factory.createCallExpression(args[i], undefined, [result]);\n    }\n    return result;\n  },\n});\n\n// ============================================================================\n// Flow Macro - Composes functions into a single arrow\n// ============================================================================\n\nexport const flowMacro = defineExpressionMacro({\n  name: \"flow\",\n  description:\n    \"Zero-cost flow — composes functions into a single inlined arrow function\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length === 0) {\n      ctx.reportError(callExpr, \"flow() requires at least one function\");\n      return callExpr;\n    }\n\n    if (args.length === 1) {\n      // flow(f) => f\n      return args[0];\n    }\n\n    // flow(f1, f2, f3) => (__x) => f3(f2(f1(__x)))\n    const param = ctx.generateUniqueName(\"__x\");\n    let body: ts.Expression = param;\n    for (const fn of args) {\n      body = factory.createCallExpression(fn, undefined, [body]);\n    }\n\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [factory.createParameterDeclaration(undefined, undefined, param)],\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      body,\n    );\n  },\n});\n\nglobalRegistry.register(pipeMacro);\nglobalRegistry.register(flowMacro);\n","/**\n * Zero-Cost Compile-Time Assertions and Invariants\n *\n * Provides compile-time checks that either:\n * 1. Disappear completely in production (staticAssert, typeAssert)\n * 2. Compile to minimal runtime checks (invariant, unreachable)\n *\n * Inspired by Rust's compile_error!, static_assert, unreachable!, and C++'s static_assert.\n *\n * @example\n * ```typescript\n * // staticAssert — evaluates condition at compile time, emits nothing\n * staticAssert(sizeof<User>() <= 1024, \"User struct too large\");\n * // Compiled output: (nothing — completely erased)\n *\n * // typeAssert — compile-time type relationship check\n * typeAssert<Extends<Dog, Animal>>();\n * typeAssert<Equals<Option<number>, number | null>>();\n * // Compiled output: (nothing)\n *\n * // invariant — kept in dev, stripped in prod\n * invariant(users.length > 0, \"Expected at least one user\");\n * // Dev output:  if (!(users.length > 0)) throw new Error(\"Expected at least one user\");\n * // Prod output: (nothing)\n *\n * // unreachable — marks code paths that should never execute\n * switch (shape.kind) {\n *   case \"circle\": return circleArea(shape);\n *   case \"square\": return squareArea(shape);\n *   default: unreachable(shape); // Compile error if shape isn't exhausted\n * }\n * // Compiled output: throw new Error(\"Unreachable\")\n *\n * // debugOnly — wraps code that should only run in development\n * debugOnly(() => {\n *   console.log(\"Debug info:\", state);\n *   validateInternalState(state);\n * });\n * // Dev output:  (() => { console.log(...); validateInternalState(state); })()\n * // Prod output: (nothing)\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API\n// ============================================================================\n\n/** Compile-time type equality check */\nexport type Equals<A, B> = [A] extends [B]\n  ? [B] extends [A]\n    ? true\n    : false\n  : false;\n\n/** Compile-time subtype check */\nexport type Extends<A, B> = A extends B ? true : false;\n\n/** Compile-time \"not\" */\nexport type Not<T extends boolean> = T extends true ? false : true;\n\n/** Compile-time \"and\" */\nexport type And<A extends boolean, B extends boolean> = A extends true\n  ? B extends true\n    ? true\n    : false\n  : false;\n\n/** Compile-time \"or\" */\nexport type Or<A extends boolean, B extends boolean> = A extends true\n  ? true\n  : B extends true\n    ? true\n    : false;\n\n/**\n * Assert a condition at compile time. Completely erased from output.\n * If the condition is false, emits a compile error.\n */\nexport function staticAssert(_condition: true, _message?: string): void {}\n\n/**\n * Assert a type-level predicate. Completely erased from output.\n * Usage: typeAssert<Equals<A, B>>()\n */\nexport function typeAssert<_T extends true>(): void {}\n\n/**\n * Runtime invariant check. Stripped in production builds.\n */\nexport function invariant(\n  condition: boolean,\n  message?: string,\n): asserts condition {\n  if (!condition) {\n    throw new Error(message ?? \"Invariant violation\");\n  }\n}\n\n/**\n * Mark a code path as unreachable. Useful for exhaustiveness checking.\n * At runtime, throws if somehow reached.\n */\nexport function unreachable(_value?: never): never {\n  throw new Error(\"Unreachable code reached\");\n}\n\n/**\n * Code that only runs in development. Completely erased in production.\n */\nexport function debugOnly(fn: () => void): void {\n  fn();\n}\n\n/**\n * Compile-time sizeof — returns the number of properties on a type.\n * Useful for compile-time assertions about type size.\n */\nexport function sizeof<_T>(): number {\n  return 0; // Replaced by macro\n}\n\n// ============================================================================\n// Macros\n// ============================================================================\n\nexport const staticAssertMacro = defineExpressionMacro({\n  name: \"staticAssert\",\n  description: \"Compile-time assertion — completely erased from output\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 1) {\n      ctx.reportError(callExpr, \"staticAssert() requires a condition\");\n      return callExpr;\n    }\n\n    // Try to evaluate the condition at compile time\n    const conditionResult = ctx.evaluate(args[0]);\n\n    if (conditionResult.kind === \"boolean\") {\n      if (!conditionResult.value) {\n        const message =\n          args.length >= 2\n            ? (() => {\n                const msgResult = ctx.evaluate(args[1]);\n                return msgResult.kind === \"string\"\n                  ? msgResult.value\n                  : \"Static assertion failed\";\n              })()\n            : \"Static assertion failed\";\n        ctx.reportError(callExpr, message);\n      }\n    }\n\n    // Erase completely — replace with void 0\n    return ctx.factory.createVoidExpression(\n      ctx.factory.createNumericLiteral(0),\n    );\n  },\n});\n\nexport const typeAssertMacro = defineExpressionMacro({\n  name: \"typeAssert\",\n  description: \"Compile-time type assertion — completely erased from output\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    // Type assertions are checked by the type system itself.\n    // The macro just erases the call.\n    // If typeAssert<false>() is written, TypeScript will already error\n    // because `false` doesn't extend `true`.\n    return ctx.factory.createVoidExpression(\n      ctx.factory.createNumericLiteral(0),\n    );\n  },\n});\n\nexport const invariantMacro = defineExpressionMacro({\n  name: \"invariant\",\n  description:\n    \"Runtime invariant — compiles to a conditional throw (strippable in prod)\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length < 1) {\n      ctx.reportError(callExpr, \"invariant() requires a condition\");\n      return callExpr;\n    }\n\n    const condition = args[0];\n    const message =\n      args.length >= 2\n        ? args[1]\n        : factory.createStringLiteral(\"Invariant violation\");\n\n    // Compile to: condition || (() => { throw new Error(message); })()\n    return factory.createBinaryExpression(\n      condition,\n      factory.createToken(ts.SyntaxKind.BarBarToken),\n      factory.createCallExpression(\n        factory.createParenthesizedExpression(\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            factory.createBlock([\n              factory.createThrowStatement(\n                factory.createNewExpression(\n                  factory.createIdentifier(\"Error\"),\n                  undefined,\n                  [message],\n                ),\n              ),\n            ]),\n          ),\n        ),\n        undefined,\n        [],\n      ),\n    );\n  },\n});\n\nexport const unreachableMacro = defineExpressionMacro({\n  name: \"unreachable\",\n  description: \"Marks unreachable code — compiles to throw\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    // Compile to an IIFE that throws\n    return factory.createCallExpression(\n      factory.createParenthesizedExpression(\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createBlock([\n            factory.createThrowStatement(\n              factory.createNewExpression(\n                factory.createIdentifier(\"Error\"),\n                undefined,\n                [factory.createStringLiteral(\"Unreachable code reached\")],\n              ),\n            ),\n          ]),\n        ),\n      ),\n      undefined,\n      [],\n    );\n  },\n});\n\nexport const debugOnlyMacro = defineExpressionMacro({\n  name: \"debugOnly\",\n  description:\n    \"Dev-only code block — inlined in dev, completely erased in prod\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"debugOnly() expects exactly one function\");\n      return callExpr;\n    }\n\n    // In dev mode: inline the function call\n    // In prod mode: erase completely (void 0)\n    // For now, we always inline — a production flag would control this\n    const fn = args[0];\n    return factory.createCallExpression(fn, undefined, []);\n  },\n});\n\nexport const sizeofMacro = defineExpressionMacro({\n  name: \"sizeof\",\n  description:\n    \"Compile-time sizeof — returns number of properties on a type as a literal\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    // Get the type argument\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"sizeof<T>() requires exactly one type argument\",\n      );\n      return callExpr;\n    }\n\n    const typeNode = typeArgs[0];\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeNode);\n    const properties = type.getProperties();\n\n    return ctx.factory.createNumericLiteral(properties.length);\n  },\n});\n\nglobalRegistry.register(staticAssertMacro);\nglobalRegistry.register(typeAssertMacro);\nglobalRegistry.register(invariantMacro);\nglobalRegistry.register(unreachableMacro);\nglobalRegistry.register(debugOnlyMacro);\nglobalRegistry.register(sizeofMacro);\n","/**\n * Zero-Cost Exhaustive Pattern Matching\n *\n * Compiles match expressions into optimized if/else chains or switch\n * statements — no closures, no arrays of patterns, no runtime matching engine.\n *\n * Supports:\n * - Discriminated unions (tagged unions)\n * - Literal matching (string, number, boolean)\n * - Predicate guards\n * - Wildcard/default cases\n * - Nested destructuring\n *\n * Inspired by Rust's match, Scala's pattern matching, and ts-pattern.\n *\n * @example\n * ```typescript\n * // Source (what you write):\n * type Shape =\n *   | { kind: \"circle\"; radius: number }\n *   | { kind: \"rect\"; width: number; height: number }\n *   | { kind: \"triangle\"; base: number; height: number };\n *\n * const area = match(shape, {\n *   circle: (s) => Math.PI * s.radius ** 2,\n *   rect: (s) => s.width * s.height,\n *   triangle: (s) => 0.5 * s.base * s.height,\n * });\n *\n * // Compiled output (what runs):\n * const area =\n *   shape.kind === \"circle\" ? ((s) => Math.PI * s.radius ** 2)(shape)\n *   : shape.kind === \"rect\" ? ((s) => s.width * s.height)(shape)\n *   : ((s) => 0.5 * s.base * s.height)(shape);\n * ```\n *\n * @example\n * ```typescript\n * // matchLiteral for simple value matching:\n * const label = matchLiteral(statusCode, {\n *   200: () => \"OK\",\n *   404: () => \"Not Found\",\n *   500: () => \"Server Error\",\n *   _: () => \"Unknown\",\n * });\n *\n * // Compiled output:\n * const label =\n *   statusCode === 200 ? \"OK\"\n *   : statusCode === 404 ? \"Not Found\"\n *   : statusCode === 500 ? \"Server Error\"\n *   : \"Unknown\";\n * ```\n *\n * @example\n * ```typescript\n * // matchGuard for predicate-based matching:\n * const category = matchGuard(score, [\n *   [s => s >= 90, () => \"A\"],\n *   [s => s >= 80, () => \"B\"],\n *   [s => s >= 70, () => \"C\"],\n *   [() => true,   () => \"F\"],\n * ]);\n *\n * // Compiled output:\n * const category =\n *   score >= 90 ? \"A\"\n *   : score >= 80 ? \"B\"\n *   : score >= 70 ? \"C\"\n *   : \"F\";\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Type-Level API\n// ============================================================================\n\n/** Extract the discriminant values from a union type */\ntype DiscriminantOf<T, K extends keyof T> =\n  T extends Record<K, infer V> ? (V extends string ? V : never) : never;\n\n/** Handler map for discriminated union matching */\ntype MatchHandlers<T, K extends keyof T, R> = {\n  [V in DiscriminantOf<T, K>]: (value: Extract<T, Record<K, V>>) => R;\n};\n\n/** Handler map for literal matching (with optional wildcard) */\ntype LiteralHandlers<T extends string | number, R> = {\n  [K in T]?: () => R;\n} & {\n  _?: () => R;\n};\n\n/** Guard-based match arm */\ntype GuardArm<T, R> = [(value: T) => boolean, (value: T) => R];\n\n/**\n * Match on a discriminated union. Exhaustive by default.\n *\n * @param value - The value to match on\n * @param handlers - Object mapping discriminant values to handler functions\n * @param discriminant - The discriminant key (default: \"kind\")\n */\nexport function match<T extends Record<string, unknown>, K extends keyof T, R>(\n  value: T,\n  handlers: MatchHandlers<T, K, R>,\n  discriminant?: K,\n): R {\n  const key = (discriminant ?? \"kind\") as K;\n  const tag = value[key] as string;\n  const handler = (handlers as Record<string, (v: T) => R>)[tag];\n  if (!handler) {\n    throw new Error(`No handler for discriminant: ${String(tag)}`);\n  }\n  return handler(value);\n}\n\n/**\n * Match on literal values (strings, numbers).\n * Use _ for the default/wildcard case.\n */\nexport function matchLiteral<T extends string | number, R>(\n  value: T,\n  handlers: LiteralHandlers<T, R>,\n): R {\n  const handler = (handlers as Record<string | number, (() => R) | undefined>)[\n    value\n  ];\n  if (handler) return handler();\n  const wildcard = (handlers as Record<string, (() => R) | undefined>)[\"_\"];\n  if (wildcard) return wildcard();\n  throw new Error(`No handler for value: ${value}`);\n}\n\n/**\n * Match with predicate guards. First matching guard wins.\n */\nexport function matchGuard<T, R>(value: T, arms: GuardArm<T, R>[]): R {\n  for (const [pred, handler] of arms) {\n    if (pred(value)) return handler(value);\n  }\n  throw new Error(\"No matching guard\");\n}\n\n// ============================================================================\n// Match Macro - Compiles to if/else chains\n// ============================================================================\n\nexport const matchMacro = defineExpressionMacro({\n  name: \"match\",\n  description:\n    \"Zero-cost pattern matching — compiles to inlined if/else chains\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length < 2) {\n      ctx.reportError(\n        callExpr,\n        \"match() requires a value and a handlers object\",\n      );\n      return callExpr;\n    }\n\n    const value = args[0];\n    const handlersArg = args[1];\n    const discriminant = args.length >= 3 ? args[2] : undefined;\n\n    // Determine the discriminant key\n    let keyName = \"kind\";\n    if (discriminant && ts.isStringLiteral(discriminant)) {\n      keyName = discriminant.text;\n    }\n\n    // The handlers must be an object literal for compile-time expansion\n    if (!ts.isObjectLiteralExpression(handlersArg)) {\n      ctx.reportError(\n        handlersArg,\n        \"match() handlers must be an object literal for compile-time expansion\",\n      );\n      return callExpr;\n    }\n\n    // Build a chain of ternary expressions:\n    // value.kind === \"a\" ? handlerA(value) : value.kind === \"b\" ? handlerB(value) : ...\n    const properties = handlersArg.properties.filter(\n      (p): p is ts.PropertyAssignment => ts.isPropertyAssignment(p),\n    );\n\n    if (properties.length === 0) {\n      ctx.reportError(handlersArg, \"match() handlers object is empty\");\n      return callExpr;\n    }\n\n    // Build from last to first (right-fold into ternaries)\n    let result: ts.Expression = factory.createCallExpression(\n      factory.createParenthesizedExpression(\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createBlock([\n            factory.createThrowStatement(\n              factory.createNewExpression(\n                factory.createIdentifier(\"Error\"),\n                undefined,\n                [factory.createStringLiteral(\"Non-exhaustive match\")],\n              ),\n            ),\n          ]),\n        ),\n      ),\n      undefined,\n      [],\n    );\n\n    // Process in reverse so we build the ternary chain correctly\n    for (let i = properties.length - 1; i >= 0; i--) {\n      const prop = properties[i];\n      const propName = ts.isIdentifier(prop.name)\n        ? prop.name.text\n        : ts.isStringLiteral(prop.name)\n          ? prop.name.text\n          : null;\n\n      if (!propName) continue;\n\n      const handler = prop.initializer;\n\n      // Wildcard case\n      if (propName === \"_\") {\n        if (ts.isArrowFunction(handler) && !ts.isBlock(handler.body)) {\n          result =\n            handler.parameters.length === 0\n              ? (handler.body as ts.Expression)\n              : factory.createCallExpression(handler, undefined, [value]);\n        } else {\n          result = factory.createCallExpression(handler, undefined, [value]);\n        }\n        continue;\n      }\n\n      // Discriminated case: value.kind === \"propName\" ? handler(value) : ...\n      const condition = factory.createBinaryExpression(\n        factory.createPropertyAccessExpression(value, keyName),\n        factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n        factory.createStringLiteral(propName),\n      );\n\n      const thenExpr = factory.createCallExpression(handler, undefined, [\n        value,\n      ]);\n\n      result = factory.createConditionalExpression(\n        condition,\n        factory.createToken(ts.SyntaxKind.QuestionToken),\n        thenExpr,\n        factory.createToken(ts.SyntaxKind.ColonToken),\n        result,\n      );\n    }\n\n    return result;\n  },\n});\n\n// ============================================================================\n// MatchLiteral Macro\n// ============================================================================\n\nexport const matchLiteralMacro = defineExpressionMacro({\n  name: \"matchLiteral\",\n  description:\n    \"Zero-cost literal matching — compiles to inlined equality checks\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 2) {\n      ctx.reportError(\n        callExpr,\n        \"matchLiteral() requires a value and a handlers object\",\n      );\n      return callExpr;\n    }\n\n    const value = args[0];\n    const handlersArg = args[1];\n\n    if (!ts.isObjectLiteralExpression(handlersArg)) {\n      ctx.reportError(\n        handlersArg,\n        \"matchLiteral() handlers must be an object literal\",\n      );\n      return callExpr;\n    }\n\n    const properties = handlersArg.properties.filter(\n      (p): p is ts.PropertyAssignment => ts.isPropertyAssignment(p),\n    );\n\n    // Separate wildcard from specific cases\n    let wildcardHandler: ts.Expression | undefined;\n    const cases: Array<{ literal: ts.Expression; handler: ts.Expression }> = [];\n\n    for (const prop of properties) {\n      const propName = ts.isIdentifier(prop.name)\n        ? prop.name.text\n        : ts.isStringLiteral(prop.name)\n          ? prop.name.text\n          : ts.isNumericLiteral(prop.name)\n            ? prop.name.text\n            : null;\n\n      if (!propName) continue;\n\n      if (propName === \"_\") {\n        wildcardHandler = prop.initializer;\n        continue;\n      }\n\n      // Determine if it's a number or string literal\n      const num = Number(propName);\n      const literal = !isNaN(num)\n        ? factory.createNumericLiteral(num)\n        : factory.createStringLiteral(propName);\n\n      cases.push({ literal, handler: prop.initializer });\n    }\n\n    // Build ternary chain from right to left\n    let result: ts.Expression;\n    if (wildcardHandler) {\n      // Call the wildcard handler\n      result = factory.createCallExpression(wildcardHandler, undefined, []);\n    } else {\n      result = factory.createCallExpression(\n        factory.createParenthesizedExpression(\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            [],\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            factory.createBlock([\n              factory.createThrowStatement(\n                factory.createNewExpression(\n                  factory.createIdentifier(\"Error\"),\n                  undefined,\n                  [factory.createStringLiteral(\"Non-exhaustive matchLiteral\")],\n                ),\n              ),\n            ]),\n          ),\n        ),\n        undefined,\n        [],\n      );\n    }\n\n    for (let i = cases.length - 1; i >= 0; i--) {\n      const { literal, handler } = cases[i];\n      const condition = factory.createBinaryExpression(\n        value,\n        factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n        literal,\n      );\n      const thenExpr = factory.createCallExpression(handler, undefined, []);\n\n      result = factory.createConditionalExpression(\n        condition,\n        factory.createToken(ts.SyntaxKind.QuestionToken),\n        thenExpr,\n        factory.createToken(ts.SyntaxKind.ColonToken),\n        result,\n      );\n    }\n\n    return result;\n  },\n});\n\n// ============================================================================\n// MatchGuard Macro\n// ============================================================================\n\nexport const matchGuardMacro = defineExpressionMacro({\n  name: \"matchGuard\",\n  description:\n    \"Zero-cost guard matching — compiles to inlined predicate checks\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 2) {\n      ctx.reportError(\n        callExpr,\n        \"matchGuard() requires a value and an array of guard arms\",\n      );\n      return callExpr;\n    }\n\n    const value = args[0];\n    const armsArg = args[1];\n\n    if (!ts.isArrayLiteralExpression(armsArg)) {\n      ctx.reportError(armsArg, \"matchGuard() arms must be an array literal\");\n      return callExpr;\n    }\n\n    // Each arm is [predicate, handler]\n    const arms: Array<{ predicate: ts.Expression; handler: ts.Expression }> =\n      [];\n\n    for (const element of armsArg.elements) {\n      if (\n        !ts.isArrayLiteralExpression(element) ||\n        element.elements.length !== 2\n      ) {\n        ctx.reportError(\n          element,\n          \"Each matchGuard arm must be a [predicate, handler] tuple\",\n        );\n        continue;\n      }\n      arms.push({\n        predicate: element.elements[0],\n        handler: element.elements[1],\n      });\n    }\n\n    if (arms.length === 0) {\n      ctx.reportError(armsArg, \"matchGuard() requires at least one arm\");\n      return callExpr;\n    }\n\n    // Build ternary chain: pred1(value) ? handler1(value) : pred2(value) ? ...\n    let result: ts.Expression = factory.createCallExpression(\n      factory.createParenthesizedExpression(\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createBlock([\n            factory.createThrowStatement(\n              factory.createNewExpression(\n                factory.createIdentifier(\"Error\"),\n                undefined,\n                [\n                  factory.createStringLiteral(\n                    \"No matching guard in matchGuard\",\n                  ),\n                ],\n              ),\n            ),\n          ]),\n        ),\n      ),\n      undefined,\n      [],\n    );\n\n    for (let i = arms.length - 1; i >= 0; i--) {\n      const { predicate, handler } = arms[i];\n\n      const condition = factory.createCallExpression(predicate, undefined, [\n        value,\n      ]);\n      const thenExpr = factory.createCallExpression(handler, undefined, [\n        value,\n      ]);\n\n      result = factory.createConditionalExpression(\n        condition,\n        factory.createToken(ts.SyntaxKind.QuestionToken),\n        thenExpr,\n        factory.createToken(ts.SyntaxKind.ColonToken),\n        result,\n      );\n    }\n\n    return result;\n  },\n});\n\nglobalRegistry.register(matchMacro);\nglobalRegistry.register(matchLiteralMacro);\nglobalRegistry.register(matchGuardMacro);\n"],"mappings":"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","names":["ts","import_core","ts","import_core","ts","import_core","ts","import_core","ts","import_core"]}