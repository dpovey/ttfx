// src/option.ts
import * as ts from "typescript";
import { defineExpressionMacro, globalRegistry } from "@typemacro/core";
var Option = {
  /** Wrap a nullable value into an Option */
  from(value) {
    return value ?? null;
  },
  /** Create a Some value */
  some(value) {
    return value;
  },
  /** The None value */
  none: null,
  /** Check if an Option is Some */
  isSome(opt) {
    return opt != null;
  },
  /** Check if an Option is None */
  isNone(opt) {
    return opt == null;
  }
};
function parseOptionChain(node) {
  const steps = [];
  let current = node;
  while (ts.isCallExpression(current)) {
    const expr = current.expression;
    if (!ts.isPropertyAccessExpression(expr)) {
      break;
    }
    const methodName = expr.name.text;
    const validMethods = [
      "map",
      "flatMap",
      "filter",
      "unwrapOr",
      "unwrap",
      "match",
      "zip",
      "and",
      "or",
      "tap"
    ];
    if (!validMethods.includes(methodName)) {
      break;
    }
    steps.unshift({
      kind: methodName,
      args: current.arguments
    });
    current = expr.expression;
  }
  if (ts.isCallExpression(current)) {
    const expr = current.expression;
    if (ts.isPropertyAccessExpression(expr) && ts.isIdentifier(expr.expression) && expr.expression.text === "Option") {
      const method = expr.name.text;
      if (method === "from" || method === "some") {
        steps.unshift({
          kind: "from",
          args: current.arguments
        });
        return { root: current, steps };
      }
    }
  }
  if (steps.length === 0) {
    return null;
  }
  return { root: current, steps };
}
function expandOptionChain(ctx, chain) {
  const factory = ctx.factory;
  let counter = 0;
  function tempName() {
    return ctx.generateUniqueName(`__opt_${counter++}`);
  }
  function nullCheck(value, thenExpr, elseExpr) {
    return factory.createConditionalExpression(
      factory.createBinaryExpression(
        value,
        factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),
        factory.createNull()
      ),
      factory.createToken(ts.SyntaxKind.QuestionToken),
      thenExpr,
      factory.createToken(ts.SyntaxKind.ColonToken),
      elseExpr ?? factory.createNull()
    );
  }
  let currentExpr = null;
  for (const step of chain.steps) {
    switch (step.kind) {
      case "from": {
        const arg = step.args[0];
        currentExpr = factory.createBinaryExpression(
          arg,
          factory.createToken(ts.SyntaxKind.QuestionQuestionToken),
          factory.createNull()
        );
        break;
      }
      case "map": {
        const fn = step.args[0];
        const prev = currentExpr;
        if (ts.isArrowFunction(fn) || ts.isFunctionExpression(fn)) {
          const param = fn.parameters[0];
          if (param && ts.isIdentifier(param.name)) {
            const body = ts.isArrowFunction(fn) && !ts.isBlock(fn.body) ? fn.body : null;
            if (body) {
              currentExpr = nullCheck(prev, inlineArrowBody(factory, fn, prev));
            } else {
              currentExpr = nullCheck(
                prev,
                factory.createCallExpression(fn, void 0, [prev])
              );
            }
          } else {
            currentExpr = nullCheck(
              prev,
              factory.createCallExpression(fn, void 0, [prev])
            );
          }
        } else {
          currentExpr = nullCheck(
            prev,
            factory.createCallExpression(fn, void 0, [prev])
          );
        }
        break;
      }
      case "flatMap": {
        const fn = step.args[0];
        const prev = currentExpr;
        if (ts.isArrowFunction(fn) && !ts.isBlock(fn.body)) {
          currentExpr = nullCheck(prev, inlineArrowBody(factory, fn, prev));
        } else {
          currentExpr = nullCheck(
            prev,
            factory.createCallExpression(fn, void 0, [prev])
          );
        }
        break;
      }
      case "filter": {
        const pred = step.args[0];
        const prev = currentExpr;
        const predCall = ts.isArrowFunction(pred) && !ts.isBlock(pred.body) ? inlineArrowBody(factory, pred, prev) : factory.createCallExpression(pred, void 0, [prev]);
        currentExpr = nullCheck(
          prev,
          factory.createConditionalExpression(
            predCall,
            factory.createToken(ts.SyntaxKind.QuestionToken),
            prev,
            factory.createToken(ts.SyntaxKind.ColonToken),
            factory.createNull()
          )
        );
        break;
      }
      case "unwrapOr": {
        const defaultVal = step.args[0];
        const prev = currentExpr;
        currentExpr = nullCheck(prev, prev, defaultVal);
        break;
      }
      case "unwrap": {
        const prev = currentExpr;
        currentExpr = nullCheck(
          prev,
          prev,
          factory.createCallExpression(
            factory.createParenthesizedExpression(
              factory.createArrowFunction(
                void 0,
                void 0,
                [],
                void 0,
                factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
                factory.createBlock([
                  factory.createThrowStatement(
                    factory.createNewExpression(
                      factory.createIdentifier("Error"),
                      void 0,
                      [factory.createStringLiteral("Called unwrap() on None")]
                    )
                  )
                ])
              )
            ),
            void 0,
            []
          )
        );
        break;
      }
      case "match": {
        const prev = currentExpr;
        if (step.args.length === 2) {
          const someFn = step.args[0];
          const noneFn = step.args[1];
          const someCall = ts.isArrowFunction(someFn) && !ts.isBlock(someFn.body) ? inlineArrowBody(factory, someFn, prev) : factory.createCallExpression(someFn, void 0, [prev]);
          const noneCall = ts.isArrowFunction(noneFn) && !ts.isBlock(noneFn.body) ? noneFn.body : factory.createCallExpression(noneFn, void 0, []);
          currentExpr = nullCheck(prev, someCall, noneCall);
        } else if (step.args.length === 1 && ts.isObjectLiteralExpression(step.args[0])) {
          const obj = step.args[0];
          let someFn;
          let noneFn;
          for (const prop of obj.properties) {
            if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {
              if (prop.name.text === "some") someFn = prop.initializer;
              if (prop.name.text === "none") noneFn = prop.initializer;
            }
          }
          if (someFn && noneFn) {
            const someCall = ts.isArrowFunction(someFn) && !ts.isBlock(someFn.body) ? inlineArrowBody(factory, someFn, prev) : factory.createCallExpression(someFn, void 0, [prev]);
            const noneCall = ts.isArrowFunction(noneFn) && !ts.isBlock(noneFn.body) ? noneFn.body : factory.createCallExpression(noneFn, void 0, []);
            currentExpr = nullCheck(prev, someCall, noneCall);
          }
        }
        break;
      }
      case "zip": {
        const other = step.args[0];
        const prev = currentExpr;
        currentExpr = factory.createConditionalExpression(
          factory.createBinaryExpression(
            factory.createBinaryExpression(
              prev,
              factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),
              factory.createNull()
            ),
            factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),
            factory.createBinaryExpression(
              other,
              factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),
              factory.createNull()
            )
          ),
          factory.createToken(ts.SyntaxKind.QuestionToken),
          factory.createArrayLiteralExpression([prev, other]),
          factory.createToken(ts.SyntaxKind.ColonToken),
          factory.createNull()
        );
        break;
      }
      case "and": {
        const other = step.args[0];
        const prev = currentExpr;
        currentExpr = nullCheck(prev, other);
        break;
      }
      case "or": {
        const other = step.args[0];
        const prev = currentExpr;
        currentExpr = nullCheck(prev, prev, other);
        break;
      }
      case "tap": {
        const fn = step.args[0];
        const prev = currentExpr;
        currentExpr = nullCheck(
          prev,
          factory.createParenthesizedExpression(
            factory.createCommaListExpression([
              factory.createCallExpression(fn, void 0, [prev]),
              prev
            ])
          )
        );
        break;
      }
    }
  }
  return currentExpr ?? factory.createNull();
}
function inlineArrowBody(factory, fn, arg) {
  if (!ts.isArrowFunction(fn) || ts.isBlock(fn.body)) {
    return factory.createCallExpression(fn, void 0, [arg]);
  }
  return factory.createCallExpression(fn, void 0, [arg]);
}
var optionMacro = defineExpressionMacro({
  name: "Option",
  description: "Zero-cost Option type \u2014 compiles method chains to inlined null checks",
  expand(ctx, callExpr, args) {
    const chain = parseOptionChain(callExpr);
    if (chain) {
      return expandOptionChain(ctx, chain);
    }
    const expr = callExpr.expression;
    if (ts.isPropertyAccessExpression(expr) && ts.isIdentifier(expr.expression) && expr.expression.text === "Option") {
      const method = expr.name.text;
      if (method === "from" && args.length === 1) {
        return ctx.factory.createBinaryExpression(
          args[0],
          ctx.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),
          ctx.factory.createNull()
        );
      }
      if (method === "some" && args.length === 1) {
        return args[0];
      }
      if (method === "isSome" && args.length === 1) {
        return ctx.factory.createBinaryExpression(
          args[0],
          ctx.factory.createToken(ts.SyntaxKind.ExclamationEqualsToken),
          ctx.factory.createNull()
        );
      }
      if (method === "isNone" && args.length === 1) {
        return ctx.factory.createBinaryExpression(
          args[0],
          ctx.factory.createToken(ts.SyntaxKind.EqualsEqualsToken),
          ctx.factory.createNull()
        );
      }
    }
    return callExpr;
  }
});
globalRegistry.register(optionMacro);

// src/result.ts
import * as ts2 from "typescript";
import { defineExpressionMacro as defineExpressionMacro2, globalRegistry as globalRegistry2 } from "@typemacro/core";
var Result = {
  /** Create a successful result */
  ok(value) {
    return { ok: true, value };
  },
  /** Create a failed result */
  err(error) {
    return { ok: false, error };
  },
  /** Wrap a throwing function into a Result */
  try(fn) {
    try {
      return { ok: true, value: fn() };
    } catch (e) {
      return {
        ok: false,
        error: e instanceof Error ? e : new Error(String(e))
      };
    }
  },
  /** Wrap a Promise into a Result */
  async fromPromise(promise) {
    try {
      return { ok: true, value: await promise };
    } catch (e) {
      return {
        ok: false,
        error: e instanceof Error ? e : new Error(String(e))
      };
    }
  },
  /** Check if a Result is Ok */
  isOk(result) {
    return result.ok;
  },
  /** Check if a Result is Err */
  isErr(result) {
    return !result.ok;
  },
  /** Collect an array of Results into a Result of array */
  all(results) {
    const values = [];
    for (const r of results) {
      if (!r.ok) return r;
      values.push(r.value);
    }
    return { ok: true, value: values };
  }
};
function parseResultChain(node) {
  const steps = [];
  let current = node;
  const validMethods = [
    "map",
    "mapErr",
    "flatMap",
    "unwrapOr",
    "unwrap",
    "unwrapErr",
    "match",
    "and",
    "or",
    "tap",
    "tapErr",
    "isOk",
    "isErr"
  ];
  while (ts2.isCallExpression(current)) {
    const expr = current.expression;
    if (!ts2.isPropertyAccessExpression(expr)) break;
    const methodName = expr.name.text;
    if (!validMethods.includes(methodName)) break;
    steps.unshift({
      kind: methodName,
      args: current.arguments
    });
    current = expr.expression;
  }
  if (ts2.isCallExpression(current)) {
    const expr = current.expression;
    if (ts2.isPropertyAccessExpression(expr) && ts2.isIdentifier(expr.expression) && expr.expression.text === "Result") {
      const method = expr.name.text;
      if (method === "ok" || method === "err" || method === "try") {
        steps.unshift({
          kind: method,
          args: current.arguments
        });
        return { root: current, steps };
      }
    }
  }
  if (steps.length === 0) return null;
  return { root: current, steps };
}
function expandResultChain(ctx, chain) {
  const factory = ctx.factory;
  function okObj(value) {
    return factory.createObjectLiteralExpression([
      factory.createPropertyAssignment("ok", factory.createTrue()),
      factory.createPropertyAssignment("value", value)
    ]);
  }
  function errObj(error) {
    return factory.createObjectLiteralExpression([
      factory.createPropertyAssignment("ok", factory.createFalse()),
      factory.createPropertyAssignment("error", error)
    ]);
  }
  function okCheck(result, thenExpr, elseExpr) {
    return factory.createConditionalExpression(
      factory.createPropertyAccessExpression(result, "ok"),
      factory.createToken(ts2.SyntaxKind.QuestionToken),
      thenExpr,
      factory.createToken(ts2.SyntaxKind.ColonToken),
      elseExpr
    );
  }
  let currentExpr = null;
  for (const step of chain.steps) {
    switch (step.kind) {
      case "ok": {
        currentExpr = okObj(step.args[0]);
        break;
      }
      case "err": {
        currentExpr = errObj(step.args[0]);
        break;
      }
      case "try": {
        const fn = step.args[0];
        const tempErr = ctx.generateUniqueName("__e");
        currentExpr = factory.createCallExpression(
          factory.createParenthesizedExpression(
            factory.createArrowFunction(
              void 0,
              void 0,
              [],
              void 0,
              factory.createToken(ts2.SyntaxKind.EqualsGreaterThanToken),
              factory.createBlock([
                factory.createTryStatement(
                  factory.createBlock([
                    factory.createReturnStatement(
                      okObj(factory.createCallExpression(fn, void 0, []))
                    )
                  ]),
                  factory.createCatchClause(
                    factory.createVariableDeclaration(tempErr),
                    factory.createBlock([
                      factory.createReturnStatement(errObj(tempErr))
                    ])
                  ),
                  void 0
                )
              ])
            )
          ),
          void 0,
          []
        );
        break;
      }
      case "map": {
        const fn = step.args[0];
        const prev = currentExpr;
        const valueAccess = factory.createPropertyAccessExpression(
          prev,
          "value"
        );
        const mapped = factory.createCallExpression(fn, void 0, [
          valueAccess
        ]);
        currentExpr = okCheck(prev, okObj(mapped), prev);
        break;
      }
      case "mapErr": {
        const fn = step.args[0];
        const prev = currentExpr;
        const errorAccess = factory.createPropertyAccessExpression(
          prev,
          "error"
        );
        const mapped = factory.createCallExpression(fn, void 0, [
          errorAccess
        ]);
        currentExpr = okCheck(prev, prev, errObj(mapped));
        break;
      }
      case "flatMap": {
        const fn = step.args[0];
        const prev = currentExpr;
        const valueAccess = factory.createPropertyAccessExpression(
          prev,
          "value"
        );
        const chained = factory.createCallExpression(fn, void 0, [
          valueAccess
        ]);
        currentExpr = okCheck(prev, chained, prev);
        break;
      }
      case "unwrapOr": {
        const defaultVal = step.args[0];
        const prev = currentExpr;
        const valueAccess = factory.createPropertyAccessExpression(
          prev,
          "value"
        );
        currentExpr = okCheck(prev, valueAccess, defaultVal);
        break;
      }
      case "unwrap": {
        const prev = currentExpr;
        const valueAccess = factory.createPropertyAccessExpression(
          prev,
          "value"
        );
        currentExpr = okCheck(
          prev,
          valueAccess,
          factory.createCallExpression(
            factory.createParenthesizedExpression(
              factory.createArrowFunction(
                void 0,
                void 0,
                [],
                void 0,
                factory.createToken(ts2.SyntaxKind.EqualsGreaterThanToken),
                factory.createBlock([
                  factory.createThrowStatement(
                    factory.createPropertyAccessExpression(prev, "error")
                  )
                ])
              )
            ),
            void 0,
            []
          )
        );
        break;
      }
      case "unwrapErr": {
        const prev = currentExpr;
        const errorAccess = factory.createPropertyAccessExpression(
          prev,
          "error"
        );
        currentExpr = okCheck(
          prev,
          factory.createCallExpression(
            factory.createParenthesizedExpression(
              factory.createArrowFunction(
                void 0,
                void 0,
                [],
                void 0,
                factory.createToken(ts2.SyntaxKind.EqualsGreaterThanToken),
                factory.createBlock([
                  factory.createThrowStatement(
                    factory.createNewExpression(
                      factory.createIdentifier("Error"),
                      void 0,
                      [factory.createStringLiteral("Called unwrapErr() on Ok")]
                    )
                  )
                ])
              )
            ),
            void 0,
            []
          ),
          errorAccess
        );
        break;
      }
      case "match": {
        const prev = currentExpr;
        if (step.args.length === 2) {
          const okFn = step.args[0];
          const errFn = step.args[1];
          const valueAccess = factory.createPropertyAccessExpression(
            prev,
            "value"
          );
          const errorAccess = factory.createPropertyAccessExpression(
            prev,
            "error"
          );
          currentExpr = okCheck(
            prev,
            factory.createCallExpression(okFn, void 0, [valueAccess]),
            factory.createCallExpression(errFn, void 0, [errorAccess])
          );
        } else if (step.args.length === 1 && ts2.isObjectLiteralExpression(step.args[0])) {
          const obj = step.args[0];
          let okFn;
          let errFn;
          for (const prop of obj.properties) {
            if (ts2.isPropertyAssignment(prop) && ts2.isIdentifier(prop.name)) {
              if (prop.name.text === "ok") okFn = prop.initializer;
              if (prop.name.text === "err") errFn = prop.initializer;
            }
          }
          if (okFn && errFn) {
            const valueAccess = factory.createPropertyAccessExpression(
              prev,
              "value"
            );
            const errorAccess = factory.createPropertyAccessExpression(
              prev,
              "error"
            );
            currentExpr = okCheck(
              prev,
              factory.createCallExpression(okFn, void 0, [valueAccess]),
              factory.createCallExpression(errFn, void 0, [errorAccess])
            );
          }
        }
        break;
      }
      case "and": {
        const other = step.args[0];
        const prev = currentExpr;
        currentExpr = okCheck(prev, other, prev);
        break;
      }
      case "or": {
        const other = step.args[0];
        const prev = currentExpr;
        currentExpr = okCheck(prev, prev, other);
        break;
      }
      case "tap": {
        const fn = step.args[0];
        const prev = currentExpr;
        const valueAccess = factory.createPropertyAccessExpression(
          prev,
          "value"
        );
        currentExpr = factory.createParenthesizedExpression(
          factory.createCommaListExpression([
            factory.createBinaryExpression(
              factory.createPropertyAccessExpression(prev, "ok"),
              factory.createToken(ts2.SyntaxKind.AmpersandAmpersandToken),
              factory.createCallExpression(fn, void 0, [valueAccess])
            ),
            prev
          ])
        );
        break;
      }
      case "tapErr": {
        const fn = step.args[0];
        const prev = currentExpr;
        const errorAccess = factory.createPropertyAccessExpression(
          prev,
          "error"
        );
        currentExpr = factory.createParenthesizedExpression(
          factory.createCommaListExpression([
            factory.createBinaryExpression(
              factory.createPrefixUnaryExpression(
                ts2.SyntaxKind.ExclamationToken,
                factory.createPropertyAccessExpression(prev, "ok")
              ),
              factory.createToken(ts2.SyntaxKind.AmpersandAmpersandToken),
              factory.createCallExpression(fn, void 0, [errorAccess])
            ),
            prev
          ])
        );
        break;
      }
      case "isOk": {
        const prev = currentExpr;
        currentExpr = factory.createPropertyAccessExpression(prev, "ok");
        break;
      }
      case "isErr": {
        const prev = currentExpr;
        currentExpr = factory.createPrefixUnaryExpression(
          ts2.SyntaxKind.ExclamationToken,
          factory.createPropertyAccessExpression(prev, "ok")
        );
        break;
      }
    }
  }
  return currentExpr ?? chain.root;
}
var resultMacro = defineExpressionMacro2({
  name: "Result",
  description: "Zero-cost Result type \u2014 compiles method chains to inlined ok/error checks",
  expand(ctx, callExpr, args) {
    const chain = parseResultChain(callExpr);
    if (chain) {
      return expandResultChain(ctx, chain);
    }
    const expr = callExpr.expression;
    if (ts2.isPropertyAccessExpression(expr) && ts2.isIdentifier(expr.expression) && expr.expression.text === "Result") {
      const method = expr.name.text;
      const factory = ctx.factory;
      if (method === "ok" && args.length === 1) {
        return factory.createObjectLiteralExpression([
          factory.createPropertyAssignment("ok", factory.createTrue()),
          factory.createPropertyAssignment("value", args[0])
        ]);
      }
      if (method === "err" && args.length === 1) {
        return factory.createObjectLiteralExpression([
          factory.createPropertyAssignment("ok", factory.createFalse()),
          factory.createPropertyAssignment("error", args[0])
        ]);
      }
      if (method === "isOk" && args.length === 1) {
        return factory.createPropertyAccessExpression(args[0], "ok");
      }
      if (method === "isErr" && args.length === 1) {
        return factory.createPrefixUnaryExpression(
          ts2.SyntaxKind.ExclamationToken,
          factory.createPropertyAccessExpression(args[0], "ok")
        );
      }
    }
    return callExpr;
  }
});
globalRegistry2.register(resultMacro);

// src/newtype.ts
import * as ts3 from "typescript";
import { defineExpressionMacro as defineExpressionMacro3, globalRegistry as globalRegistry3 } from "@typemacro/core";
function wrap(value) {
  return value;
}
function unwrap(value) {
  return value;
}
function newtypeCtor() {
  return (value) => value;
}
function validatedNewtype(validate, errorMessage) {
  return (value) => {
    if (!validate(value)) {
      throw new Error(errorMessage ?? `Invalid value for newtype: ${value}`);
    }
    return value;
  };
}
var wrapMacro = defineExpressionMacro3({
  name: "wrap",
  description: "Zero-cost newtype wrap \u2014 compiles away to the raw value",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "wrap() expects exactly one argument");
      return callExpr;
    }
    return args[0];
  }
});
var unwrapMacro = defineExpressionMacro3({
  name: "unwrap",
  description: "Zero-cost newtype unwrap \u2014 compiles away to the raw value",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "unwrap() expects exactly one argument");
      return callExpr;
    }
    return args[0];
  }
});
var newtypeCtorMacro = defineExpressionMacro3({
  name: "newtypeCtor",
  description: "Zero-cost newtype constructor factory \u2014 the returned function compiles to identity",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const param = factory.createParameterDeclaration(
      void 0,
      void 0,
      factory.createIdentifier("__v")
    );
    return factory.createArrowFunction(
      void 0,
      void 0,
      [param],
      void 0,
      factory.createToken(ts3.SyntaxKind.EqualsGreaterThanToken),
      factory.createIdentifier("__v")
    );
  }
});
globalRegistry3.register(wrapMacro);
globalRegistry3.register(unwrapMacro);

// src/pipe.ts
import * as ts4 from "typescript";
import { defineExpressionMacro as defineExpressionMacro4, globalRegistry as globalRegistry4 } from "@typemacro/core";
function pipe(value, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), value);
}
function flow(...fns) {
  return (x) => fns.reduce((acc, fn) => fn(acc), x);
}
var pipeMacro = defineExpressionMacro4({
  name: "pipe",
  description: "Zero-cost pipe \u2014 inlines function composition into nested calls",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length === 0) {
      ctx.reportError(callExpr, "pipe() requires at least one argument");
      return callExpr;
    }
    if (args.length === 1) {
      return args[0];
    }
    let result = args[0];
    for (let i = 1; i < args.length; i++) {
      result = factory.createCallExpression(args[i], void 0, [result]);
    }
    return result;
  }
});
var flowMacro = defineExpressionMacro4({
  name: "flow",
  description: "Zero-cost flow \u2014 composes functions into a single inlined arrow function",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length === 0) {
      ctx.reportError(callExpr, "flow() requires at least one function");
      return callExpr;
    }
    if (args.length === 1) {
      return args[0];
    }
    const param = ctx.generateUniqueName("__x");
    let body = param;
    for (const fn of args) {
      body = factory.createCallExpression(fn, void 0, [body]);
    }
    return factory.createArrowFunction(
      void 0,
      void 0,
      [factory.createParameterDeclaration(void 0, void 0, param)],
      void 0,
      factory.createToken(ts4.SyntaxKind.EqualsGreaterThanToken),
      body
    );
  }
});
globalRegistry4.register(pipeMacro);
globalRegistry4.register(flowMacro);

// src/assert.ts
import * as ts5 from "typescript";
import { defineExpressionMacro as defineExpressionMacro5, globalRegistry as globalRegistry5 } from "@typemacro/core";
function staticAssert(_condition, _message) {
}
function typeAssert() {
}
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message ?? "Invariant violation");
  }
}
function unreachable(_value) {
  throw new Error("Unreachable code reached");
}
function debugOnly(fn) {
  fn();
}
function sizeof() {
  return 0;
}
var staticAssertMacro = defineExpressionMacro5({
  name: "staticAssert",
  description: "Compile-time assertion \u2014 completely erased from output",
  expand(ctx, callExpr, args) {
    if (args.length < 1) {
      ctx.reportError(callExpr, "staticAssert() requires a condition");
      return callExpr;
    }
    const conditionResult = ctx.evaluate(args[0]);
    if (conditionResult.kind === "boolean") {
      if (!conditionResult.value) {
        const message = args.length >= 2 ? (() => {
          const msgResult = ctx.evaluate(args[1]);
          return msgResult.kind === "string" ? msgResult.value : "Static assertion failed";
        })() : "Static assertion failed";
        ctx.reportError(callExpr, message);
      }
    }
    return ctx.factory.createVoidExpression(
      ctx.factory.createNumericLiteral(0)
    );
  }
});
var typeAssertMacro = defineExpressionMacro5({
  name: "typeAssert",
  description: "Compile-time type assertion \u2014 completely erased from output",
  expand(ctx, callExpr, _args) {
    return ctx.factory.createVoidExpression(
      ctx.factory.createNumericLiteral(0)
    );
  }
});
var invariantMacro = defineExpressionMacro5({
  name: "invariant",
  description: "Runtime invariant \u2014 compiles to a conditional throw (strippable in prod)",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length < 1) {
      ctx.reportError(callExpr, "invariant() requires a condition");
      return callExpr;
    }
    const condition = args[0];
    const message = args.length >= 2 ? args[1] : factory.createStringLiteral("Invariant violation");
    return factory.createBinaryExpression(
      condition,
      factory.createToken(ts5.SyntaxKind.BarBarToken),
      factory.createCallExpression(
        factory.createParenthesizedExpression(
          factory.createArrowFunction(
            void 0,
            void 0,
            [],
            void 0,
            factory.createToken(ts5.SyntaxKind.EqualsGreaterThanToken),
            factory.createBlock([
              factory.createThrowStatement(
                factory.createNewExpression(
                  factory.createIdentifier("Error"),
                  void 0,
                  [message]
                )
              )
            ])
          )
        ),
        void 0,
        []
      )
    );
  }
});
var unreachableMacro = defineExpressionMacro5({
  name: "unreachable",
  description: "Marks unreachable code \u2014 compiles to throw",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    return factory.createCallExpression(
      factory.createParenthesizedExpression(
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts5.SyntaxKind.EqualsGreaterThanToken),
          factory.createBlock([
            factory.createThrowStatement(
              factory.createNewExpression(
                factory.createIdentifier("Error"),
                void 0,
                [factory.createStringLiteral("Unreachable code reached")]
              )
            )
          ])
        )
      ),
      void 0,
      []
    );
  }
});
var debugOnlyMacro = defineExpressionMacro5({
  name: "debugOnly",
  description: "Dev-only code block \u2014 inlined in dev, completely erased in prod",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1) {
      ctx.reportError(callExpr, "debugOnly() expects exactly one function");
      return callExpr;
    }
    const fn = args[0];
    return factory.createCallExpression(fn, void 0, []);
  }
});
var sizeofMacro = defineExpressionMacro5({
  name: "sizeof",
  description: "Compile-time sizeof \u2014 returns number of properties on a type as a literal",
  expand(ctx, callExpr, _args) {
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "sizeof<T>() requires exactly one type argument"
      );
      return callExpr;
    }
    const typeNode = typeArgs[0];
    const type = ctx.typeChecker.getTypeFromTypeNode(typeNode);
    const properties = type.getProperties();
    return ctx.factory.createNumericLiteral(properties.length);
  }
});
globalRegistry5.register(staticAssertMacro);
globalRegistry5.register(typeAssertMacro);
globalRegistry5.register(invariantMacro);
globalRegistry5.register(unreachableMacro);
globalRegistry5.register(debugOnlyMacro);
globalRegistry5.register(sizeofMacro);

// src/match.ts
import * as ts6 from "typescript";
import { defineExpressionMacro as defineExpressionMacro6, globalRegistry as globalRegistry6 } from "@typemacro/core";
function match(value, handlers, discriminant) {
  const key = discriminant ?? "kind";
  const tag = value[key];
  const handler = handlers[tag];
  if (!handler) {
    throw new Error(`No handler for discriminant: ${String(tag)}`);
  }
  return handler(value);
}
function matchLiteral(value, handlers) {
  const handler = handlers[value];
  if (handler) return handler();
  const wildcard = handlers["_"];
  if (wildcard) return wildcard();
  throw new Error(`No handler for value: ${value}`);
}
function matchGuard(value, arms) {
  for (const [pred, handler] of arms) {
    if (pred(value)) return handler(value);
  }
  throw new Error("No matching guard");
}
var matchMacro = defineExpressionMacro6({
  name: "match",
  description: "Zero-cost pattern matching \u2014 compiles to inlined if/else chains",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length < 2) {
      ctx.reportError(
        callExpr,
        "match() requires a value and a handlers object"
      );
      return callExpr;
    }
    const value = args[0];
    const handlersArg = args[1];
    const discriminant = args.length >= 3 ? args[2] : void 0;
    let keyName = "kind";
    if (discriminant && ts6.isStringLiteral(discriminant)) {
      keyName = discriminant.text;
    }
    if (!ts6.isObjectLiteralExpression(handlersArg)) {
      ctx.reportError(
        handlersArg,
        "match() handlers must be an object literal for compile-time expansion"
      );
      return callExpr;
    }
    const properties = handlersArg.properties.filter(
      (p) => ts6.isPropertyAssignment(p)
    );
    if (properties.length === 0) {
      ctx.reportError(handlersArg, "match() handlers object is empty");
      return callExpr;
    }
    let result = factory.createCallExpression(
      factory.createParenthesizedExpression(
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts6.SyntaxKind.EqualsGreaterThanToken),
          factory.createBlock([
            factory.createThrowStatement(
              factory.createNewExpression(
                factory.createIdentifier("Error"),
                void 0,
                [factory.createStringLiteral("Non-exhaustive match")]
              )
            )
          ])
        )
      ),
      void 0,
      []
    );
    for (let i = properties.length - 1; i >= 0; i--) {
      const prop = properties[i];
      const propName = ts6.isIdentifier(prop.name) ? prop.name.text : ts6.isStringLiteral(prop.name) ? prop.name.text : null;
      if (!propName) continue;
      const handler = prop.initializer;
      if (propName === "_") {
        if (ts6.isArrowFunction(handler) && !ts6.isBlock(handler.body)) {
          result = handler.parameters.length === 0 ? handler.body : factory.createCallExpression(handler, void 0, [value]);
        } else {
          result = factory.createCallExpression(handler, void 0, [value]);
        }
        continue;
      }
      const condition = factory.createBinaryExpression(
        factory.createPropertyAccessExpression(value, keyName),
        factory.createToken(ts6.SyntaxKind.EqualsEqualsEqualsToken),
        factory.createStringLiteral(propName)
      );
      const thenExpr = factory.createCallExpression(handler, void 0, [
        value
      ]);
      result = factory.createConditionalExpression(
        condition,
        factory.createToken(ts6.SyntaxKind.QuestionToken),
        thenExpr,
        factory.createToken(ts6.SyntaxKind.ColonToken),
        result
      );
    }
    return result;
  }
});
var matchLiteralMacro = defineExpressionMacro6({
  name: "matchLiteral",
  description: "Zero-cost literal matching \u2014 compiles to inlined equality checks",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 2) {
      ctx.reportError(
        callExpr,
        "matchLiteral() requires a value and a handlers object"
      );
      return callExpr;
    }
    const value = args[0];
    const handlersArg = args[1];
    if (!ts6.isObjectLiteralExpression(handlersArg)) {
      ctx.reportError(
        handlersArg,
        "matchLiteral() handlers must be an object literal"
      );
      return callExpr;
    }
    const properties = handlersArg.properties.filter(
      (p) => ts6.isPropertyAssignment(p)
    );
    let wildcardHandler;
    const cases = [];
    for (const prop of properties) {
      const propName = ts6.isIdentifier(prop.name) ? prop.name.text : ts6.isStringLiteral(prop.name) ? prop.name.text : ts6.isNumericLiteral(prop.name) ? prop.name.text : null;
      if (!propName) continue;
      if (propName === "_") {
        wildcardHandler = prop.initializer;
        continue;
      }
      const num = Number(propName);
      const literal = !isNaN(num) ? factory.createNumericLiteral(num) : factory.createStringLiteral(propName);
      cases.push({ literal, handler: prop.initializer });
    }
    let result;
    if (wildcardHandler) {
      result = factory.createCallExpression(wildcardHandler, void 0, []);
    } else {
      result = factory.createCallExpression(
        factory.createParenthesizedExpression(
          factory.createArrowFunction(
            void 0,
            void 0,
            [],
            void 0,
            factory.createToken(ts6.SyntaxKind.EqualsGreaterThanToken),
            factory.createBlock([
              factory.createThrowStatement(
                factory.createNewExpression(
                  factory.createIdentifier("Error"),
                  void 0,
                  [factory.createStringLiteral("Non-exhaustive matchLiteral")]
                )
              )
            ])
          )
        ),
        void 0,
        []
      );
    }
    for (let i = cases.length - 1; i >= 0; i--) {
      const { literal, handler } = cases[i];
      const condition = factory.createBinaryExpression(
        value,
        factory.createToken(ts6.SyntaxKind.EqualsEqualsEqualsToken),
        literal
      );
      const thenExpr = factory.createCallExpression(handler, void 0, []);
      result = factory.createConditionalExpression(
        condition,
        factory.createToken(ts6.SyntaxKind.QuestionToken),
        thenExpr,
        factory.createToken(ts6.SyntaxKind.ColonToken),
        result
      );
    }
    return result;
  }
});
var matchGuardMacro = defineExpressionMacro6({
  name: "matchGuard",
  description: "Zero-cost guard matching \u2014 compiles to inlined predicate checks",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 2) {
      ctx.reportError(
        callExpr,
        "matchGuard() requires a value and an array of guard arms"
      );
      return callExpr;
    }
    const value = args[0];
    const armsArg = args[1];
    if (!ts6.isArrayLiteralExpression(armsArg)) {
      ctx.reportError(armsArg, "matchGuard() arms must be an array literal");
      return callExpr;
    }
    const arms = [];
    for (const element of armsArg.elements) {
      if (!ts6.isArrayLiteralExpression(element) || element.elements.length !== 2) {
        ctx.reportError(
          element,
          "Each matchGuard arm must be a [predicate, handler] tuple"
        );
        continue;
      }
      arms.push({
        predicate: element.elements[0],
        handler: element.elements[1]
      });
    }
    if (arms.length === 0) {
      ctx.reportError(armsArg, "matchGuard() requires at least one arm");
      return callExpr;
    }
    let result = factory.createCallExpression(
      factory.createParenthesizedExpression(
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts6.SyntaxKind.EqualsGreaterThanToken),
          factory.createBlock([
            factory.createThrowStatement(
              factory.createNewExpression(
                factory.createIdentifier("Error"),
                void 0,
                [
                  factory.createStringLiteral(
                    "No matching guard in matchGuard"
                  )
                ]
              )
            )
          ])
        )
      ),
      void 0,
      []
    );
    for (let i = arms.length - 1; i >= 0; i--) {
      const { predicate, handler } = arms[i];
      const condition = factory.createCallExpression(predicate, void 0, [
        value
      ]);
      const thenExpr = factory.createCallExpression(handler, void 0, [
        value
      ]);
      result = factory.createConditionalExpression(
        condition,
        factory.createToken(ts6.SyntaxKind.QuestionToken),
        thenExpr,
        factory.createToken(ts6.SyntaxKind.ColonToken),
        result
      );
    }
    return result;
  }
});
globalRegistry6.register(matchMacro);
globalRegistry6.register(matchLiteralMacro);
globalRegistry6.register(matchGuardMacro);
export {
  Option,
  Result,
  debugOnly,
  debugOnlyMacro,
  flow,
  flowMacro,
  invariant,
  invariantMacro,
  match,
  matchGuard,
  matchGuardMacro,
  matchLiteral,
  matchLiteralMacro,
  matchMacro,
  newtypeCtor,
  newtypeCtorMacro,
  optionMacro,
  pipe,
  pipeMacro,
  resultMacro,
  sizeof,
  sizeofMacro,
  staticAssert,
  staticAssertMacro,
  typeAssert,
  typeAssertMacro,
  unreachable,
  unreachableMacro,
  unwrap,
  unwrapMacro,
  validatedNewtype,
  wrap,
  wrapMacro
};
//# sourceMappingURL=index.js.map