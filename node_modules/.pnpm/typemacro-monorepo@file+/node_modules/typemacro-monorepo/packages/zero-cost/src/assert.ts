/**
 * Zero-Cost Compile-Time Assertions and Invariants
 *
 * Provides compile-time checks that either:
 * 1. Disappear completely in production (staticAssert, typeAssert)
 * 2. Compile to minimal runtime checks (invariant, unreachable)
 *
 * Inspired by Rust's compile_error!, static_assert, unreachable!, and C++'s static_assert.
 *
 * @example
 * ```typescript
 * // staticAssert — evaluates condition at compile time, emits nothing
 * staticAssert(sizeof<User>() <= 1024, "User struct too large");
 * // Compiled output: (nothing — completely erased)
 *
 * // typeAssert — compile-time type relationship check
 * typeAssert<Extends<Dog, Animal>>();
 * typeAssert<Equals<Option<number>, number | null>>();
 * // Compiled output: (nothing)
 *
 * // invariant — kept in dev, stripped in prod
 * invariant(users.length > 0, "Expected at least one user");
 * // Dev output:  if (!(users.length > 0)) throw new Error("Expected at least one user");
 * // Prod output: (nothing)
 *
 * // unreachable — marks code paths that should never execute
 * switch (shape.kind) {
 *   case "circle": return circleArea(shape);
 *   case "square": return squareArea(shape);
 *   default: unreachable(shape); // Compile error if shape isn't exhausted
 * }
 * // Compiled output: throw new Error("Unreachable")
 *
 * // debugOnly — wraps code that should only run in development
 * debugOnly(() => {
 *   console.log("Debug info:", state);
 *   validateInternalState(state);
 * });
 * // Dev output:  (() => { console.log(...); validateInternalState(state); })()
 * // Prod output: (nothing)
 * ```
 */

import * as ts from "typescript";
import { defineExpressionMacro, globalRegistry, MacroContext } from "@typemacro/core";

// ============================================================================
// Type-Level API
// ============================================================================

/** Compile-time type equality check */
export type Equals<A, B> = [A] extends [B]
  ? [B] extends [A]
    ? true
    : false
  : false;

/** Compile-time subtype check */
export type Extends<A, B> = A extends B ? true : false;

/** Compile-time "not" */
export type Not<T extends boolean> = T extends true ? false : true;

/** Compile-time "and" */
export type And<A extends boolean, B extends boolean> = A extends true
  ? B extends true
    ? true
    : false
  : false;

/** Compile-time "or" */
export type Or<A extends boolean, B extends boolean> = A extends true
  ? true
  : B extends true
    ? true
    : false;

/**
 * Assert a condition at compile time. Completely erased from output.
 * If the condition is false, emits a compile error.
 */
export function staticAssert(_condition: true, _message?: string): void {}

/**
 * Assert a type-level predicate. Completely erased from output.
 * Usage: typeAssert<Equals<A, B>>()
 */
export function typeAssert<_T extends true>(): void {}

/**
 * Runtime invariant check. Stripped in production builds.
 */
export function invariant(
  condition: boolean,
  message?: string,
): asserts condition {
  if (!condition) {
    throw new Error(message ?? "Invariant violation");
  }
}

/**
 * Mark a code path as unreachable. Useful for exhaustiveness checking.
 * At runtime, throws if somehow reached.
 */
export function unreachable(_value?: never): never {
  throw new Error("Unreachable code reached");
}

/**
 * Code that only runs in development. Completely erased in production.
 */
export function debugOnly(fn: () => void): void {
  fn();
}

/**
 * Compile-time sizeof — returns the number of properties on a type.
 * Useful for compile-time assertions about type size.
 */
export function sizeof<_T>(): number {
  return 0; // Replaced by macro
}

// ============================================================================
// Macros
// ============================================================================

export const staticAssertMacro = defineExpressionMacro({
  name: "staticAssert",
  description: "Compile-time assertion — completely erased from output",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    if (args.length < 1) {
      ctx.reportError(callExpr, "staticAssert() requires a condition");
      return callExpr;
    }

    // Try to evaluate the condition at compile time
    const conditionResult = ctx.evaluate(args[0]);

    if (conditionResult.kind === "boolean") {
      if (!conditionResult.value) {
        const message =
          args.length >= 2
            ? (() => {
                const msgResult = ctx.evaluate(args[1]);
                return msgResult.kind === "string"
                  ? msgResult.value
                  : "Static assertion failed";
              })()
            : "Static assertion failed";
        ctx.reportError(callExpr, message);
      }
    }

    // Erase completely — replace with void 0
    return ctx.factory.createVoidExpression(
      ctx.factory.createNumericLiteral(0),
    );
  },
});

export const typeAssertMacro = defineExpressionMacro({
  name: "typeAssert",
  description: "Compile-time type assertion — completely erased from output",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    _args: readonly ts.Expression[],
  ): ts.Expression {
    // Type assertions are checked by the type system itself.
    // The macro just erases the call.
    // If typeAssert<false>() is written, TypeScript will already error
    // because `false` doesn't extend `true`.
    return ctx.factory.createVoidExpression(
      ctx.factory.createNumericLiteral(0),
    );
  },
});

export const invariantMacro = defineExpressionMacro({
  name: "invariant",
  description:
    "Runtime invariant — compiles to a conditional throw (strippable in prod)",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    const factory = ctx.factory;

    if (args.length < 1) {
      ctx.reportError(callExpr, "invariant() requires a condition");
      return callExpr;
    }

    const condition = args[0];
    const message =
      args.length >= 2
        ? args[1]
        : factory.createStringLiteral("Invariant violation");

    // Compile to: condition || (() => { throw new Error(message); })()
    return factory.createBinaryExpression(
      condition,
      factory.createToken(ts.SyntaxKind.BarBarToken),
      factory.createCallExpression(
        factory.createParenthesizedExpression(
          factory.createArrowFunction(
            undefined,
            undefined,
            [],
            undefined,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            factory.createBlock([
              factory.createThrowStatement(
                factory.createNewExpression(
                  factory.createIdentifier("Error"),
                  undefined,
                  [message],
                ),
              ),
            ]),
          ),
        ),
        undefined,
        [],
      ),
    );
  },
});

export const unreachableMacro = defineExpressionMacro({
  name: "unreachable",
  description: "Marks unreachable code — compiles to throw",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    _args: readonly ts.Expression[],
  ): ts.Expression {
    const factory = ctx.factory;

    // Compile to an IIFE that throws
    return factory.createCallExpression(
      factory.createParenthesizedExpression(
        factory.createArrowFunction(
          undefined,
          undefined,
          [],
          undefined,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          factory.createBlock([
            factory.createThrowStatement(
              factory.createNewExpression(
                factory.createIdentifier("Error"),
                undefined,
                [factory.createStringLiteral("Unreachable code reached")],
              ),
            ),
          ]),
        ),
      ),
      undefined,
      [],
    );
  },
});

export const debugOnlyMacro = defineExpressionMacro({
  name: "debugOnly",
  description:
    "Dev-only code block — inlined in dev, completely erased in prod",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    const factory = ctx.factory;

    if (args.length !== 1) {
      ctx.reportError(callExpr, "debugOnly() expects exactly one function");
      return callExpr;
    }

    // In dev mode: inline the function call
    // In prod mode: erase completely (void 0)
    // For now, we always inline — a production flag would control this
    const fn = args[0];
    return factory.createCallExpression(fn, undefined, []);
  },
});

export const sizeofMacro = defineExpressionMacro({
  name: "sizeof",
  description:
    "Compile-time sizeof — returns number of properties on a type as a literal",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    _args: readonly ts.Expression[],
  ): ts.Expression {
    // Get the type argument
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "sizeof<T>() requires exactly one type argument",
      );
      return callExpr;
    }

    const typeNode = typeArgs[0];
    const type = ctx.typeChecker.getTypeFromTypeNode(typeNode);
    const properties = type.getProperties();

    return ctx.factory.createNumericLiteral(properties.length);
  },
});

globalRegistry.register(staticAssertMacro);
globalRegistry.register(typeAssertMacro);
globalRegistry.register(invariantMacro);
globalRegistry.register(unreachableMacro);
globalRegistry.register(debugOnlyMacro);
globalRegistry.register(sizeofMacro);
