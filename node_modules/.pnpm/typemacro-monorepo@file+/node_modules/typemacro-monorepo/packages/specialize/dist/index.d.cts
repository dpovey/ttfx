import * as _typemacro_core from '@typemacro/core';

/**
 * Specialize Macros - Zero-cost typeclass specialization
 *
 * Provides compile-time specialization of generic functions to eliminate
 * runtime typeclass dictionary passing overhead. Similar to GHC's specialization
 * pragmas or Rust's monomorphization.
 *
 * Usage:
 *   // Define a generic function using typeclass constraints
 *   function sortWith<T>(items: T[], ord: Ord<T>): T[] { ... }
 *
 *   // Create a specialized version for numbers at compile time
 *   const sortNumbers = specialize(sortWith, [numberOrd]);
 *   // sortNumbers is: (items: number[]) => number[]
 *
 *   // Or use specialize$ for inline specialization
 *   const sorted = specialize$(sortWith(items, numberOrd));
 */
declare const specializeMacro: _typemacro_core.ExpressionMacro;
declare const specializeInlineMacro: _typemacro_core.ExpressionMacro;
declare const monoMacro: _typemacro_core.ExpressionMacro;
declare const inlineCallMacro: _typemacro_core.ExpressionMacro;
/**
 * Register macros with the global registry.
 * Call this function to enable specialization macros in your project.
 */
declare function register(): void;

export { inlineCallMacro, monoMacro, register, specializeInlineMacro, specializeMacro };
