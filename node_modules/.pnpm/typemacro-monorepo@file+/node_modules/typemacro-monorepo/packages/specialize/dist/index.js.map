{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Specialize Macros - Zero-cost typeclass specialization\n *\n * Provides compile-time specialization of generic functions to eliminate\n * runtime typeclass dictionary passing overhead. Similar to GHC's specialization\n * pragmas or Rust's monomorphization.\n *\n * Usage:\n *   // Define a generic function using typeclass constraints\n *   function sortWith<T>(items: T[], ord: Ord<T>): T[] { ... }\n *\n *   // Create a specialized version for numbers at compile time\n *   const sortNumbers = specialize(sortWith, [numberOrd]);\n *   // sortNumbers is: (items: number[]) => number[]\n *\n *   // Or use specialize$ for inline specialization\n *   const sorted = specialize$(sortWith(items, numberOrd));\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  globalRegistry,\n  MacroContext,\n} from \"@typemacro/core\";\n\n// ============================================================================\n// specialize() - Create specialized function at compile time\n// ============================================================================\n\nexport const specializeMacro = defineExpressionMacro({\n  name: \"specialize\",\n  module: \"@typemacro/specialize\",\n  description: \"Create a specialized version of a generic function\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 2) {\n      ctx.reportError(\n        callExpr,\n        \"specialize() requires a function and an array of typeclass instances\",\n      );\n      return callExpr;\n    }\n\n    const fnExpr = args[0];\n    const instancesArg = args[1];\n\n    // Validate that instancesArg is an array literal\n    if (!ts.isArrayLiteralExpression(instancesArg)) {\n      ctx.reportError(\n        callExpr,\n        \"specialize() second argument must be an array literal of typeclass instances\",\n      );\n      return callExpr;\n    }\n\n    const instances = instancesArg.elements;\n\n    // Get the function type to understand its signature\n    const fnType = ctx.getTypeOf(fnExpr);\n    const callSignatures = fnType.getCallSignatures();\n\n    if (callSignatures.length === 0) {\n      ctx.reportError(callExpr, \"specialize() first argument must be callable\");\n      return callExpr;\n    }\n\n    const signature = callSignatures[0];\n    const params = signature.getParameters();\n\n    // Find which parameters are typeclass instances (last N parameters)\n    // and which are \"real\" parameters\n    const numInstances = instances.length;\n    const realParamCount = params.length - numInstances;\n\n    if (realParamCount < 0) {\n      ctx.reportError(\n        callExpr,\n        `specialize() provided ${numInstances} instances but function only has ${params.length} parameters`,\n      );\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n\n    // Generate parameter names for the specialized function\n    const paramNames: ts.Identifier[] = [];\n    const paramDecls: ts.ParameterDeclaration[] = [];\n\n    for (let i = 0; i < realParamCount; i++) {\n      const paramSymbol = params[i];\n      const paramName = factory.createIdentifier(paramSymbol.getName());\n      paramNames.push(paramName);\n\n      // Get parameter type\n      const paramType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        paramSymbol,\n        callExpr,\n      );\n      const typeNode = ctx.typeChecker.typeToTypeNode(\n        paramType,\n        callExpr,\n        ts.NodeBuilderFlags.None,\n      );\n\n      paramDecls.push(\n        factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          paramName,\n          undefined,\n          typeNode,\n        ),\n      );\n    }\n\n    // Create the specialized function body:\n    // (...realParams) => fn(...realParams, ...instances)\n    const allArgs = [...paramNames, ...instances];\n\n    const body = factory.createCallExpression(fnExpr, undefined, allArgs);\n\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      paramDecls,\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      body,\n    );\n  },\n});\n\n// ============================================================================\n// specialize$() - Inline specialization for single call\n// ============================================================================\n\nexport const specializeInlineMacro = defineExpressionMacro({\n  name: \"specialize$\",\n  module: \"@typemacro/specialize\",\n  description: \"Inline a specialized function call\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"specialize$() requires exactly one function call expression\",\n      );\n      return callExpr;\n    }\n\n    const innerCall = args[0];\n\n    if (!ts.isCallExpression(innerCall)) {\n      ctx.reportError(\n        callExpr,\n        \"specialize$() argument must be a function call\",\n      );\n      return callExpr;\n    }\n\n    // Get the function being called\n    const fnExpr = innerCall.expression;\n    const fnType = ctx.getTypeOf(fnExpr);\n\n    // Check if it's a generic function\n    const callSignatures = fnType.getCallSignatures();\n    if (callSignatures.length === 0) {\n      // Not a function call, return as-is\n      return innerCall;\n    }\n\n    const signature = callSignatures[0];\n    const typeParams = signature.getTypeParameters();\n\n    if (!typeParams || typeParams.length === 0) {\n      // Not a generic function, no specialization needed\n      return innerCall;\n    }\n\n    // The function is generic. In a real implementation, we would:\n    // 1. Analyze the call arguments to determine concrete types\n    // 2. Inline the function body with those types\n    // 3. Perform constant folding and dead code elimination\n\n    // For now, we simply return the call as-is with a comment indicating\n    // it was processed. A full implementation would require access to\n    // the function body, which may be in a different file.\n\n    // Add a leading comment to indicate specialization was attempted\n    const factory = ctx.factory;\n\n    return factory.createCallExpression(\n      innerCall.expression,\n      innerCall.typeArguments,\n      innerCall.arguments.slice(),\n    );\n  },\n});\n\n// ============================================================================\n// mono() - Monomorphize a generic function for specific types\n// ============================================================================\n\nexport const monoMacro = defineExpressionMacro({\n  name: \"mono\",\n  module: \"@typemacro/specialize\",\n  description:\n    \"Monomorphize a generic function for specific type arguments\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"mono() requires exactly one function reference\",\n      );\n      return callExpr;\n    }\n\n    // mono<T1, T2>(fn) creates a specialized version with those type args\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length === 0) {\n      ctx.reportError(callExpr, \"mono<T1, ...>() requires type arguments\");\n      return callExpr;\n    }\n\n    const fnExpr = args[0];\n    const fnType = ctx.getTypeOf(fnExpr);\n    const callSignatures = fnType.getCallSignatures();\n\n    if (callSignatures.length === 0) {\n      ctx.reportError(callExpr, \"mono() argument must be a function\");\n      return callExpr;\n    }\n\n    const signature = callSignatures[0];\n    const params = signature.getParameters();\n\n    const factory = ctx.factory;\n\n    // Create a specialized wrapper that passes the type arguments\n    const paramDecls: ts.ParameterDeclaration[] = [];\n    const paramRefs: ts.Identifier[] = [];\n\n    for (const param of params) {\n      const name = factory.createIdentifier(param.getName());\n      paramRefs.push(name);\n\n      const paramType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        param,\n        callExpr,\n      );\n      const typeNode = ctx.typeChecker.typeToTypeNode(\n        paramType,\n        callExpr,\n        ts.NodeBuilderFlags.None,\n      );\n\n      paramDecls.push(\n        factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          name,\n          undefined,\n          typeNode,\n        ),\n      );\n    }\n\n    // Create: (...params) => fn<T1, T2>(...params)\n    const body = factory.createCallExpression(fnExpr, typeArgs, paramRefs);\n\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      paramDecls,\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      body,\n    );\n  },\n});\n\n// ============================================================================\n// inlineCall() - Inline a function call at compile time\n// ============================================================================\n\nexport const inlineCallMacro = defineExpressionMacro({\n  name: \"inlineCall\",\n  module: \"@typemacro/specialize\",\n  description: \"Attempt to inline a function call at compile time\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"inlineCall() requires exactly one function call\",\n      );\n      return callExpr;\n    }\n\n    const call = args[0];\n    if (!ts.isCallExpression(call)) {\n      ctx.reportError(\n        callExpr,\n        \"inlineCall() argument must be a function call\",\n      );\n      return callExpr;\n    }\n\n    // Get the function declaration if available\n    const fnExpr = call.expression;\n    const fnSymbol = ctx.typeChecker.getSymbolAtLocation(fnExpr);\n\n    if (!fnSymbol) {\n      // Can't resolve symbol, return call as-is\n      return call;\n    }\n\n    const declarations = fnSymbol.getDeclarations();\n    if (!declarations || declarations.length === 0) {\n      return call;\n    }\n\n    const fnDecl = declarations[0];\n\n    // Check if it's a simple function/arrow function we can inline\n    let body: ts.ConciseBody | undefined;\n    let fnParams: ts.NodeArray<ts.ParameterDeclaration> | undefined;\n\n    if (ts.isFunctionDeclaration(fnDecl) && fnDecl.body) {\n      body = fnDecl.body;\n      fnParams = fnDecl.parameters;\n    } else if (ts.isArrowFunction(fnDecl)) {\n      body = fnDecl.body;\n      fnParams = fnDecl.parameters;\n    } else if (\n      ts.isVariableDeclaration(fnDecl) &&\n      fnDecl.initializer &&\n      ts.isArrowFunction(fnDecl.initializer)\n    ) {\n      body = fnDecl.initializer.body;\n      fnParams = fnDecl.initializer.parameters;\n    }\n\n    if (!body || !fnParams) {\n      // Can't inline, return original call\n      return call;\n    }\n\n    // Simple case: arrow function with expression body\n    if (!ts.isBlock(body)) {\n      // Create an IIFE that substitutes arguments\n      // ((param1, param2, ...) => body)(arg1, arg2, ...)\n      const factory = ctx.factory;\n\n      // Clone parameters by recreating them\n      const clonedParams = fnParams.map((p) =>\n        factory.createParameterDeclaration(\n          undefined,\n          p.dotDotDotToken ? factory.createToken(ts.SyntaxKind.DotDotDotToken) : undefined,\n          ts.isIdentifier(p.name) ? factory.createIdentifier(p.name.text) : p.name,\n          p.questionToken ? factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,\n          p.type,\n          p.initializer,\n        ),\n      );\n\n      return factory.createCallExpression(\n        factory.createParenthesizedExpression(\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            clonedParams,\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            body, // Body is already an expression, can reuse\n          ),\n        ),\n        undefined,\n        call.arguments.slice(),\n      );\n    }\n\n    // For block bodies, check if it's a single return statement\n    if (body.statements.length === 1) {\n      const stmt = body.statements[0];\n      if (ts.isReturnStatement(stmt) && stmt.expression) {\n        const factory = ctx.factory;\n\n        // Clone parameters by recreating them\n        const clonedParams = fnParams.map((p) =>\n          factory.createParameterDeclaration(\n            undefined,\n            p.dotDotDotToken ? factory.createToken(ts.SyntaxKind.DotDotDotToken) : undefined,\n            ts.isIdentifier(p.name) ? factory.createIdentifier(p.name.text) : p.name,\n            p.questionToken ? factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,\n            p.type,\n            p.initializer,\n          ),\n        );\n\n        return factory.createCallExpression(\n          factory.createParenthesizedExpression(\n            factory.createArrowFunction(\n              undefined,\n              undefined,\n              clonedParams,\n              undefined,\n              factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n              stmt.expression, // Reuse the expression\n            ),\n          ),\n          undefined,\n          call.arguments.slice(),\n        );\n      }\n    }\n\n    // Complex body, can't inline easily\n    return call;\n  },\n});\n\n/**\n * Register macros with the global registry.\n * Call this function to enable specialization macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(specializeMacro);\n  globalRegistry.register(specializeInlineMacro);\n  globalRegistry.register(monoMacro);\n  globalRegistry.register(inlineCallMacro);\n}\n\n// Auto-register when this module is imported\nregister();\n"],"mappings":"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","names":[]}