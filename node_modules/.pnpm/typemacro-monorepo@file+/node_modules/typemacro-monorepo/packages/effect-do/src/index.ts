/**
 * @typemacro/effect-do - Effect Do-Comprehension Macros
 *
 * Provides Scala-style for-comprehension syntax for monadic types.
 * Works with Effect, Promise, Option, Either, and other flatMappable types.
 *
 * @example
 * ```typescript
 * // Generator-style syntax
 * const result = Do(function*() {
 *   const user = yield* fetchUser(id);
 *   const posts = yield* fetchPosts(user.id);
 *   const comments = yield* fetchComments(posts[0].id);
 *   return { user, posts, comments };
 * });
 *
 * // Transforms to:
 * const result = fetchUser(id).flatMap(user =>
 *   fetchPosts(user.id).flatMap(posts =>
 *     fetchComments(posts[0].id).map(comments =>
 *       ({ user, posts, comments })
 *     )
 *   )
 * );
 * ```
 */

import * as ts from "typescript";
import {
  defineExpressionMacro,
  globalRegistry,
  MacroContext,
} from "@typemacro/core";

// ============================================================================
// Monad Interface (for type documentation)
// ============================================================================

/**
 * Interface for types that support do-comprehension
 */
export interface Monad<A> {
  map<B>(f: (a: A) => B): Monad<B>;
  flatMap<B>(f: (a: A) => Monad<B>): Monad<B>;
}

// ============================================================================
// Do Macro
// ============================================================================

export const doMacro = defineExpressionMacro({
  name: "Do",
  description: "Transform generator-style code into flatMap chains",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "Do() expects exactly one generator function argument",
      );
      return callExpr;
    }

    const arg = args[0];

    // Must be a generator function
    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {
      ctx.reportError(
        callExpr,
        "Do() expects a generator function (function*() { ... })",
      );
      return callExpr;
    }

    if (!arg.body) {
      ctx.reportError(callExpr, "Do() generator function must have a body");
      return callExpr;
    }

    // Extract yield statements and transform to flatMap chain
    return transformGeneratorToFlatMap(ctx, arg.body);
  },
});

/**
 * Transform a generator function body into nested flatMap calls
 */
function transformGeneratorToFlatMap(
  ctx: MacroContext,
  body: ts.Block,
): ts.Expression {
  const factory = ctx.factory;
  const statements = Array.from(body.statements);

  // Find all yield* expressions and the final return
  const bindings: Array<{
    name: ts.Identifier;
    expression: ts.Expression;
  }> = [];
  let returnExpr: ts.Expression | undefined;

  for (const stmt of statements) {
    // Variable declaration with yield*
    if (ts.isVariableStatement(stmt)) {
      for (const decl of stmt.declarationList.declarations) {
        if (ts.isIdentifier(decl.name) && decl.initializer) {
          // Check for yield* expression
          if (
            ts.isYieldExpression(decl.initializer) &&
            decl.initializer.asteriskToken
          ) {
            if (decl.initializer.expression) {
              bindings.push({
                name: decl.name,
                expression: decl.initializer.expression,
              });
            }
          }
        }
      }
    }

    // Return statement
    if (ts.isReturnStatement(stmt) && stmt.expression) {
      returnExpr = stmt.expression;
    }
  }

  if (bindings.length === 0) {
    ctx.reportError(
      body,
      "Do() generator must have at least one yield* expression",
    );
    return factory.createIdentifier("undefined");
  }

  if (!returnExpr) {
    ctx.reportError(body, "Do() generator must have a return statement");
    return factory.createIdentifier("undefined");
  }

  // Build the flatMap chain from inside out
  // Start with the innermost: lastEffect.map(lastVar => returnExpr)
  let result = factory.createCallExpression(
    factory.createPropertyAccessExpression(
      bindings[bindings.length - 1].expression,
      "map",
    ),
    undefined,
    [
      factory.createArrowFunction(
        undefined,
        undefined,
        [
          factory.createParameterDeclaration(
            undefined,
            undefined,
            bindings[bindings.length - 1].name,
          ),
        ],
        undefined,
        factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
        returnExpr,
      ),
    ],
  );

  // Wrap with flatMaps from inside out
  for (let i = bindings.length - 2; i >= 0; i--) {
    const binding = bindings[i];
    result = factory.createCallExpression(
      factory.createPropertyAccessExpression(binding.expression, "flatMap"),
      undefined,
      [
        factory.createArrowFunction(
          undefined,
          undefined,
          [
            factory.createParameterDeclaration(
              undefined,
              undefined,
              binding.name,
            ),
          ],
          undefined,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          result,
        ),
      ],
    );
  }

  return result;
}

// ============================================================================
// ForYield Macro - Alternative syntax closer to Scala
// ============================================================================

export const forYieldMacro = defineExpressionMacro({
  name: "forYield",
  description: "Scala-style for-yield comprehension",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    // forYield([...bindings], yieldExpr)
    // where bindings are [name, expression] pairs

    if (args.length < 2) {
      ctx.reportError(
        callExpr,
        "forYield() expects bindings array and yield expression",
      );
      return callExpr;
    }

    const factory = ctx.factory;
    const bindingsArg = args[0];
    const yieldExpr = args[args.length - 1];

    if (!ts.isArrayLiteralExpression(bindingsArg)) {
      ctx.reportError(callExpr, "First argument must be an array of bindings");
      return callExpr;
    }

    // Parse bindings
    const bindings: Array<{ name: string; expr: ts.Expression }> = [];

    for (const element of bindingsArg.elements) {
      if (
        ts.isArrayLiteralExpression(element) &&
        element.elements.length === 2
      ) {
        const nameEl = element.elements[0];
        const exprEl = element.elements[1];

        if (ts.isStringLiteral(nameEl)) {
          bindings.push({
            name: nameEl.text,
            expr: exprEl,
          });
        }
      }
    }

    if (bindings.length === 0) {
      ctx.reportError(callExpr, "forYield() needs at least one binding");
      return callExpr;
    }

    // Build the chain
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        bindings[bindings.length - 1].expr,
        "map",
      ),
      undefined,
      [
        factory.createArrowFunction(
          undefined,
          undefined,
          [
            factory.createParameterDeclaration(
              undefined,
              undefined,
              factory.createIdentifier(bindings[bindings.length - 1].name),
            ),
          ],
          undefined,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          yieldExpr,
        ),
      ],
    );

    for (let i = bindings.length - 2; i >= 0; i--) {
      const binding = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(binding.expr, "flatMap"),
        undefined,
        [
          factory.createArrowFunction(
            undefined,
            undefined,
            [
              factory.createParameterDeclaration(
                undefined,
                undefined,
                factory.createIdentifier(binding.name),
              ),
            ],
            undefined,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result,
          ),
        ],
      );
    }

    return result;
  },
});

// ============================================================================
// Async Do - For Promises
// ============================================================================

export const asyncDoMacro = defineExpressionMacro({
  name: "asyncDo",
  description: "Transform async generator-style code into Promise chains",

  expand(
    ctx: MacroContext,
    callExpr: ts.CallExpression,
    args: readonly ts.Expression[],
  ): ts.Expression {
    const factory = ctx.factory;

    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "asyncDo() expects exactly one generator function argument",
      );
      return callExpr;
    }

    const arg = args[0];

    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {
      ctx.reportError(
        callExpr,
        "asyncDo() expects a generator function (function*() { ... })",
      );
      return callExpr;
    }

    if (!arg.body) {
      ctx.reportError(
        callExpr,
        "asyncDo() generator function must have a body",
      );
      return callExpr;
    }

    // Extract yield* expressions
    const statements = Array.from(arg.body.statements);
    const bindings: Array<{ name: ts.Identifier; expression: ts.Expression }> =
      [];
    let returnExpr: ts.Expression | undefined;

    for (const stmt of statements) {
      if (ts.isVariableStatement(stmt)) {
        for (const decl of stmt.declarationList.declarations) {
          if (ts.isIdentifier(decl.name) && decl.initializer) {
            if (
              ts.isYieldExpression(decl.initializer) &&
              decl.initializer.asteriskToken
            ) {
              if (decl.initializer.expression) {
                bindings.push({
                  name: decl.name,
                  expression: decl.initializer.expression,
                });
              }
            }
          }
        }
      }

      if (ts.isReturnStatement(stmt) && stmt.expression) {
        returnExpr = stmt.expression;
      }
    }

    if (bindings.length === 0 || !returnExpr) {
      return callExpr;
    }

    // Build Promise.then chain
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        bindings[bindings.length - 1].expression,
        "then",
      ),
      undefined,
      [
        factory.createArrowFunction(
          undefined,
          undefined,
          [
            factory.createParameterDeclaration(
              undefined,
              undefined,
              bindings[bindings.length - 1].name,
            ),
          ],
          undefined,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          returnExpr,
        ),
      ],
    );

    for (let i = bindings.length - 2; i >= 0; i--) {
      const binding = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(binding.expression, "then"),
        undefined,
        [
          factory.createArrowFunction(
            undefined,
            undefined,
            [
              factory.createParameterDeclaration(
                undefined,
                undefined,
                binding.name,
              ),
            ],
            undefined,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result,
          ),
        ],
      );
    }

    return result;
  },
});

// ============================================================================
// Registration
// ============================================================================

export function register(): void {
  globalRegistry.register(doMacro);
  globalRegistry.register(forYieldMacro);
  globalRegistry.register(asyncDoMacro);
}

// Auto-register
register();

// ============================================================================
// Runtime For Comprehension Builder (no macro transformation needed)
// ============================================================================

/**
 * Runtime for-comprehension builder with Scala-like fluent syntax.
 * This works at runtime without macro transformation.
 *
 * @example
 * ```typescript
 * const result = For.from({ x: some(1) })
 *   .bind("y", ({ x }) => some(x + 1))
 *   .yield(({ x, y }) => x + y);
 * ```
 */
export class ForComprehension<
  M extends Monad<unknown>,
  Ctx extends Record<string, unknown>,
> {
  private constructor(
    private readonly effect: M,
    private readonly context: Ctx,
  ) {}

  /**
   * Start a for comprehension with a single effect
   */
  static of<M extends Monad<unknown>, A>(
    effect: M & Monad<A>,
  ): ForComprehension<M, Record<string, never>> {
    return new ForComprehension(effect, {} as Record<string, never>);
  }

  /**
   * Start a for comprehension with named initial bindings
   */
  static from<Name extends string, M extends Monad<unknown>, A>(
    bindings: Record<Name, M & Monad<A>>,
  ): ForComprehensionBuilder<{ [K in Name]: A }> {
    const entries = Object.entries(bindings) as [Name, M & Monad<A>][];
    if (entries.length !== 1) {
      throw new Error("For.from() expects exactly one binding");
    }
    const [name, effect] = entries[0];
    return new ForComprehensionBuilder(effect as Monad<A>, name);
  }
}

/**
 * Builder for chaining for-comprehension bindings
 */
export class ForComprehensionBuilder<Ctx extends Record<string, unknown>> {
  private bindings: Array<{
    name: string;
    effect: Monad<unknown> | ((ctx: Ctx) => Monad<unknown>);
  }> = [];

  constructor(
    private readonly initialEffect: Monad<unknown>,
    private readonly initialName: string,
  ) {
    this.bindings.push({ name: initialName, effect: initialEffect });
  }

  /**
   * Add a new binding to the comprehension
   */
  bind<Name extends string, A>(
    name: Name,
    effect: (ctx: Ctx) => Monad<A>,
  ): ForComprehensionBuilder<Ctx & { [K in Name]: A }> {
    this.bindings.push({
      name,
      effect: effect as (ctx: Ctx) => Monad<unknown>,
    });
    return this as unknown as ForComprehensionBuilder<Ctx & { [K in Name]: A }>;
  }

  /**
   * Complete the comprehension with a yield expression
   */
  yield<B>(f: (ctx: Ctx) => B): Monad<B> {
    // Build the chain from inside out
    const bindings = this.bindings;

    if (bindings.length === 1) {
      const b = bindings[0];
      const effect =
        typeof b.effect === "function" ? b.effect({} as Ctx) : b.effect;
      return effect.map((val: unknown) => f({ [b.name]: val } as Ctx));
    }

    // Build nested flatMaps
    const buildChain = (index: number, ctx: Ctx): Monad<B> => {
      if (index === bindings.length - 1) {
        // Last binding - use map for the yield
        const b = bindings[index];
        const effect =
          typeof b.effect === "function" ? b.effect(ctx) : b.effect;
        return effect.map((val: unknown) =>
          f({ ...ctx, [b.name]: val } as Ctx),
        );
      }

      const b = bindings[index];
      const effect = typeof b.effect === "function" ? b.effect(ctx) : b.effect;

      return effect.flatMap((val: unknown) => {
        const newCtx = { ...ctx, [b.name]: val } as Ctx;
        return buildChain(index + 1, newCtx);
      });
    };

    return buildChain(0, {} as Ctx);
  }

  /**
   * Alias for yield
   */
  map<B>(f: (ctx: Ctx) => B): Monad<B> {
    return this.yield(f);
  }
}

// Export the For namespace
export const For = ForComprehension;

// ============================================================================
// Helper Types
// ============================================================================

/**
 * Simple Option type for demonstration
 */
export class Option<A> {
  private constructor(
    private readonly _value: A | null,
    private readonly _isSome: boolean,
  ) {}

  static some<A>(value: A): Option<A> {
    return new Option(value, true);
  }

  static none<A>(): Option<A> {
    return new Option<A>(null, false);
  }

  get value(): A | undefined {
    return this._isSome ? this._value! : undefined;
  }

  isSome(): boolean {
    return this._isSome;
  }

  isNone(): boolean {
    return !this._isSome;
  }

  map<B>(f: (a: A) => B): Option<B> {
    if (this._isSome) {
      return Option.some(f(this._value!));
    }
    return Option.none();
  }

  flatMap<B>(f: (a: A) => Option<B>): Option<B> {
    if (this._isSome) {
      return f(this._value!);
    }
    return Option.none();
  }

  getOrElse(defaultValue: A): A {
    return this._isSome ? this._value! : defaultValue;
  }
}

/**
 * Simple Either type for demonstration
 */
export class Either<L, R> {
  private constructor(
    private readonly _left: L | null,
    private readonly _right: R | null,
    public readonly isRight: boolean,
  ) {}

  static left<L, R>(value: L): Either<L, R> {
    return new Either<L, R>(value, null, false);
  }

  static right<L, R>(value: R): Either<L, R> {
    return new Either<L, R>(null, value, true);
  }

  get value(): R | undefined {
    return this.isRight ? this._right! : undefined;
  }

  get error(): L | undefined {
    return this.isRight ? undefined : this._left!;
  }

  isLeft(): boolean {
    return !this.isRight;
  }

  map<B>(f: (r: R) => B): Either<L, B> {
    if (this.isRight) {
      return Either.right(f(this._right!));
    }
    return Either.left(this._left!);
  }

  flatMap<B>(f: (r: R) => Either<L, B>): Either<L, B> {
    if (this.isRight) {
      return f(this._right!);
    }
    return Either.left(this._left!);
  }

  fold<B>(onLeft: (l: L) => B, onRight: (r: R) => B): B {
    return this.isRight ? onRight(this._right!) : onLeft(this._left!);
  }
}

/**
 * Simple IO monad for demonstration
 */
export class IO<A> {
  constructor(private readonly _run: () => A) {}

  static of<A>(value: A): IO<A> {
    return new IO(() => value);
  }

  static suspend<A>(f: () => A): IO<A> {
    return new IO(f);
  }

  map<B>(f: (a: A) => B): IO<B> {
    return new IO(() => f(this._run()));
  }

  flatMap<B>(f: (a: A) => IO<B>): IO<B> {
    return new IO(() => f(this._run())._run());
  }

  run(): A {
    return this._run();
  }
}

// ============================================================================
// Helper functions for cleaner syntax
// ============================================================================

/** Create a Some value */
export function some<A>(value: A): Option<A> {
  return Option.some(value);
}

/** Create a None value */
export function none<A>(): Option<A> {
  return Option.none();
}

/** Create a Left (error) value */
export function left<L, R>(value: L): Either<L, R> {
  return Either.left(value);
}

/** Create a Right (success) value */
export function right<L, R>(value: R): Either<L, R> {
  return Either.right(value);
}

/** Create an IO from a thunk */
export function io<A>(f: () => A): IO<A> {
  return new IO(f);
}
