"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Either: () => Either,
  For: () => For,
  ForComprehension: () => ForComprehension,
  ForComprehensionBuilder: () => ForComprehensionBuilder,
  IO: () => IO,
  Option: () => Option,
  asyncDoMacro: () => asyncDoMacro,
  doMacro: () => doMacro,
  forYieldMacro: () => forYieldMacro,
  io: () => io,
  left: () => left,
  none: () => none,
  register: () => register,
  right: () => right,
  some: () => some
});
module.exports = __toCommonJS(index_exports);
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var doMacro = (0, import_core.defineExpressionMacro)({
  name: "Do",
  description: "Transform generator-style code into flatMap chains",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "Do() expects exactly one generator function argument"
      );
      return callExpr;
    }
    const arg = args[0];
    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {
      ctx.reportError(
        callExpr,
        "Do() expects a generator function (function*() { ... })"
      );
      return callExpr;
    }
    if (!arg.body) {
      ctx.reportError(callExpr, "Do() generator function must have a body");
      return callExpr;
    }
    return transformGeneratorToFlatMap(ctx, arg.body);
  }
});
function transformGeneratorToFlatMap(ctx, body) {
  const factory = ctx.factory;
  const statements = Array.from(body.statements);
  const bindings = [];
  let returnExpr;
  for (const stmt of statements) {
    if (ts.isVariableStatement(stmt)) {
      for (const decl of stmt.declarationList.declarations) {
        if (ts.isIdentifier(decl.name) && decl.initializer) {
          if (ts.isYieldExpression(decl.initializer) && decl.initializer.asteriskToken) {
            if (decl.initializer.expression) {
              bindings.push({
                name: decl.name,
                expression: decl.initializer.expression
              });
            }
          }
        }
      }
    }
    if (ts.isReturnStatement(stmt) && stmt.expression) {
      returnExpr = stmt.expression;
    }
  }
  if (bindings.length === 0) {
    ctx.reportError(
      body,
      "Do() generator must have at least one yield* expression"
    );
    return factory.createIdentifier("undefined");
  }
  if (!returnExpr) {
    ctx.reportError(body, "Do() generator must have a return statement");
    return factory.createIdentifier("undefined");
  }
  let result = factory.createCallExpression(
    factory.createPropertyAccessExpression(
      bindings[bindings.length - 1].expression,
      "map"
    ),
    void 0,
    [
      factory.createArrowFunction(
        void 0,
        void 0,
        [
          factory.createParameterDeclaration(
            void 0,
            void 0,
            bindings[bindings.length - 1].name
          )
        ],
        void 0,
        factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
        returnExpr
      )
    ]
  );
  for (let i = bindings.length - 2; i >= 0; i--) {
    const binding = bindings[i];
    result = factory.createCallExpression(
      factory.createPropertyAccessExpression(binding.expression, "flatMap"),
      void 0,
      [
        factory.createArrowFunction(
          void 0,
          void 0,
          [
            factory.createParameterDeclaration(
              void 0,
              void 0,
              binding.name
            )
          ],
          void 0,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          result
        )
      ]
    );
  }
  return result;
}
var forYieldMacro = (0, import_core.defineExpressionMacro)({
  name: "forYield",
  description: "Scala-style for-yield comprehension",
  expand(ctx, callExpr, args) {
    if (args.length < 2) {
      ctx.reportError(
        callExpr,
        "forYield() expects bindings array and yield expression"
      );
      return callExpr;
    }
    const factory = ctx.factory;
    const bindingsArg = args[0];
    const yieldExpr = args[args.length - 1];
    if (!ts.isArrayLiteralExpression(bindingsArg)) {
      ctx.reportError(callExpr, "First argument must be an array of bindings");
      return callExpr;
    }
    const bindings = [];
    for (const element of bindingsArg.elements) {
      if (ts.isArrayLiteralExpression(element) && element.elements.length === 2) {
        const nameEl = element.elements[0];
        const exprEl = element.elements[1];
        if (ts.isStringLiteral(nameEl)) {
          bindings.push({
            name: nameEl.text,
            expr: exprEl
          });
        }
      }
    }
    if (bindings.length === 0) {
      ctx.reportError(callExpr, "forYield() needs at least one binding");
      return callExpr;
    }
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        bindings[bindings.length - 1].expr,
        "map"
      ),
      void 0,
      [
        factory.createArrowFunction(
          void 0,
          void 0,
          [
            factory.createParameterDeclaration(
              void 0,
              void 0,
              factory.createIdentifier(bindings[bindings.length - 1].name)
            )
          ],
          void 0,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          yieldExpr
        )
      ]
    );
    for (let i = bindings.length - 2; i >= 0; i--) {
      const binding = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(binding.expr, "flatMap"),
        void 0,
        [
          factory.createArrowFunction(
            void 0,
            void 0,
            [
              factory.createParameterDeclaration(
                void 0,
                void 0,
                factory.createIdentifier(binding.name)
              )
            ],
            void 0,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result
          )
        ]
      );
    }
    return result;
  }
});
var asyncDoMacro = (0, import_core.defineExpressionMacro)({
  name: "asyncDo",
  description: "Transform async generator-style code into Promise chains",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "asyncDo() expects exactly one generator function argument"
      );
      return callExpr;
    }
    const arg = args[0];
    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {
      ctx.reportError(
        callExpr,
        "asyncDo() expects a generator function (function*() { ... })"
      );
      return callExpr;
    }
    if (!arg.body) {
      ctx.reportError(
        callExpr,
        "asyncDo() generator function must have a body"
      );
      return callExpr;
    }
    const statements = Array.from(arg.body.statements);
    const bindings = [];
    let returnExpr;
    for (const stmt of statements) {
      if (ts.isVariableStatement(stmt)) {
        for (const decl of stmt.declarationList.declarations) {
          if (ts.isIdentifier(decl.name) && decl.initializer) {
            if (ts.isYieldExpression(decl.initializer) && decl.initializer.asteriskToken) {
              if (decl.initializer.expression) {
                bindings.push({
                  name: decl.name,
                  expression: decl.initializer.expression
                });
              }
            }
          }
        }
      }
      if (ts.isReturnStatement(stmt) && stmt.expression) {
        returnExpr = stmt.expression;
      }
    }
    if (bindings.length === 0 || !returnExpr) {
      return callExpr;
    }
    let result = factory.createCallExpression(
      factory.createPropertyAccessExpression(
        bindings[bindings.length - 1].expression,
        "then"
      ),
      void 0,
      [
        factory.createArrowFunction(
          void 0,
          void 0,
          [
            factory.createParameterDeclaration(
              void 0,
              void 0,
              bindings[bindings.length - 1].name
            )
          ],
          void 0,
          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
          returnExpr
        )
      ]
    );
    for (let i = bindings.length - 2; i >= 0; i--) {
      const binding = bindings[i];
      result = factory.createCallExpression(
        factory.createPropertyAccessExpression(binding.expression, "then"),
        void 0,
        [
          factory.createArrowFunction(
            void 0,
            void 0,
            [
              factory.createParameterDeclaration(
                void 0,
                void 0,
                binding.name
              )
            ],
            void 0,
            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
            result
          )
        ]
      );
    }
    return result;
  }
});
function register() {
  import_core.globalRegistry.register(doMacro);
  import_core.globalRegistry.register(forYieldMacro);
  import_core.globalRegistry.register(asyncDoMacro);
}
register();
var ForComprehension = class _ForComprehension {
  constructor(effect, context) {
    this.effect = effect;
    this.context = context;
  }
  /**
   * Start a for comprehension with a single effect
   */
  static of(effect) {
    return new _ForComprehension(effect, {});
  }
  /**
   * Start a for comprehension with named initial bindings
   */
  static from(bindings) {
    const entries = Object.entries(bindings);
    if (entries.length !== 1) {
      throw new Error("For.from() expects exactly one binding");
    }
    const [name, effect] = entries[0];
    return new ForComprehensionBuilder(effect, name);
  }
};
var ForComprehensionBuilder = class {
  constructor(initialEffect, initialName) {
    this.initialEffect = initialEffect;
    this.initialName = initialName;
    this.bindings.push({ name: initialName, effect: initialEffect });
  }
  bindings = [];
  /**
   * Add a new binding to the comprehension
   */
  bind(name, effect) {
    this.bindings.push({
      name,
      effect
    });
    return this;
  }
  /**
   * Complete the comprehension with a yield expression
   */
  yield(f) {
    const bindings = this.bindings;
    if (bindings.length === 1) {
      const b = bindings[0];
      const effect = typeof b.effect === "function" ? b.effect({}) : b.effect;
      return effect.map((val) => f({ [b.name]: val }));
    }
    const buildChain = (index, ctx) => {
      if (index === bindings.length - 1) {
        const b2 = bindings[index];
        const effect2 = typeof b2.effect === "function" ? b2.effect(ctx) : b2.effect;
        return effect2.map(
          (val) => f({ ...ctx, [b2.name]: val })
        );
      }
      const b = bindings[index];
      const effect = typeof b.effect === "function" ? b.effect(ctx) : b.effect;
      return effect.flatMap((val) => {
        const newCtx = { ...ctx, [b.name]: val };
        return buildChain(index + 1, newCtx);
      });
    };
    return buildChain(0, {});
  }
  /**
   * Alias for yield
   */
  map(f) {
    return this.yield(f);
  }
};
var For = ForComprehension;
var Option = class _Option {
  constructor(_value, _isSome) {
    this._value = _value;
    this._isSome = _isSome;
  }
  static some(value) {
    return new _Option(value, true);
  }
  static none() {
    return new _Option(null, false);
  }
  get value() {
    return this._isSome ? this._value : void 0;
  }
  isSome() {
    return this._isSome;
  }
  isNone() {
    return !this._isSome;
  }
  map(f) {
    if (this._isSome) {
      return _Option.some(f(this._value));
    }
    return _Option.none();
  }
  flatMap(f) {
    if (this._isSome) {
      return f(this._value);
    }
    return _Option.none();
  }
  getOrElse(defaultValue) {
    return this._isSome ? this._value : defaultValue;
  }
};
var Either = class _Either {
  constructor(_left, _right, isRight) {
    this._left = _left;
    this._right = _right;
    this.isRight = isRight;
  }
  static left(value) {
    return new _Either(value, null, false);
  }
  static right(value) {
    return new _Either(null, value, true);
  }
  get value() {
    return this.isRight ? this._right : void 0;
  }
  get error() {
    return this.isRight ? void 0 : this._left;
  }
  isLeft() {
    return !this.isRight;
  }
  map(f) {
    if (this.isRight) {
      return _Either.right(f(this._right));
    }
    return _Either.left(this._left);
  }
  flatMap(f) {
    if (this.isRight) {
      return f(this._right);
    }
    return _Either.left(this._left);
  }
  fold(onLeft, onRight) {
    return this.isRight ? onRight(this._right) : onLeft(this._left);
  }
};
var IO = class _IO {
  constructor(_run) {
    this._run = _run;
  }
  static of(value) {
    return new _IO(() => value);
  }
  static suspend(f) {
    return new _IO(f);
  }
  map(f) {
    return new _IO(() => f(this._run()));
  }
  flatMap(f) {
    return new _IO(() => f(this._run())._run());
  }
  run() {
    return this._run();
  }
};
function some(value) {
  return Option.some(value);
}
function none() {
  return Option.none();
}
function left(value) {
  return Either.left(value);
}
function right(value) {
  return Either.right(value);
}
function io(f) {
  return new IO(f);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Either,
  For,
  ForComprehension,
  ForComprehensionBuilder,
  IO,
  Option,
  asyncDoMacro,
  doMacro,
  forYieldMacro,
  io,
  left,
  none,
  register,
  right,
  some
});
//# sourceMappingURL=index.cjs.map