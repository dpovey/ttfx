{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @typemacro/effect-do - Effect Do-Comprehension Macros\n *\n * Provides Scala-style for-comprehension syntax for monadic types.\n * Works with Effect, Promise, Option, Either, and other flatMappable types.\n *\n * @example\n * ```typescript\n * // Generator-style syntax\n * const result = Do(function*() {\n *   const user = yield* fetchUser(id);\n *   const posts = yield* fetchPosts(user.id);\n *   const comments = yield* fetchComments(posts[0].id);\n *   return { user, posts, comments };\n * });\n *\n * // Transforms to:\n * const result = fetchUser(id).flatMap(user =>\n *   fetchPosts(user.id).flatMap(posts =>\n *     fetchComments(posts[0].id).map(comments =>\n *       ({ user, posts, comments })\n *     )\n *   )\n * );\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// Monad Interface (for type documentation)\n// ============================================================================\n\n/**\n * Interface for types that support do-comprehension\n */\nexport interface Monad<A> {\n  map<B>(f: (a: A) => B): Monad<B>;\n  flatMap<B>(f: (a: A) => Monad<B>): Monad<B>;\n}\n\n// ============================================================================\n// Do Macro\n// ============================================================================\n\nexport const doMacro = defineExpressionMacro({\n  name: \"Do\",\n  description: \"Transform generator-style code into flatMap chains\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"Do() expects exactly one generator function argument\",\n      );\n      return callExpr;\n    }\n\n    const arg = args[0];\n\n    // Must be a generator function\n    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {\n      ctx.reportError(\n        callExpr,\n        \"Do() expects a generator function (function*() { ... })\",\n      );\n      return callExpr;\n    }\n\n    if (!arg.body) {\n      ctx.reportError(callExpr, \"Do() generator function must have a body\");\n      return callExpr;\n    }\n\n    // Extract yield statements and transform to flatMap chain\n    return transformGeneratorToFlatMap(ctx, arg.body);\n  },\n});\n\n/**\n * Transform a generator function body into nested flatMap calls\n */\nfunction transformGeneratorToFlatMap(\n  ctx: MacroContext,\n  body: ts.Block,\n): ts.Expression {\n  const factory = ctx.factory;\n  const statements = Array.from(body.statements);\n\n  // Find all yield* expressions and the final return\n  const bindings: Array<{\n    name: ts.Identifier;\n    expression: ts.Expression;\n  }> = [];\n  let returnExpr: ts.Expression | undefined;\n\n  for (const stmt of statements) {\n    // Variable declaration with yield*\n    if (ts.isVariableStatement(stmt)) {\n      for (const decl of stmt.declarationList.declarations) {\n        if (ts.isIdentifier(decl.name) && decl.initializer) {\n          // Check for yield* expression\n          if (\n            ts.isYieldExpression(decl.initializer) &&\n            decl.initializer.asteriskToken\n          ) {\n            if (decl.initializer.expression) {\n              bindings.push({\n                name: decl.name,\n                expression: decl.initializer.expression,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    // Return statement\n    if (ts.isReturnStatement(stmt) && stmt.expression) {\n      returnExpr = stmt.expression;\n    }\n  }\n\n  if (bindings.length === 0) {\n    ctx.reportError(\n      body,\n      \"Do() generator must have at least one yield* expression\",\n    );\n    return factory.createIdentifier(\"undefined\");\n  }\n\n  if (!returnExpr) {\n    ctx.reportError(body, \"Do() generator must have a return statement\");\n    return factory.createIdentifier(\"undefined\");\n  }\n\n  // Build the flatMap chain from inside out\n  // Start with the innermost: lastEffect.map(lastVar => returnExpr)\n  let result = factory.createCallExpression(\n    factory.createPropertyAccessExpression(\n      bindings[bindings.length - 1].expression,\n      \"map\",\n    ),\n    undefined,\n    [\n      factory.createArrowFunction(\n        undefined,\n        undefined,\n        [\n          factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            bindings[bindings.length - 1].name,\n          ),\n        ],\n        undefined,\n        factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n        returnExpr,\n      ),\n    ],\n  );\n\n  // Wrap with flatMaps from inside out\n  for (let i = bindings.length - 2; i >= 0; i--) {\n    const binding = bindings[i];\n    result = factory.createCallExpression(\n      factory.createPropertyAccessExpression(binding.expression, \"flatMap\"),\n      undefined,\n      [\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            factory.createParameterDeclaration(\n              undefined,\n              undefined,\n              binding.name,\n            ),\n          ],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          result,\n        ),\n      ],\n    );\n  }\n\n  return result;\n}\n\n// ============================================================================\n// ForYield Macro - Alternative syntax closer to Scala\n// ============================================================================\n\nexport const forYieldMacro = defineExpressionMacro({\n  name: \"forYield\",\n  description: \"Scala-style for-yield comprehension\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    // forYield([...bindings], yieldExpr)\n    // where bindings are [name, expression] pairs\n\n    if (args.length < 2) {\n      ctx.reportError(\n        callExpr,\n        \"forYield() expects bindings array and yield expression\",\n      );\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n    const bindingsArg = args[0];\n    const yieldExpr = args[args.length - 1];\n\n    if (!ts.isArrayLiteralExpression(bindingsArg)) {\n      ctx.reportError(callExpr, \"First argument must be an array of bindings\");\n      return callExpr;\n    }\n\n    // Parse bindings\n    const bindings: Array<{ name: string; expr: ts.Expression }> = [];\n\n    for (const element of bindingsArg.elements) {\n      if (\n        ts.isArrayLiteralExpression(element) &&\n        element.elements.length === 2\n      ) {\n        const nameEl = element.elements[0];\n        const exprEl = element.elements[1];\n\n        if (ts.isStringLiteral(nameEl)) {\n          bindings.push({\n            name: nameEl.text,\n            expr: exprEl,\n          });\n        }\n      }\n    }\n\n    if (bindings.length === 0) {\n      ctx.reportError(callExpr, \"forYield() needs at least one binding\");\n      return callExpr;\n    }\n\n    // Build the chain\n    let result = factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        bindings[bindings.length - 1].expr,\n        \"map\",\n      ),\n      undefined,\n      [\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            factory.createParameterDeclaration(\n              undefined,\n              undefined,\n              factory.createIdentifier(bindings[bindings.length - 1].name),\n            ),\n          ],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          yieldExpr,\n        ),\n      ],\n    );\n\n    for (let i = bindings.length - 2; i >= 0; i--) {\n      const binding = bindings[i];\n      result = factory.createCallExpression(\n        factory.createPropertyAccessExpression(binding.expr, \"flatMap\"),\n        undefined,\n        [\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              factory.createParameterDeclaration(\n                undefined,\n                undefined,\n                factory.createIdentifier(binding.name),\n              ),\n            ],\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            result,\n          ),\n        ],\n      );\n    }\n\n    return result;\n  },\n});\n\n// ============================================================================\n// Async Do - For Promises\n// ============================================================================\n\nexport const asyncDoMacro = defineExpressionMacro({\n  name: \"asyncDo\",\n  description: \"Transform async generator-style code into Promise chains\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"asyncDo() expects exactly one generator function argument\",\n      );\n      return callExpr;\n    }\n\n    const arg = args[0];\n\n    if (!ts.isFunctionExpression(arg) || !arg.asteriskToken) {\n      ctx.reportError(\n        callExpr,\n        \"asyncDo() expects a generator function (function*() { ... })\",\n      );\n      return callExpr;\n    }\n\n    if (!arg.body) {\n      ctx.reportError(\n        callExpr,\n        \"asyncDo() generator function must have a body\",\n      );\n      return callExpr;\n    }\n\n    // Extract yield* expressions\n    const statements = Array.from(arg.body.statements);\n    const bindings: Array<{ name: ts.Identifier; expression: ts.Expression }> =\n      [];\n    let returnExpr: ts.Expression | undefined;\n\n    for (const stmt of statements) {\n      if (ts.isVariableStatement(stmt)) {\n        for (const decl of stmt.declarationList.declarations) {\n          if (ts.isIdentifier(decl.name) && decl.initializer) {\n            if (\n              ts.isYieldExpression(decl.initializer) &&\n              decl.initializer.asteriskToken\n            ) {\n              if (decl.initializer.expression) {\n                bindings.push({\n                  name: decl.name,\n                  expression: decl.initializer.expression,\n                });\n              }\n            }\n          }\n        }\n      }\n\n      if (ts.isReturnStatement(stmt) && stmt.expression) {\n        returnExpr = stmt.expression;\n      }\n    }\n\n    if (bindings.length === 0 || !returnExpr) {\n      return callExpr;\n    }\n\n    // Build Promise.then chain\n    let result = factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        bindings[bindings.length - 1].expression,\n        \"then\",\n      ),\n      undefined,\n      [\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [\n            factory.createParameterDeclaration(\n              undefined,\n              undefined,\n              bindings[bindings.length - 1].name,\n            ),\n          ],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          returnExpr,\n        ),\n      ],\n    );\n\n    for (let i = bindings.length - 2; i >= 0; i--) {\n      const binding = bindings[i];\n      result = factory.createCallExpression(\n        factory.createPropertyAccessExpression(binding.expression, \"then\"),\n        undefined,\n        [\n          factory.createArrowFunction(\n            undefined,\n            undefined,\n            [\n              factory.createParameterDeclaration(\n                undefined,\n                undefined,\n                binding.name,\n              ),\n            ],\n            undefined,\n            factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n            result,\n          ),\n        ],\n      );\n    }\n\n    return result;\n  },\n});\n\n// ============================================================================\n// Registration\n// ============================================================================\n\nexport function register(): void {\n  globalRegistry.register(doMacro);\n  globalRegistry.register(forYieldMacro);\n  globalRegistry.register(asyncDoMacro);\n}\n\n// Auto-register\nregister();\n\n// ============================================================================\n// Runtime For Comprehension Builder (no macro transformation needed)\n// ============================================================================\n\n/**\n * Runtime for-comprehension builder with Scala-like fluent syntax.\n * This works at runtime without macro transformation.\n *\n * @example\n * ```typescript\n * const result = For.from({ x: some(1) })\n *   .bind(\"y\", ({ x }) => some(x + 1))\n *   .yield(({ x, y }) => x + y);\n * ```\n */\nexport class ForComprehension<\n  M extends Monad<unknown>,\n  Ctx extends Record<string, unknown>,\n> {\n  private constructor(\n    private readonly effect: M,\n    private readonly context: Ctx,\n  ) {}\n\n  /**\n   * Start a for comprehension with a single effect\n   */\n  static of<M extends Monad<unknown>, A>(\n    effect: M & Monad<A>,\n  ): ForComprehension<M, Record<string, never>> {\n    return new ForComprehension(effect, {} as Record<string, never>);\n  }\n\n  /**\n   * Start a for comprehension with named initial bindings\n   */\n  static from<Name extends string, M extends Monad<unknown>, A>(\n    bindings: Record<Name, M & Monad<A>>,\n  ): ForComprehensionBuilder<{ [K in Name]: A }> {\n    const entries = Object.entries(bindings) as [Name, M & Monad<A>][];\n    if (entries.length !== 1) {\n      throw new Error(\"For.from() expects exactly one binding\");\n    }\n    const [name, effect] = entries[0];\n    return new ForComprehensionBuilder(effect as Monad<A>, name);\n  }\n}\n\n/**\n * Builder for chaining for-comprehension bindings\n */\nexport class ForComprehensionBuilder<Ctx extends Record<string, unknown>> {\n  private bindings: Array<{\n    name: string;\n    effect: Monad<unknown> | ((ctx: Ctx) => Monad<unknown>);\n  }> = [];\n\n  constructor(\n    private readonly initialEffect: Monad<unknown>,\n    private readonly initialName: string,\n  ) {\n    this.bindings.push({ name: initialName, effect: initialEffect });\n  }\n\n  /**\n   * Add a new binding to the comprehension\n   */\n  bind<Name extends string, A>(\n    name: Name,\n    effect: (ctx: Ctx) => Monad<A>,\n  ): ForComprehensionBuilder<Ctx & { [K in Name]: A }> {\n    this.bindings.push({\n      name,\n      effect: effect as (ctx: Ctx) => Monad<unknown>,\n    });\n    return this as unknown as ForComprehensionBuilder<Ctx & { [K in Name]: A }>;\n  }\n\n  /**\n   * Complete the comprehension with a yield expression\n   */\n  yield<B>(f: (ctx: Ctx) => B): Monad<B> {\n    // Build the chain from inside out\n    const bindings = this.bindings;\n\n    if (bindings.length === 1) {\n      const b = bindings[0];\n      const effect =\n        typeof b.effect === \"function\" ? b.effect({} as Ctx) : b.effect;\n      return effect.map((val: unknown) => f({ [b.name]: val } as Ctx));\n    }\n\n    // Build nested flatMaps\n    const buildChain = (index: number, ctx: Ctx): Monad<B> => {\n      if (index === bindings.length - 1) {\n        // Last binding - use map for the yield\n        const b = bindings[index];\n        const effect =\n          typeof b.effect === \"function\" ? b.effect(ctx) : b.effect;\n        return effect.map((val: unknown) =>\n          f({ ...ctx, [b.name]: val } as Ctx),\n        );\n      }\n\n      const b = bindings[index];\n      const effect = typeof b.effect === \"function\" ? b.effect(ctx) : b.effect;\n\n      return effect.flatMap((val: unknown) => {\n        const newCtx = { ...ctx, [b.name]: val } as Ctx;\n        return buildChain(index + 1, newCtx);\n      });\n    };\n\n    return buildChain(0, {} as Ctx);\n  }\n\n  /**\n   * Alias for yield\n   */\n  map<B>(f: (ctx: Ctx) => B): Monad<B> {\n    return this.yield(f);\n  }\n}\n\n// Export the For namespace\nexport const For = ForComprehension;\n\n// ============================================================================\n// Helper Types\n// ============================================================================\n\n/**\n * Simple Option type for demonstration\n */\nexport class Option<A> {\n  private constructor(\n    private readonly _value: A | null,\n    private readonly _isSome: boolean,\n  ) {}\n\n  static some<A>(value: A): Option<A> {\n    return new Option(value, true);\n  }\n\n  static none<A>(): Option<A> {\n    return new Option<A>(null, false);\n  }\n\n  get value(): A | undefined {\n    return this._isSome ? this._value! : undefined;\n  }\n\n  isSome(): boolean {\n    return this._isSome;\n  }\n\n  isNone(): boolean {\n    return !this._isSome;\n  }\n\n  map<B>(f: (a: A) => B): Option<B> {\n    if (this._isSome) {\n      return Option.some(f(this._value!));\n    }\n    return Option.none();\n  }\n\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    if (this._isSome) {\n      return f(this._value!);\n    }\n    return Option.none();\n  }\n\n  getOrElse(defaultValue: A): A {\n    return this._isSome ? this._value! : defaultValue;\n  }\n}\n\n/**\n * Simple Either type for demonstration\n */\nexport class Either<L, R> {\n  private constructor(\n    private readonly _left: L | null,\n    private readonly _right: R | null,\n    public readonly isRight: boolean,\n  ) {}\n\n  static left<L, R>(value: L): Either<L, R> {\n    return new Either<L, R>(value, null, false);\n  }\n\n  static right<L, R>(value: R): Either<L, R> {\n    return new Either<L, R>(null, value, true);\n  }\n\n  get value(): R | undefined {\n    return this.isRight ? this._right! : undefined;\n  }\n\n  get error(): L | undefined {\n    return this.isRight ? undefined : this._left!;\n  }\n\n  isLeft(): boolean {\n    return !this.isRight;\n  }\n\n  map<B>(f: (r: R) => B): Either<L, B> {\n    if (this.isRight) {\n      return Either.right(f(this._right!));\n    }\n    return Either.left(this._left!);\n  }\n\n  flatMap<B>(f: (r: R) => Either<L, B>): Either<L, B> {\n    if (this.isRight) {\n      return f(this._right!);\n    }\n    return Either.left(this._left!);\n  }\n\n  fold<B>(onLeft: (l: L) => B, onRight: (r: R) => B): B {\n    return this.isRight ? onRight(this._right!) : onLeft(this._left!);\n  }\n}\n\n/**\n * Simple IO monad for demonstration\n */\nexport class IO<A> {\n  constructor(private readonly _run: () => A) {}\n\n  static of<A>(value: A): IO<A> {\n    return new IO(() => value);\n  }\n\n  static suspend<A>(f: () => A): IO<A> {\n    return new IO(f);\n  }\n\n  map<B>(f: (a: A) => B): IO<B> {\n    return new IO(() => f(this._run()));\n  }\n\n  flatMap<B>(f: (a: A) => IO<B>): IO<B> {\n    return new IO(() => f(this._run())._run());\n  }\n\n  run(): A {\n    return this._run();\n  }\n}\n\n// ============================================================================\n// Helper functions for cleaner syntax\n// ============================================================================\n\n/** Create a Some value */\nexport function some<A>(value: A): Option<A> {\n  return Option.some(value);\n}\n\n/** Create a None value */\nexport function none<A>(): Option<A> {\n  return Option.none();\n}\n\n/** Create a Left (error) value */\nexport function left<L, R>(value: L): Either<L, R> {\n  return Either.left(value);\n}\n\n/** Create a Right (success) value */\nexport function right<L, R>(value: R): Either<L, R> {\n  return Either.right(value);\n}\n\n/** Create an IO from a thunk */\nexport function io<A>(f: () => A): IO<A> {\n  return new IO(f);\n}\n"],"mappings":"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","names":["b","effect"]}