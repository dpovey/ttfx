import * as _typemacro_core from '@typemacro/core';

/**
 * @typemacro/effect-do - Effect Do-Comprehension Macros
 *
 * Provides Scala-style for-comprehension syntax for monadic types.
 * Works with Effect, Promise, Option, Either, and other flatMappable types.
 *
 * @example
 * ```typescript
 * // Generator-style syntax
 * const result = Do(function*() {
 *   const user = yield* fetchUser(id);
 *   const posts = yield* fetchPosts(user.id);
 *   const comments = yield* fetchComments(posts[0].id);
 *   return { user, posts, comments };
 * });
 *
 * // Transforms to:
 * const result = fetchUser(id).flatMap(user =>
 *   fetchPosts(user.id).flatMap(posts =>
 *     fetchComments(posts[0].id).map(comments =>
 *       ({ user, posts, comments })
 *     )
 *   )
 * );
 * ```
 */
/**
 * Interface for types that support do-comprehension
 */
interface Monad<A> {
    map<B>(f: (a: A) => B): Monad<B>;
    flatMap<B>(f: (a: A) => Monad<B>): Monad<B>;
}
declare const doMacro: _typemacro_core.ExpressionMacro;
declare const forYieldMacro: _typemacro_core.ExpressionMacro;
declare const asyncDoMacro: _typemacro_core.ExpressionMacro;
declare function register(): void;
/**
 * Runtime for-comprehension builder with Scala-like fluent syntax.
 * This works at runtime without macro transformation.
 *
 * @example
 * ```typescript
 * const result = For.from({ x: some(1) })
 *   .bind("y", ({ x }) => some(x + 1))
 *   .yield(({ x, y }) => x + y);
 * ```
 */
declare class ForComprehension<M extends Monad<unknown>, Ctx extends Record<string, unknown>> {
    private readonly effect;
    private readonly context;
    private constructor();
    /**
     * Start a for comprehension with a single effect
     */
    static of<M extends Monad<unknown>, A>(effect: M & Monad<A>): ForComprehension<M, Record<string, never>>;
    /**
     * Start a for comprehension with named initial bindings
     */
    static from<Name extends string, M extends Monad<unknown>, A>(bindings: Record<Name, M & Monad<A>>): ForComprehensionBuilder<{
        [K in Name]: A;
    }>;
}
/**
 * Builder for chaining for-comprehension bindings
 */
declare class ForComprehensionBuilder<Ctx extends Record<string, unknown>> {
    private readonly initialEffect;
    private readonly initialName;
    private bindings;
    constructor(initialEffect: Monad<unknown>, initialName: string);
    /**
     * Add a new binding to the comprehension
     */
    bind<Name extends string, A>(name: Name, effect: (ctx: Ctx) => Monad<A>): ForComprehensionBuilder<Ctx & {
        [K in Name]: A;
    }>;
    /**
     * Complete the comprehension with a yield expression
     */
    yield<B>(f: (ctx: Ctx) => B): Monad<B>;
    /**
     * Alias for yield
     */
    map<B>(f: (ctx: Ctx) => B): Monad<B>;
}
declare const For: typeof ForComprehension;
/**
 * Simple Option type for demonstration
 */
declare class Option<A> {
    private readonly _value;
    private readonly _isSome;
    private constructor();
    static some<A>(value: A): Option<A>;
    static none<A>(): Option<A>;
    get value(): A | undefined;
    isSome(): boolean;
    isNone(): boolean;
    map<B>(f: (a: A) => B): Option<B>;
    flatMap<B>(f: (a: A) => Option<B>): Option<B>;
    getOrElse(defaultValue: A): A;
}
/**
 * Simple Either type for demonstration
 */
declare class Either<L, R> {
    private readonly _left;
    private readonly _right;
    readonly isRight: boolean;
    private constructor();
    static left<L, R>(value: L): Either<L, R>;
    static right<L, R>(value: R): Either<L, R>;
    get value(): R | undefined;
    get error(): L | undefined;
    isLeft(): boolean;
    map<B>(f: (r: R) => B): Either<L, B>;
    flatMap<B>(f: (r: R) => Either<L, B>): Either<L, B>;
    fold<B>(onLeft: (l: L) => B, onRight: (r: R) => B): B;
}
/**
 * Simple IO monad for demonstration
 */
declare class IO<A> {
    private readonly _run;
    constructor(_run: () => A);
    static of<A>(value: A): IO<A>;
    static suspend<A>(f: () => A): IO<A>;
    map<B>(f: (a: A) => B): IO<B>;
    flatMap<B>(f: (a: A) => IO<B>): IO<B>;
    run(): A;
}
/** Create a Some value */
declare function some<A>(value: A): Option<A>;
/** Create a None value */
declare function none<A>(): Option<A>;
/** Create a Left (error) value */
declare function left<L, R>(value: L): Either<L, R>;
/** Create a Right (success) value */
declare function right<L, R>(value: R): Either<L, R>;
/** Create an IO from a thunk */
declare function io<A>(f: () => A): IO<A>;

export { Either, For, ForComprehension, ForComprehensionBuilder, IO, type Monad, Option, asyncDoMacro, doMacro, forYieldMacro, io, left, none, register, right, some };
