import * as _typemacro_core from '@typemacro/core';

/**
 * Derive Macros - Auto-generate common implementations
 *
 * Inspired by Rust's derive macros, these automatically generate
 * implementations for common traits/interfaces.
 *
 * Usage:
 *   @derive(Eq, Ord, Clone, Debug)
 *   interface Point {
 *     x: number;
 *     y: number;
 *   }
 */
declare const EqDerive: _typemacro_core.DeriveMacro;
declare const OrdDerive: _typemacro_core.DeriveMacro;
declare const CloneDerive: _typemacro_core.DeriveMacro;
declare const DebugDerive: _typemacro_core.DeriveMacro;
declare const HashDerive: _typemacro_core.DeriveMacro;
declare const DefaultDerive: _typemacro_core.DeriveMacro;
declare const JsonDerive: _typemacro_core.DeriveMacro;
declare const BuilderDerive: _typemacro_core.DeriveMacro;
declare const deriveMacros: {
    Eq: _typemacro_core.DeriveMacro;
    Ord: _typemacro_core.DeriveMacro;
    Clone: _typemacro_core.DeriveMacro;
    Debug: _typemacro_core.DeriveMacro;
    Hash: _typemacro_core.DeriveMacro;
    Default: _typemacro_core.DeriveMacro;
    Json: _typemacro_core.DeriveMacro;
    Builder: _typemacro_core.DeriveMacro;
};
/**
 * Create a derived function name based on convention
 */
declare function createDerivedFunctionName(operation: string, typeName: string): string;
/**
 * Register macros with the global registry.
 * Call this function to enable derive macros in your project.
 */
declare function register(): void;

export { BuilderDerive, CloneDerive, DebugDerive, DefaultDerive, EqDerive, HashDerive, JsonDerive, OrdDerive, createDerivedFunctionName, deriveMacros, register };
