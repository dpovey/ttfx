{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Derive Macros - Auto-generate common implementations\n *\n * Inspired by Rust's derive macros, these automatically generate\n * implementations for common traits/interfaces.\n *\n * Usage:\n *   @derive(Eq, Ord, Clone, Debug)\n *   interface Point {\n *     x: number;\n *     y: number;\n *   }\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineDeriveMacro,\n  globalRegistry,\n  MacroContext,\n  DeriveTypeInfo,\n  DeriveFieldInfo,\n} from \"@typemacro/core\";\n\n// ============================================================================\n// Eq - Generate equality comparison function\n// ============================================================================\n\nexport const EqDerive = defineDeriveMacro({\n  name: \"Eq\",\n  description: \"Generate an equality comparison function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `${uncapitalize(name)}Eq`;\n\n    // Generate: (a: Type, b: Type) => boolean\n    const comparisons = fields.map(\n      (field) => `a.${field.name} === b.${field.name}`,\n    );\n\n    const body = comparisons.length > 0 ? comparisons.join(\" && \") : \"true\";\n\n    const code = `\nexport function ${fnName}(a: ${name}, b: ${name}): boolean {\n  return ${body};\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Ord - Generate comparison/ordering function\n// ============================================================================\n\nexport const OrdDerive = defineDeriveMacro({\n  name: \"Ord\",\n  description: \"Generate a comparison function for ordering\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `${uncapitalize(name)}Compare`;\n\n    // Generate field comparisons\n    const comparisons = fields\n      .map((field) => {\n        return `\n  if (a.${field.name} < b.${field.name}) return -1;\n  if (a.${field.name} > b.${field.name}) return 1;`;\n      })\n      .join(\"\\n\");\n\n    const code = `\nexport function ${fnName}(a: ${name}, b: ${name}): -1 | 0 | 1 {\n${comparisons}\n  return 0;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Clone - Generate a deep clone function\n// ============================================================================\n\nexport const CloneDerive = defineDeriveMacro({\n  name: \"Clone\",\n  description: \"Generate a deep clone function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `clone${name}`;\n\n    // Generate field copying\n    const copies = fields.map((field) => {\n      // For now, simple copy. Could be enhanced for nested objects\n      return `    ${field.name}: value.${field.name}`;\n    });\n\n    const code = `\nexport function ${fnName}(value: ${name}): ${name} {\n  return {\n${copies.join(\",\\n\")}\n  };\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Debug - Generate a debug string representation\n// ============================================================================\n\nexport const DebugDerive = defineDeriveMacro({\n  name: \"Debug\",\n  description: \"Generate a debug string representation function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `debug${name}`;\n\n    // Generate field string representations\n    const fieldStrs = fields.map(\n      (field) => `\\${JSON.stringify(value.${field.name})}`,\n    );\n\n    const fieldNames = fields.map((f) => f.name);\n    const pairs = fieldNames.map((n, i) => `${n}: ${fieldStrs[i]}`);\n\n    const code = `\nexport function ${fnName}(value: ${name}): string {\n  return \\`${name} { ${pairs.join(\", \")} }\\`;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Hash - Generate a hash function\n// ============================================================================\n\nexport const HashDerive = defineDeriveMacro({\n  name: \"Hash\",\n  description: \"Generate a hash function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `hash${name}`;\n\n    // Simple djb2-style hash\n    const hashCode = fields\n      .map((field) => {\n        const fieldType = getBaseType(field);\n        if (fieldType === \"number\") {\n          return `  hash = ((hash << 5) + hash) + (value.${field.name} | 0);`;\n        } else if (fieldType === \"string\") {\n          return `  for (let i = 0; i < value.${field.name}.length; i++) {\n    hash = ((hash << 5) + hash) + value.${field.name}.charCodeAt(i);\n  }`;\n        } else if (fieldType === \"boolean\") {\n          return `  hash = ((hash << 5) + hash) + (value.${field.name} ? 1 : 0);`;\n        }\n        return `  hash = ((hash << 5) + hash) + String(value.${field.name}).length;`;\n      })\n      .join(\"\\n\");\n\n    const code = `\nexport function ${fnName}(value: ${name}): number {\n  let hash = 5381;\n${hashCode}\n  return hash >>> 0;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Default - Generate a default value factory\n// ============================================================================\n\nexport const DefaultDerive = defineDeriveMacro({\n  name: \"Default\",\n  description: \"Generate a default value factory function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `default${name}`;\n\n    // Generate default values based on type\n    const defaults = fields.map((field) => {\n      const defaultValue = getDefaultForType(field);\n      return `    ${field.name}: ${defaultValue}`;\n    });\n\n    const code = `\nexport function ${fnName}(): ${name} {\n  return {\n${defaults.join(\",\\n\")}\n  };\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// JSON - Generate JSON serialization/deserialization\n// ============================================================================\n\nexport const JsonDerive = defineDeriveMacro({\n  name: \"Json\",\n  description: \"Generate JSON serialization and deserialization functions\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n\n    // Serialize function\n    const serializeCode = `\nexport function ${uncapitalize(name)}ToJson(value: ${name}): string {\n  return JSON.stringify(value);\n}\n`;\n\n    // Deserialize with validation\n    const validations = fields\n      .map((field) => {\n        const baseType = getBaseType(field);\n        const optionalCheck = field.optional\n          ? \"\"\n          : `\n    if (obj.${field.name} === undefined) {\n      throw new Error(\"Missing required field: ${field.name}\");\n    }`;\n        const typeCheck = `\n    if (obj.${field.name} !== undefined && typeof obj.${field.name} !== \"${baseType}\") {\n      throw new Error(\"Field ${field.name} must be ${baseType}\");\n    }`;\n        return optionalCheck + typeCheck;\n      })\n      .join(\"\\n\");\n\n    const deserializeCode = `\nexport function ${uncapitalize(name)}FromJson(json: string): ${name} {\n  const obj = JSON.parse(json);\n${validations}\n  return obj as ${name};\n}\n`;\n\n    return [\n      ...ctx.parseStatements(serializeCode),\n      ...ctx.parseStatements(deserializeCode),\n    ];\n  },\n});\n\n// ============================================================================\n// Builder - Generate a builder pattern\n// ============================================================================\n\nexport const BuilderDerive = defineDeriveMacro({\n  name: \"Builder\",\n  description: \"Generate a builder pattern class\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const builderName = `${name}Builder`;\n\n    // Generate setter methods\n    const setters = fields\n      .map((field) => {\n        const methodName = `with${capitalize(field.name)}`;\n        return `\n  ${methodName}(${field.name}: ${field.typeString}): ${builderName} {\n    this._${field.name} = ${field.name};\n    return this;\n  }`;\n      })\n      .join(\"\\n\");\n\n    // Generate private fields\n    const privateFields = fields\n      .map((field) => {\n        const defaultValue = getDefaultForType(field);\n        return `  private _${field.name}: ${field.typeString} = ${defaultValue};`;\n      })\n      .join(\"\\n\");\n\n    // Generate build method\n    const buildProps = fields\n      .map((field) => `      ${field.name}: this._${field.name}`)\n      .join(\",\\n\");\n\n    const code = `\nexport class ${builderName} {\n${privateFields}\n\n${setters}\n\n  build(): ${name} {\n    return {\n${buildProps}\n    };\n  }\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction uncapitalize(str: string): string {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction getBaseType(field: DeriveFieldInfo): string {\n  const typeStr = field.typeString.toLowerCase();\n  if (typeStr === \"number\" || typeStr.includes(\"number\")) return \"number\";\n  if (typeStr === \"string\" || typeStr.includes(\"string\")) return \"string\";\n  if (typeStr === \"boolean\" || typeStr.includes(\"boolean\")) return \"boolean\";\n  if (typeStr.startsWith(\"array\") || typeStr.includes(\"[]\")) return \"object\";\n  return \"object\";\n}\n\nfunction getDefaultForType(field: DeriveFieldInfo): string {\n  if (field.optional) {\n    return \"undefined\";\n  }\n\n  const baseType = getBaseType(field);\n  switch (baseType) {\n    case \"number\":\n      return \"0\";\n    case \"string\":\n      return '\"\"';\n    case \"boolean\":\n      return \"false\";\n    default:\n      return \"{}\";\n  }\n}\n\n// ============================================================================\n// Export all derive macros as a collection\n// ============================================================================\n\nexport const deriveMacros = {\n  Eq: EqDerive,\n  Ord: OrdDerive,\n  Clone: CloneDerive,\n  Debug: DebugDerive,\n  Hash: HashDerive,\n  Default: DefaultDerive,\n  Json: JsonDerive,\n  Builder: BuilderDerive,\n};\n\n/**\n * Create a derived function name based on convention\n */\nexport function createDerivedFunctionName(\n  operation: string,\n  typeName: string,\n): string {\n  switch (operation) {\n    case \"eq\":\n      return `${uncapitalize(typeName)}Eq`;\n    case \"ord\":\n      return `${uncapitalize(typeName)}Ord`;\n    case \"compare\":\n      return `${uncapitalize(typeName)}Compare`;\n    case \"clone\":\n      return `clone${typeName}`;\n    case \"debug\":\n      return `debug${typeName}`;\n    case \"hash\":\n      return `hash${typeName}`;\n    case \"default\":\n      return `default${typeName}`;\n    case \"toJson\":\n      return `${uncapitalize(typeName)}ToJson`;\n    case \"fromJson\":\n      return `${uncapitalize(typeName)}FromJson`;\n    default:\n      return `${uncapitalize(typeName)}${capitalize(operation)}`;\n  }\n}\n\n/**\n * Register macros with the global registry.\n * Call this function to enable derive macros in your project.\n */\nexport function register(): void {\n  globalRegistry.register(EqDerive);\n  globalRegistry.register(OrdDerive);\n  globalRegistry.register(CloneDerive);\n  globalRegistry.register(DebugDerive);\n  globalRegistry.register(HashDerive);\n  globalRegistry.register(DefaultDerive);\n  globalRegistry.register(JsonDerive);\n  globalRegistry.register(BuilderDerive);\n}\n\n// Auto-register when this module is imported\nregister();\n"],"mappings":"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","names":[]}