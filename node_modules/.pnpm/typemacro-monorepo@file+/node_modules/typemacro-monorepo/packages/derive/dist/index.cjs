"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BuilderDerive: () => BuilderDerive,
  CloneDerive: () => CloneDerive,
  DebugDerive: () => DebugDerive,
  DefaultDerive: () => DefaultDerive,
  EqDerive: () => EqDerive,
  HashDerive: () => HashDerive,
  JsonDerive: () => JsonDerive,
  OrdDerive: () => OrdDerive,
  createDerivedFunctionName: () => createDerivedFunctionName,
  deriveMacros: () => deriveMacros,
  register: () => register
});
module.exports = __toCommonJS(index_exports);
var import_core = require("@typemacro/core");
var EqDerive = (0, import_core.defineDeriveMacro)({
  name: "Eq",
  description: "Generate an equality comparison function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `${uncapitalize(name)}Eq`;
    const comparisons = fields.map(
      (field) => `a.${field.name} === b.${field.name}`
    );
    const body = comparisons.length > 0 ? comparisons.join(" && ") : "true";
    const code = `
export function ${fnName}(a: ${name}, b: ${name}): boolean {
  return ${body};
}
`;
    return ctx.parseStatements(code);
  }
});
var OrdDerive = (0, import_core.defineDeriveMacro)({
  name: "Ord",
  description: "Generate a comparison function for ordering",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `${uncapitalize(name)}Compare`;
    const comparisons = fields.map((field) => {
      return `
  if (a.${field.name} < b.${field.name}) return -1;
  if (a.${field.name} > b.${field.name}) return 1;`;
    }).join("\n");
    const code = `
export function ${fnName}(a: ${name}, b: ${name}): -1 | 0 | 1 {
${comparisons}
  return 0;
}
`;
    return ctx.parseStatements(code);
  }
});
var CloneDerive = (0, import_core.defineDeriveMacro)({
  name: "Clone",
  description: "Generate a deep clone function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `clone${name}`;
    const copies = fields.map((field) => {
      return `    ${field.name}: value.${field.name}`;
    });
    const code = `
export function ${fnName}(value: ${name}): ${name} {
  return {
${copies.join(",\n")}
  };
}
`;
    return ctx.parseStatements(code);
  }
});
var DebugDerive = (0, import_core.defineDeriveMacro)({
  name: "Debug",
  description: "Generate a debug string representation function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `debug${name}`;
    const fieldStrs = fields.map(
      (field) => `\${JSON.stringify(value.${field.name})}`
    );
    const fieldNames = fields.map((f) => f.name);
    const pairs = fieldNames.map((n, i) => `${n}: ${fieldStrs[i]}`);
    const code = `
export function ${fnName}(value: ${name}): string {
  return \`${name} { ${pairs.join(", ")} }\`;
}
`;
    return ctx.parseStatements(code);
  }
});
var HashDerive = (0, import_core.defineDeriveMacro)({
  name: "Hash",
  description: "Generate a hash function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `hash${name}`;
    const hashCode = fields.map((field) => {
      const fieldType = getBaseType(field);
      if (fieldType === "number") {
        return `  hash = ((hash << 5) + hash) + (value.${field.name} | 0);`;
      } else if (fieldType === "string") {
        return `  for (let i = 0; i < value.${field.name}.length; i++) {
    hash = ((hash << 5) + hash) + value.${field.name}.charCodeAt(i);
  }`;
      } else if (fieldType === "boolean") {
        return `  hash = ((hash << 5) + hash) + (value.${field.name} ? 1 : 0);`;
      }
      return `  hash = ((hash << 5) + hash) + String(value.${field.name}).length;`;
    }).join("\n");
    const code = `
export function ${fnName}(value: ${name}): number {
  let hash = 5381;
${hashCode}
  return hash >>> 0;
}
`;
    return ctx.parseStatements(code);
  }
});
var DefaultDerive = (0, import_core.defineDeriveMacro)({
  name: "Default",
  description: "Generate a default value factory function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `default${name}`;
    const defaults = fields.map((field) => {
      const defaultValue = getDefaultForType(field);
      return `    ${field.name}: ${defaultValue}`;
    });
    const code = `
export function ${fnName}(): ${name} {
  return {
${defaults.join(",\n")}
  };
}
`;
    return ctx.parseStatements(code);
  }
});
var JsonDerive = (0, import_core.defineDeriveMacro)({
  name: "Json",
  description: "Generate JSON serialization and deserialization functions",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const serializeCode = `
export function ${uncapitalize(name)}ToJson(value: ${name}): string {
  return JSON.stringify(value);
}
`;
    const validations = fields.map((field) => {
      const baseType = getBaseType(field);
      const optionalCheck = field.optional ? "" : `
    if (obj.${field.name} === undefined) {
      throw new Error("Missing required field: ${field.name}");
    }`;
      const typeCheck = `
    if (obj.${field.name} !== undefined && typeof obj.${field.name} !== "${baseType}") {
      throw new Error("Field ${field.name} must be ${baseType}");
    }`;
      return optionalCheck + typeCheck;
    }).join("\n");
    const deserializeCode = `
export function ${uncapitalize(name)}FromJson(json: string): ${name} {
  const obj = JSON.parse(json);
${validations}
  return obj as ${name};
}
`;
    return [
      ...ctx.parseStatements(serializeCode),
      ...ctx.parseStatements(deserializeCode)
    ];
  }
});
var BuilderDerive = (0, import_core.defineDeriveMacro)({
  name: "Builder",
  description: "Generate a builder pattern class",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const builderName = `${name}Builder`;
    const setters = fields.map((field) => {
      const methodName = `with${capitalize(field.name)}`;
      return `
  ${methodName}(${field.name}: ${field.typeString}): ${builderName} {
    this._${field.name} = ${field.name};
    return this;
  }`;
    }).join("\n");
    const privateFields = fields.map((field) => {
      const defaultValue = getDefaultForType(field);
      return `  private _${field.name}: ${field.typeString} = ${defaultValue};`;
    }).join("\n");
    const buildProps = fields.map((field) => `      ${field.name}: this._${field.name}`).join(",\n");
    const code = `
export class ${builderName} {
${privateFields}

${setters}

  build(): ${name} {
    return {
${buildProps}
    };
  }
}
`;
    return ctx.parseStatements(code);
  }
});
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getBaseType(field) {
  const typeStr = field.typeString.toLowerCase();
  if (typeStr === "number" || typeStr.includes("number")) return "number";
  if (typeStr === "string" || typeStr.includes("string")) return "string";
  if (typeStr === "boolean" || typeStr.includes("boolean")) return "boolean";
  if (typeStr.startsWith("array") || typeStr.includes("[]")) return "object";
  return "object";
}
function getDefaultForType(field) {
  if (field.optional) {
    return "undefined";
  }
  const baseType = getBaseType(field);
  switch (baseType) {
    case "number":
      return "0";
    case "string":
      return '""';
    case "boolean":
      return "false";
    default:
      return "{}";
  }
}
var deriveMacros = {
  Eq: EqDerive,
  Ord: OrdDerive,
  Clone: CloneDerive,
  Debug: DebugDerive,
  Hash: HashDerive,
  Default: DefaultDerive,
  Json: JsonDerive,
  Builder: BuilderDerive
};
function createDerivedFunctionName(operation, typeName) {
  switch (operation) {
    case "eq":
      return `${uncapitalize(typeName)}Eq`;
    case "ord":
      return `${uncapitalize(typeName)}Ord`;
    case "compare":
      return `${uncapitalize(typeName)}Compare`;
    case "clone":
      return `clone${typeName}`;
    case "debug":
      return `debug${typeName}`;
    case "hash":
      return `hash${typeName}`;
    case "default":
      return `default${typeName}`;
    case "toJson":
      return `${uncapitalize(typeName)}ToJson`;
    case "fromJson":
      return `${uncapitalize(typeName)}FromJson`;
    default:
      return `${uncapitalize(typeName)}${capitalize(operation)}`;
  }
}
function register() {
  import_core.globalRegistry.register(EqDerive);
  import_core.globalRegistry.register(OrdDerive);
  import_core.globalRegistry.register(CloneDerive);
  import_core.globalRegistry.register(DebugDerive);
  import_core.globalRegistry.register(HashDerive);
  import_core.globalRegistry.register(DefaultDerive);
  import_core.globalRegistry.register(JsonDerive);
  import_core.globalRegistry.register(BuilderDerive);
}
register();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BuilderDerive,
  CloneDerive,
  DebugDerive,
  DefaultDerive,
  EqDerive,
  HashDerive,
  JsonDerive,
  OrdDerive,
  createDerivedFunctionName,
  deriveMacros,
  register
});
//# sourceMappingURL=index.cjs.map