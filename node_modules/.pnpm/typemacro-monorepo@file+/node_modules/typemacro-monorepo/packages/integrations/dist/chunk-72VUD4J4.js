// src/unplugin.ts
import * as ts from "typescript";
import * as path from "path";
import { createUnplugin } from "unplugin";
import macroTransformerFactory from "@typemacro/transformer";
function findTsConfig(cwd, explicit) {
  if (explicit) {
    return path.resolve(cwd, explicit);
  }
  const found = ts.findConfigFile(cwd, ts.sys.fileExists, "tsconfig.json");
  if (!found) {
    throw new Error(
      `[typemacro] Could not find tsconfig.json from ${cwd}. Pass the tsconfig option to specify the path explicitly.`
    );
  }
  return found;
}
function createProgram2(configPath) {
  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
  if (configFile.error) {
    throw new Error(
      `[typemacro] Error reading ${configPath}: ${ts.flattenDiagnosticMessageText(configFile.error.messageText, "\n")}`
    );
  }
  const config = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    path.dirname(configPath)
  );
  const host = ts.createCompilerHost(config.options);
  const program = ts.createProgram(config.fileNames, config.options, host);
  return { program, host, config };
}
function shouldTransform(id, include, exclude) {
  const normalizedId = id.replace(/\\/g, "/");
  if (exclude) {
    if (exclude instanceof RegExp) {
      if (exclude.test(normalizedId)) return false;
    } else {
      if (exclude.some((pattern) => normalizedId.includes(pattern)))
        return false;
    }
  } else {
    if (/node_modules/.test(normalizedId)) return false;
  }
  if (include) {
    if (include instanceof RegExp) {
      return include.test(normalizedId);
    }
    return include.some((pattern) => normalizedId.includes(pattern));
  }
  return /\.[jt]sx?$/.test(normalizedId);
}
var unpluginFactory = (options = {}) => {
  let cache;
  const verbose = options?.verbose ?? false;
  return {
    name: "typemacro",
    enforce: "pre",
    buildStart() {
      try {
        const configPath = findTsConfig(process.cwd(), options?.tsconfig);
        cache = createProgram2(configPath);
        if (verbose) {
          console.log(`[typemacro] Loaded config from ${configPath}`);
          console.log(
            `[typemacro] Program has ${cache.config.fileNames.length} files`
          );
        }
      } catch (error) {
        console.error(String(error));
      }
    },
    transformInclude(id) {
      return shouldTransform(id, options?.include, options?.exclude);
    },
    transform(code, id) {
      if (!cache) return null;
      const sourceFile = cache.program.getSourceFile(id);
      if (!sourceFile) {
        if (verbose) {
          console.log(`[typemacro] Skipping ${id} (not in program)`);
        }
        return null;
      }
      const transformerConfig = { verbose };
      const result = ts.transform(sourceFile, [
        macroTransformerFactory(cache.program, transformerConfig)
      ]);
      if (result.transformed.length === 0) {
        result.dispose();
        return null;
      }
      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
      const transformed = printer.printFile(result.transformed[0]);
      result.dispose();
      if (transformed === code) return null;
      return {
        code: transformed,
        // TODO: generate proper source map from the transformation
        map: null
      };
    }
  };
};
var unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);

export {
  unpluginFactory,
  unplugin
};
//# sourceMappingURL=chunk-72VUD4J4.js.map