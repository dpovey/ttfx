{"version":3,"sources":["../src/rollup.ts","../src/unplugin.ts"],"sourcesContent":["/**\n * typemacro Rollup plugin\n *\n * @example\n * ```ts\n * // rollup.config.js\n * import typemacro from \"@typemacro/integrations/rollup\";\n *\n * export default {\n *   plugins: [typemacro()],\n * };\n * ```\n */\n\nimport { unplugin, type TypeMacroPluginOptions } from \"./unplugin.js\";\n\nexport default unplugin.rollup;\nexport type { TypeMacroPluginOptions };\n","/**\n * typemacro unplugin integration\n *\n * Universal plugin that works with Vite, Rollup, Webpack, esbuild, and Rspack.\n * Uses the TypeScript compiler API to create a Program, then runs the macro\n * transformer on each .ts/.tsx file during the build.\n */\n\nimport * as ts from \"typescript\";\nimport * as path from \"path\";\nimport { createUnplugin, type UnpluginFactory } from \"unplugin\";\nimport macroTransformerFactory, {\n  type MacroTransformerConfig,\n} from \"@typemacro/transformer\";\n\nexport interface TypeMacroPluginOptions {\n  /** Path to tsconfig.json (default: auto-detected) */\n  tsconfig?: string;\n\n  /** File patterns to include (default: /\\.[jt]sx?$/) */\n  include?: RegExp | string[];\n\n  /** File patterns to exclude (default: /node_modules/) */\n  exclude?: RegExp | string[];\n\n  /** Enable verbose logging */\n  verbose?: boolean;\n}\n\ninterface ProgramCache {\n  program: ts.Program;\n  host: ts.CompilerHost;\n  config: ts.ParsedCommandLine;\n}\n\nfunction findTsConfig(cwd: string, explicit?: string): string {\n  if (explicit) {\n    return path.resolve(cwd, explicit);\n  }\n\n  const found = ts.findConfigFile(cwd, ts.sys.fileExists, \"tsconfig.json\");\n  if (!found) {\n    throw new Error(\n      `[typemacro] Could not find tsconfig.json from ${cwd}. ` +\n        `Pass the tsconfig option to specify the path explicitly.`,\n    );\n  }\n  return found;\n}\n\nfunction createProgram(configPath: string): ProgramCache {\n  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);\n  if (configFile.error) {\n    throw new Error(\n      `[typemacro] Error reading ${configPath}: ${ts.flattenDiagnosticMessageText(configFile.error.messageText, \"\\n\")}`,\n    );\n  }\n\n  const config = ts.parseJsonConfigFileContent(\n    configFile.config,\n    ts.sys,\n    path.dirname(configPath),\n  );\n\n  const host = ts.createCompilerHost(config.options);\n  const program = ts.createProgram(config.fileNames, config.options, host);\n\n  return { program, host, config };\n}\n\nfunction shouldTransform(\n  id: string,\n  include?: RegExp | string[],\n  exclude?: RegExp | string[],\n): boolean {\n  const normalizedId = id.replace(/\\\\/g, \"/\");\n\n  // Check exclude first\n  if (exclude) {\n    if (exclude instanceof RegExp) {\n      if (exclude.test(normalizedId)) return false;\n    } else {\n      if (exclude.some((pattern) => normalizedId.includes(pattern)))\n        return false;\n    }\n  } else {\n    if (/node_modules/.test(normalizedId)) return false;\n  }\n\n  // Check include\n  if (include) {\n    if (include instanceof RegExp) {\n      return include.test(normalizedId);\n    }\n    return include.some((pattern) => normalizedId.includes(pattern));\n  }\n\n  return /\\.[jt]sx?$/.test(normalizedId);\n}\n\nexport const unpluginFactory: UnpluginFactory<\n  TypeMacroPluginOptions | undefined\n> = (options = {}) => {\n  let cache: ProgramCache | undefined;\n  const verbose = options?.verbose ?? false;\n\n  return {\n    name: \"typemacro\",\n    enforce: \"pre\",\n\n    buildStart() {\n      try {\n        const configPath = findTsConfig(process.cwd(), options?.tsconfig);\n        cache = createProgram(configPath);\n        if (verbose) {\n          console.log(`[typemacro] Loaded config from ${configPath}`);\n          console.log(\n            `[typemacro] Program has ${cache.config.fileNames.length} files`,\n          );\n        }\n      } catch (error) {\n        console.error(String(error));\n      }\n    },\n\n    transformInclude(id) {\n      return shouldTransform(id, options?.include, options?.exclude);\n    },\n\n    transform(code, id) {\n      if (!cache) return null;\n\n      const sourceFile = cache.program.getSourceFile(id);\n      if (!sourceFile) {\n        // File not in the TS program -- skip\n        if (verbose) {\n          console.log(`[typemacro] Skipping ${id} (not in program)`);\n        }\n        return null;\n      }\n\n      const transformerConfig: MacroTransformerConfig = { verbose };\n\n      // Run the macro transformer\n      const result = ts.transform(sourceFile, [\n        macroTransformerFactory(cache.program, transformerConfig),\n      ]);\n\n      if (result.transformed.length === 0) {\n        result.dispose();\n        return null;\n      }\n\n      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n      const transformed = printer.printFile(result.transformed[0]);\n      result.dispose();\n\n      // Only return if the code actually changed\n      if (transformed === code) return null;\n\n      return {\n        code: transformed,\n        // TODO: generate proper source map from the transformation\n        map: null,\n      };\n    },\n  };\n};\n\nexport const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACQA,SAAoB;AACpB,WAAsB;AACtB,sBAAqD;AACrD,yBAEO;AAsBP,SAAS,aAAa,KAAa,UAA2B;AAC5D,MAAI,UAAU;AACZ,WAAY,aAAQ,KAAK,QAAQ;AAAA,EACnC;AAEA,QAAM,QAAW,kBAAe,KAAQ,OAAI,YAAY,eAAe;AACvE,MAAI,CAAC,OAAO;AACV,UAAM,IAAI;AAAA,MACR,iDAAiD,GAAG;AAAA,IAEtD;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAASA,eAAc,YAAkC;AACvD,QAAM,aAAgB,kBAAe,YAAe,OAAI,QAAQ;AAChE,MAAI,WAAW,OAAO;AACpB,UAAM,IAAI;AAAA,MACR,6BAA6B,UAAU,KAAQ,gCAA6B,WAAW,MAAM,aAAa,IAAI,CAAC;AAAA,IACjH;AAAA,EACF;AAEA,QAAM,SAAY;AAAA,IAChB,WAAW;AAAA,IACR;AAAA,IACE,aAAQ,UAAU;AAAA,EACzB;AAEA,QAAM,OAAU,sBAAmB,OAAO,OAAO;AACjD,QAAM,UAAa,iBAAc,OAAO,WAAW,OAAO,SAAS,IAAI;AAEvE,SAAO,EAAE,SAAS,MAAM,OAAO;AACjC;AAEA,SAAS,gBACP,IACA,SACA,SACS;AACT,QAAM,eAAe,GAAG,QAAQ,OAAO,GAAG;AAG1C,MAAI,SAAS;AACX,QAAI,mBAAmB,QAAQ;AAC7B,UAAI,QAAQ,KAAK,YAAY,EAAG,QAAO;AAAA,IACzC,OAAO;AACL,UAAI,QAAQ,KAAK,CAAC,YAAY,aAAa,SAAS,OAAO,CAAC;AAC1D,eAAO;AAAA,IACX;AAAA,EACF,OAAO;AACL,QAAI,eAAe,KAAK,YAAY,EAAG,QAAO;AAAA,EAChD;AAGA,MAAI,SAAS;AACX,QAAI,mBAAmB,QAAQ;AAC7B,aAAO,QAAQ,KAAK,YAAY;AAAA,IAClC;AACA,WAAO,QAAQ,KAAK,CAAC,YAAY,aAAa,SAAS,OAAO,CAAC;AAAA,EACjE;AAEA,SAAO,aAAa,KAAK,YAAY;AACvC;AAEO,IAAM,kBAET,CAAC,UAAU,CAAC,MAAM;AACpB,MAAI;AACJ,QAAM,UAAU,SAAS,WAAW;AAEpC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,IAET,aAAa;AACX,UAAI;AACF,cAAM,aAAa,aAAa,QAAQ,IAAI,GAAG,SAAS,QAAQ;AAChE,gBAAQA,eAAc,UAAU;AAChC,YAAI,SAAS;AACX,kBAAQ,IAAI,kCAAkC,UAAU,EAAE;AAC1D,kBAAQ;AAAA,YACN,2BAA2B,MAAM,OAAO,UAAU,MAAM;AAAA,UAC1D;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,MAAM,OAAO,KAAK,CAAC;AAAA,MAC7B;AAAA,IACF;AAAA,IAEA,iBAAiB,IAAI;AACnB,aAAO,gBAAgB,IAAI,SAAS,SAAS,SAAS,OAAO;AAAA,IAC/D;AAAA,IAEA,UAAU,MAAM,IAAI;AAClB,UAAI,CAAC,MAAO,QAAO;AAEnB,YAAM,aAAa,MAAM,QAAQ,cAAc,EAAE;AACjD,UAAI,CAAC,YAAY;AAEf,YAAI,SAAS;AACX,kBAAQ,IAAI,wBAAwB,EAAE,mBAAmB;AAAA,QAC3D;AACA,eAAO;AAAA,MACT;AAEA,YAAM,oBAA4C,EAAE,QAAQ;AAG5D,YAAM,SAAY,aAAU,YAAY;AAAA,YACtC,mBAAAC,SAAwB,MAAM,SAAS,iBAAiB;AAAA,MAC1D,CAAC;AAED,UAAI,OAAO,YAAY,WAAW,GAAG;AACnC,eAAO,QAAQ;AACf,eAAO;AAAA,MACT;AAEA,YAAM,UAAa,iBAAc,EAAE,SAAY,eAAY,SAAS,CAAC;AACrE,YAAM,cAAc,QAAQ,UAAU,OAAO,YAAY,CAAC,CAAC;AAC3D,aAAO,QAAQ;AAGf,UAAI,gBAAgB,KAAM,QAAO;AAEjC,aAAO;AAAA,QACL,MAAM;AAAA;AAAA,QAEN,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,WAA2B,oDAAe,eAAe;;;ADzJtE,IAAO,iBAAQ,SAAS;","names":["createProgram","macroTransformerFactory"]}