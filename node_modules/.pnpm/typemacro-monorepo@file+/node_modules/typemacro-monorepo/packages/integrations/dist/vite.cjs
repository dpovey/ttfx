"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/vite.ts
var vite_exports = {};
__export(vite_exports, {
  default: () => vite_default
});
module.exports = __toCommonJS(vite_exports);

// src/unplugin.ts
var ts = __toESM(require("typescript"), 1);
var path = __toESM(require("path"), 1);
var import_unplugin = require("unplugin");
var import_transformer = __toESM(require("@typemacro/transformer"), 1);
function findTsConfig(cwd, explicit) {
  if (explicit) {
    return path.resolve(cwd, explicit);
  }
  const found = ts.findConfigFile(cwd, ts.sys.fileExists, "tsconfig.json");
  if (!found) {
    throw new Error(
      `[typemacro] Could not find tsconfig.json from ${cwd}. Pass the tsconfig option to specify the path explicitly.`
    );
  }
  return found;
}
function createProgram2(configPath) {
  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
  if (configFile.error) {
    throw new Error(
      `[typemacro] Error reading ${configPath}: ${ts.flattenDiagnosticMessageText(configFile.error.messageText, "\n")}`
    );
  }
  const config = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    path.dirname(configPath)
  );
  const host = ts.createCompilerHost(config.options);
  const program = ts.createProgram(config.fileNames, config.options, host);
  return { program, host, config };
}
function shouldTransform(id, include, exclude) {
  const normalizedId = id.replace(/\\/g, "/");
  if (exclude) {
    if (exclude instanceof RegExp) {
      if (exclude.test(normalizedId)) return false;
    } else {
      if (exclude.some((pattern) => normalizedId.includes(pattern)))
        return false;
    }
  } else {
    if (/node_modules/.test(normalizedId)) return false;
  }
  if (include) {
    if (include instanceof RegExp) {
      return include.test(normalizedId);
    }
    return include.some((pattern) => normalizedId.includes(pattern));
  }
  return /\.[jt]sx?$/.test(normalizedId);
}
var unpluginFactory = (options = {}) => {
  let cache;
  const verbose = options?.verbose ?? false;
  return {
    name: "typemacro",
    enforce: "pre",
    buildStart() {
      try {
        const configPath = findTsConfig(process.cwd(), options?.tsconfig);
        cache = createProgram2(configPath);
        if (verbose) {
          console.log(`[typemacro] Loaded config from ${configPath}`);
          console.log(
            `[typemacro] Program has ${cache.config.fileNames.length} files`
          );
        }
      } catch (error) {
        console.error(String(error));
      }
    },
    transformInclude(id) {
      return shouldTransform(id, options?.include, options?.exclude);
    },
    transform(code, id) {
      if (!cache) return null;
      const sourceFile = cache.program.getSourceFile(id);
      if (!sourceFile) {
        if (verbose) {
          console.log(`[typemacro] Skipping ${id} (not in program)`);
        }
        return null;
      }
      const transformerConfig = { verbose };
      const result = ts.transform(sourceFile, [
        (0, import_transformer.default)(cache.program, transformerConfig)
      ]);
      if (result.transformed.length === 0) {
        result.dispose();
        return null;
      }
      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
      const transformed = printer.printFile(result.transformed[0]);
      result.dispose();
      if (transformed === code) return null;
      return {
        code: transformed,
        // TODO: generate proper source map from the transformation
        map: null
      };
    }
  };
};
var unplugin = /* @__PURE__ */ (0, import_unplugin.createUnplugin)(unpluginFactory);

// src/vite.ts
var vite_default = unplugin.vite;
//# sourceMappingURL=vite.cjs.map