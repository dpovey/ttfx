{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/macro.ts"],"sourcesContent":["/**\n * @typemacro/sql - Doobie-like Type-Safe SQL DSL\n *\n * This module provides:\n * - Fragment class for composable SQL building\n * - Query and Update wrappers with type branding\n * - ConnectionIO for pure database operation descriptions\n * - Transactor for interpreting ConnectionIO programs\n * - sql`` macro for compile-time SQL validation\n *\n * @example\n * ```typescript\n * import { sql, Fragment, Query, Transactor } from \"@typemacro/sql\";\n *\n * const name = \"Alice\";\n * const age = 30;\n *\n * const query = sql`SELECT * FROM users WHERE name = ${name} AND age > ${age}`;\n * console.log(query.text);   // \"SELECT * FROM users WHERE name = $1 AND age > $2\"\n * console.log(query.params); // [\"Alice\", 30]\n * ```\n */\n\n// Re-export types and classes\nexport type { SqlParam, DbConnection } from \"./types.js\";\nexport { Fragment, Query, Update, ConnectionIO, Transactor } from \"./types.js\";\n\n// Re-export macro\nexport { sqlMacro, register } from \"./macro.js\";\n\n// ============================================================================\n// Runtime Helper (used by the sql macro)\n// ============================================================================\n\nimport { Fragment, SqlParam } from \"./types.js\";\n\n/**\n * Runtime helper for sql`` macro.\n *\n * Handles both Fragment interpolations (which get inlined) and\n * plain values (which become bound parameters).\n */\nexport function __sql_build(\n  segments: string[],\n  interpolations: unknown[],\n): Fragment {\n  const resultSegments: string[] = [];\n  const resultParams: SqlParam[] = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i === 0) {\n      resultSegments.push(segments[i]);\n    } else {\n      const interp = interpolations[i - 1];\n\n      if (interp instanceof Fragment) {\n        // Inline the fragment\n        const lastIdx = resultSegments.length - 1;\n        resultSegments[lastIdx] += interp.segments[0];\n        for (let j = 1; j < interp.segments.length; j++) {\n          resultSegments.push(interp.segments[j]);\n        }\n        resultParams.push(...interp.params);\n        // Append the next segment to the last one\n        resultSegments[resultSegments.length - 1] += segments[i];\n      } else {\n        // It's a plain parameter\n        resultParams.push(interp as SqlParam);\n        resultSegments.push(segments[i]);\n      }\n    }\n  }\n\n  return new Fragment(resultSegments, resultParams);\n}\n\n// ============================================================================\n// Prototype Extensions for Fragment\n// ============================================================================\n\ndeclare module \"./types.js\" {\n  interface Fragment {\n    /** Convert this fragment to a typed Query */\n    toQuery<R>(): Query<R>;\n    /** Convert this fragment to an Update */\n    toUpdate(): Update;\n  }\n}\n\nimport { Query, Update } from \"./types.js\";\n\nFragment.prototype.toQuery = function <R>(): Query<R> {\n  return new Query<R>(this);\n};\n\nFragment.prototype.toUpdate = function (): Update {\n  return new Update(this);\n};\n\n// ============================================================================\n// Fallback sql function for non-macro usage\n// ============================================================================\n\n/**\n * Tagged template function for SQL - fallback when macro transform isn't applied.\n *\n * This allows the same code to work even without the macro transformer,\n * though you lose compile-time validation.\n */\nexport function sql(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): Fragment {\n  return __sql_build([...strings], values);\n}\n","/**\n * Doobie-like Type-Safe SQL DSL\n *\n * Inspired by Scala's Doobie library, this module provides composable SQL\n * fragments with type-safe parameter binding. SQL statements are built from\n * fragments that can be combined, nested, and composed — parameters are\n * tracked and flattened automatically.\n *\n * Key concepts:\n * - Fragment: an SQL string paired with its bound parameters\n * - Fragments compose via concatenation, AND/OR combinators, IN lists, etc.\n * - The sql`` tagged template is the primary entry point\n * - Parameters are always positional ($1, $2, …) in the final output\n *\n * @example\n * ```typescript\n * const name = \"Alice\";\n * const age = 30;\n *\n * const base = sql`SELECT * FROM users`;\n * const cond = sql`WHERE name = ${name} AND age > ${age}`;\n * const query = base.append(cond);\n *\n * query.text;   // \"SELECT * FROM users WHERE name = $1 AND age > $2\"\n * query.params; // [\"Alice\", 30]\n * ```\n */\n\n// ============================================================================\n// Param Types\n// ============================================================================\n\n/** Values that can be bound as SQL parameters */\nexport type SqlParam =\n  | string\n  | number\n  | boolean\n  | null\n  | Date\n  | Buffer\n  | SqlParam[];\n\n// ============================================================================\n// Fragment — the core composable SQL building block\n// ============================================================================\n\n/**\n * An SQL fragment: a piece of SQL text with associated parameters.\n *\n * Fragments are the fundamental unit of composition. They track raw SQL\n * segments and parameter values separately, then render to a final\n * parameterised query string on demand.\n *\n * Immutable — every combinator returns a new Fragment.\n */\nexport class Fragment {\n  /**\n   * @param segments - Raw SQL text segments (one more than params)\n   * @param params  - Bound parameter values, interleaved between segments\n   */\n  constructor(\n    readonly segments: readonly string[],\n    readonly params: readonly SqlParam[],\n  ) {}\n\n  // --------------------------------------------------------------------------\n  // Rendering\n  // --------------------------------------------------------------------------\n\n  /** Render to a parameterised query with positional placeholders ($1, $2, …) */\n  get query(): { text: string; params: readonly SqlParam[] } {\n    const allParams: SqlParam[] = [];\n    const parts: string[] = [];\n\n    for (let i = 0; i < this.segments.length; i++) {\n      parts.push(this.segments[i]);\n      if (i < this.params.length) {\n        const param = this.params[i];\n        if (param instanceof Fragment) {\n          // Nested fragment — inline its SQL and collect its params\n          const nested = param.query;\n          // Re-number the nested placeholders\n          const offset = allParams.length;\n          const renumbered = nested.text.replace(\n            /\\$(\\d+)/g,\n            (_, n) => `$${parseInt(n) + offset}`,\n          );\n          parts.push(renumbered);\n          allParams.push(...nested.params);\n        } else {\n          allParams.push(param);\n          parts.push(`$${allParams.length}`);\n        }\n      }\n    }\n\n    return { text: parts.join(\"\"), params: allParams };\n  }\n\n  /** Shorthand: rendered SQL text */\n  get text(): string {\n    return this.query.text;\n  }\n\n  /** Shorthand: rendered parameter array */\n  get values(): readonly SqlParam[] {\n    return this.query.params;\n  }\n\n  // --------------------------------------------------------------------------\n  // Composition\n  // --------------------------------------------------------------------------\n\n  /** Concatenate two fragments with a space separator */\n  append(other: Fragment): Fragment {\n    return Fragment.concat(this, other);\n  }\n\n  /** Prepend another fragment */\n  prepend(other: Fragment): Fragment {\n    return Fragment.concat(other, this);\n  }\n\n  /** Wrap with parentheses */\n  parens(): Fragment {\n    return Fragment.raw(\"(\")\n      .appendNoSpace(this)\n      .appendNoSpace(Fragment.raw(\")\"));\n  }\n\n  /** Concatenate without adding a space */\n  appendNoSpace(other: Fragment): Fragment {\n    // Merge the last segment of `this` with the first segment of `other`\n    const newSegments = [\n      ...this.segments.slice(0, -1),\n      this.segments[this.segments.length - 1] + other.segments[0],\n      ...other.segments.slice(1),\n    ];\n    return new Fragment(newSegments, [...this.params, ...other.params]);\n  }\n\n  // --------------------------------------------------------------------------\n  // SQL Combinators\n  // --------------------------------------------------------------------------\n\n  /** Join fragments with AND */\n  static and(fragments: Fragment[]): Fragment {\n    return Fragment.intercalate(Fragment.raw(\" AND \"), fragments);\n  }\n\n  /** Join fragments with OR (wrapped in parens for safety) */\n  static or(fragments: Fragment[]): Fragment {\n    return Fragment.intercalate(Fragment.raw(\" OR \"), fragments).parens();\n  }\n\n  /** Join fragments with a separator */\n  static intercalate(sep: Fragment, fragments: Fragment[]): Fragment {\n    if (fragments.length === 0) return Fragment.empty;\n    let result = fragments[0];\n    for (let i = 1; i < fragments.length; i++) {\n      result = result.appendNoSpace(sep).appendNoSpace(fragments[i]);\n    }\n    return result;\n  }\n\n  /** Comma-separated list */\n  static commas(fragments: Fragment[]): Fragment {\n    return Fragment.intercalate(Fragment.raw(\", \"), fragments);\n  }\n\n  /** Concatenate two fragments with a space */\n  static concat(a: Fragment, b: Fragment): Fragment {\n    // Join with a space between the last segment of a and first segment of b\n    const newSegments = [\n      ...a.segments.slice(0, -1),\n      a.segments[a.segments.length - 1] + \" \" + b.segments[0],\n      ...b.segments.slice(1),\n    ];\n    return new Fragment(newSegments, [...a.params, ...b.params]);\n  }\n\n  // --------------------------------------------------------------------------\n  // Constructors\n  // --------------------------------------------------------------------------\n\n  /** Empty fragment */\n  static readonly empty = new Fragment([\"\"], []);\n\n  /** Raw SQL with no parameters */\n  static raw(sql: string): Fragment {\n    return new Fragment([sql], []);\n  }\n\n  /** A single parameter placeholder */\n  static param(value: SqlParam): Fragment {\n    return new Fragment([\"\", \"\"], [value]);\n  }\n\n  /**\n   * IN-list: `column IN ($1, $2, $3)`\n   *\n   * Expands an array into a comma-separated parameter list.\n   */\n  static inList(column: string, values: SqlParam[]): Fragment {\n    if (values.length === 0) {\n      return Fragment.raw(\"FALSE\"); // empty IN is always false\n    }\n    const segments = [column + \" IN (\"];\n    const params: SqlParam[] = [];\n    for (let i = 0; i < values.length; i++) {\n      segments.push(i < values.length - 1 ? \", \" : \")\");\n      params.push(values[i]);\n    }\n    return new Fragment(segments, params);\n  }\n\n  /**\n   * VALUES clause for bulk inserts.\n   *\n   * @param rows - Array of row tuples\n   */\n  static values(rows: SqlParam[][]): Fragment {\n    const rowFragments = rows.map((row) => {\n      const inner = Fragment.commas(row.map((v) => Fragment.param(v)));\n      return inner.parens();\n    });\n    return Fragment.raw(\"VALUES \").appendNoSpace(\n      Fragment.intercalate(Fragment.raw(\", \"), rowFragments),\n    );\n  }\n\n  /**\n   * SET clause for updates: `SET col1 = $1, col2 = $2`\n   */\n  static set(assignments: Record<string, SqlParam>): Fragment {\n    const frags = Object.entries(assignments).map(\n      ([col, val]) => new Fragment([`${col} = `, \"\"], [val]),\n    );\n    return Fragment.raw(\"SET \").appendNoSpace(Fragment.commas(frags));\n  }\n\n  /**\n   * Optional fragment — include only if the condition is true.\n   * Useful for dynamic WHERE clauses.\n   */\n  static when(condition: boolean, fragment: () => Fragment): Fragment {\n    return condition ? fragment() : Fragment.empty;\n  }\n\n  /**\n   * Build a WHERE clause from optional conditions.\n   * Only non-empty fragments are included, joined with AND.\n   */\n  static whereAnd(fragments: Fragment[]): Fragment {\n    const nonEmpty = fragments.filter((f) => f.segments.join(\"\").trim() !== \"\");\n    if (nonEmpty.length === 0) return Fragment.empty;\n    return Fragment.raw(\"WHERE \").appendNoSpace(Fragment.and(nonEmpty));\n  }\n\n  // --------------------------------------------------------------------------\n  // Debugging\n  // --------------------------------------------------------------------------\n\n  /** String representation for debugging */\n  toString(): string {\n    const { text, params } = this.query;\n    return `Fragment(${text}, [${params.map((p) => JSON.stringify(p)).join(\", \")}])`;\n  }\n}\n\n// ============================================================================\n// Query & Update — typed wrappers for read vs write operations\n// ============================================================================\n\n/**\n * A SELECT query that returns rows of type R.\n *\n * This is a branded wrapper around Fragment that carries the expected\n * result row type for downstream consumption (e.g. by a database driver).\n */\nexport class Query<R> {\n  readonly _tag = \"Query\" as const;\n\n  constructor(readonly fragment: Fragment) {}\n\n  get text(): string {\n    return this.fragment.text;\n  }\n\n  get params(): readonly SqlParam[] {\n    return this.fragment.values;\n  }\n\n  /** Map over the expected result type (compile-time only) */\n  map<B>(_f: (a: R) => B): Query<B> {\n    return new Query<B>(this.fragment);\n  }\n\n  /** Append a fragment to this query */\n  append(other: Fragment): Query<R> {\n    return new Query<R>(this.fragment.append(other));\n  }\n\n  toString(): string {\n    return `Query(${this.fragment.text})`;\n  }\n}\n\n/**\n * An INSERT/UPDATE/DELETE statement that affects rows.\n */\nexport class Update {\n  readonly _tag = \"Update\" as const;\n\n  constructor(readonly fragment: Fragment) {}\n\n  get text(): string {\n    return this.fragment.text;\n  }\n\n  get params(): readonly SqlParam[] {\n    return this.fragment.values;\n  }\n\n  toString(): string {\n    return `Update(${this.fragment.text})`;\n  }\n}\n\n// ============================================================================\n// ConnectionIO — a description of a database operation (pure, composable)\n// ============================================================================\n\n/**\n * A description of a database operation, inspired by Doobie's ConnectionIO.\n *\n * ConnectionIO values are pure descriptions — they don't execute anything\n * until interpreted by a Transactor. This allows composition, sequencing,\n * and transactional grouping.\n */\nexport type ConnectionIO<A> =\n  | { _tag: \"Pure\"; value: A }\n  | {\n      _tag: \"QueryIO\";\n      query: Query<A>;\n      decoder: (row: Record<string, unknown>) => A;\n    }\n  | { _tag: \"UpdateIO\"; update: Update }\n  | {\n      _tag: \"FlatMap\";\n      source: ConnectionIO<unknown>;\n      f: (a: unknown) => ConnectionIO<A>;\n    }\n  | { _tag: \"Sequence\"; operations: ConnectionIO<unknown>[] };\n\nexport const ConnectionIO = {\n  /** Lift a pure value */\n  pure<A>(value: A): ConnectionIO<A> {\n    return { _tag: \"Pure\", value };\n  },\n\n  /** Create a query operation */\n  query<A>(\n    q: Query<A>,\n    decoder: (row: Record<string, unknown>) => A,\n  ): ConnectionIO<A[]> {\n    return {\n      _tag: \"QueryIO\",\n      query: q as unknown as Query<A[]>,\n      decoder: decoder as unknown as (row: Record<string, unknown>) => A[],\n    };\n  },\n\n  /** Create an update operation */\n  update(u: Update): ConnectionIO<number> {\n    return { _tag: \"UpdateIO\", update: u } as unknown as ConnectionIO<number>;\n  },\n\n  /** Sequence: run one operation, then use its result to decide the next */\n  flatMap<A, B>(\n    source: ConnectionIO<A>,\n    f: (a: A) => ConnectionIO<B>,\n  ): ConnectionIO<B> {\n    return {\n      _tag: \"FlatMap\",\n      source: source as ConnectionIO<unknown>,\n      f: f as (a: unknown) => ConnectionIO<B>,\n    };\n  },\n\n  /** Map over the result */\n  map<A, B>(source: ConnectionIO<A>, f: (a: A) => B): ConnectionIO<B> {\n    return ConnectionIO.flatMap(source, (a) => ConnectionIO.pure(f(a)));\n  },\n};\n\n// ============================================================================\n// Transactor — interprets ConnectionIO against a real database connection\n// ============================================================================\n\n/**\n * Minimal database connection interface.\n * Compatible with node-postgres (pg), mysql2, better-sqlite3, etc.\n */\nexport interface DbConnection {\n  query(\n    text: string,\n    params: readonly SqlParam[],\n  ): Promise<{ rows: Record<string, unknown>[] }>;\n}\n\n/**\n * Interprets ConnectionIO programs against a database connection.\n */\nexport class Transactor {\n  constructor(private readonly conn: DbConnection) {}\n\n  async run<A>(program: ConnectionIO<A>): Promise<A> {\n    switch (program._tag) {\n      case \"Pure\":\n        return program.value;\n\n      case \"QueryIO\": {\n        const { text, params } = program.query;\n        const result = await this.conn.query(text, params);\n        return result.rows.map(program.decoder) as unknown as A;\n      }\n\n      case \"UpdateIO\": {\n        const { text, params } = program.update;\n        const result = await this.conn.query(text, params);\n        return (result.rows.length ?? 0) as unknown as A;\n      }\n\n      case \"FlatMap\": {\n        const a = await this.run(program.source);\n        return this.run(program.f(a));\n      }\n\n      case \"Sequence\": {\n        let last: unknown;\n        for (const op of program.operations) {\n          last = await this.run(op);\n        }\n        return last as A;\n      }\n    }\n  }\n}\n","/**\n * Doobie-like SQL Macro\n *\n * Compile-time transformation of sql`` tagged template literals into\n * Fragment construction calls. The macro:\n *\n * 1. Parses the template literal segments and interpolations\n * 2. Distinguishes between Fragment-typed interpolations (inlined as sub-fragments)\n *    and plain values (bound as parameters)\n * 3. Validates basic SQL syntax at compile time\n * 4. Generates efficient Fragment construction code\n *\n * @example\n * ```typescript\n * // Input:\n * const q = sql`SELECT * FROM users WHERE name = ${name} AND age > ${age}`;\n *\n * // Expands to:\n * const q = new Fragment(\n *   [\"SELECT * FROM users WHERE name = \", \" AND age > \", \"\"],\n *   [name, age]\n * );\n * ```\n *\n * Fragment interpolations are composed at the Fragment level:\n * ```typescript\n * const cond = sql`WHERE active = ${true}`;\n * const q = sql`SELECT * FROM users ${cond}`;\n *\n * // Expands to:\n * const q = __sql_compose(\n *   [\"SELECT * FROM users \", \"\"],\n *   [cond]\n * );\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typemacro/core\";\n\n// ============================================================================\n// SQL Macro Definition\n// ============================================================================\n\nexport const sqlMacro = defineExpressionMacro({\n  name: \"sql\",\n  description:\n    \"Doobie-style composable SQL fragments with type-safe parameter binding\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    // sql`` is invoked as an expression macro wrapping a template literal\n    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {\n      ctx.reportError(\n        callExpr,\n        \"sql expects a tagged template literal: sql`...`\",\n      );\n      return callExpr;\n    }\n\n    const template = args[0];\n\n    // -----------------------------------------------------------------------\n    // No-substitution template: sql`SELECT 1`\n    // -----------------------------------------------------------------------\n    if (ts.isNoSubstitutionTemplateLiteral(template)) {\n      const sqlText = template.text;\n      const validationError = validateSqlFragment(sqlText);\n      if (validationError) {\n        ctx.reportWarning(callExpr, `SQL warning: ${validationError}`);\n      }\n\n      // new Fragment([\"SELECT 1\"], [])\n      return createFragmentConstructor(factory, [sqlText], []);\n    }\n\n    // -----------------------------------------------------------------------\n    // Template with interpolations\n    // -----------------------------------------------------------------------\n    if (ts.isTemplateExpression(template)) {\n      const segments: string[] = [template.head.text];\n      const interpolations: ts.Expression[] = [];\n\n      for (const span of template.templateSpans) {\n        interpolations.push(span.expression);\n        segments.push(span.literal.text);\n      }\n\n      // Validate the combined SQL text (with placeholders)\n      const combinedSql = segments.join(\"?\");\n      const validationError = validateSqlFragment(combinedSql);\n      if (validationError) {\n        ctx.reportWarning(callExpr, `SQL warning: ${validationError}`);\n      }\n\n      // Generate: __sql_build([\"seg0\", \"seg1\", ...], [expr0, expr1, ...])\n      // The runtime helper handles Fragment vs plain value interpolations\n      return createSqlBuildCall(factory, segments, interpolations);\n    }\n\n    return callExpr;\n  },\n});\n\n// ============================================================================\n// AST Construction Helpers\n// ============================================================================\n\n/**\n * Generate: new Fragment(segments, params)\n *\n * Used when all interpolations are known to be plain params (no sub-fragments).\n */\nfunction createFragmentConstructor(\n  factory: ts.NodeFactory,\n  segments: string[],\n  params: ts.Expression[],\n): ts.Expression {\n  const segmentsArray = factory.createArrayLiteralExpression(\n    segments.map((s) => factory.createStringLiteral(s)),\n  );\n\n  const paramsArray = factory.createArrayLiteralExpression(params);\n\n  return factory.createNewExpression(\n    factory.createIdentifier(\"Fragment\"),\n    undefined,\n    [segmentsArray, paramsArray],\n  );\n}\n\n/**\n * Generate: __sql_build([\"seg0\", \"seg1\", ...], [expr0, expr1, ...])\n *\n * The runtime helper inspects each interpolation at runtime:\n * - If it's a Fragment, it inlines its SQL and params\n * - Otherwise, it treats it as a bound parameter\n *\n * This allows mixing Fragment composition and parameter binding in one template.\n */\nfunction createSqlBuildCall(\n  factory: ts.NodeFactory,\n  segments: string[],\n  interpolations: ts.Expression[],\n): ts.Expression {\n  const segmentsArray = factory.createArrayLiteralExpression(\n    segments.map((s) => factory.createStringLiteral(s)),\n  );\n\n  const interpolationsArray =\n    factory.createArrayLiteralExpression(interpolations);\n\n  return factory.createCallExpression(\n    factory.createIdentifier(\"__sql_build\"),\n    undefined,\n    [segmentsArray, interpolationsArray],\n  );\n}\n\n// ============================================================================\n// Compile-Time SQL Validation\n// ============================================================================\n\nfunction validateSqlFragment(sql: string): string | null {\n  const normalized = sql.toLowerCase().trim();\n\n  if (!normalized) return null;\n\n  // Check for unbalanced parentheses\n  let depth = 0;\n  for (const char of sql) {\n    if (char === \"(\") depth++;\n    if (char === \")\") depth--;\n    if (depth < 0) return \"Unbalanced parentheses\";\n  }\n  if (depth !== 0) return \"Unbalanced parentheses\";\n\n  // Check for unbalanced single quotes (basic string literal check)\n  const singleQuotes = (sql.match(/'/g) || []).length;\n  if (singleQuotes % 2 !== 0) return \"Unbalanced single quotes\";\n\n  // Warn about SQL comments\n  if (normalized.includes(\"--\")) {\n    return \"SQL comment detected — ensure this is intentional\";\n  }\n\n  return null;\n}\n\n// ============================================================================\n// Register\n// ============================================================================\n\nexport function register(): void {\n  globalRegistry.register(sqlMacro);\n}\n\n// Auto-register\nregister();\n"],"mappings":"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","names":["sql","sql"]}