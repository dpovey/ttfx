import * as _typemacro_core from '@typemacro/core';

/**
 * Doobie-like Type-Safe SQL DSL
 *
 * Inspired by Scala's Doobie library, this module provides composable SQL
 * fragments with type-safe parameter binding. SQL statements are built from
 * fragments that can be combined, nested, and composed — parameters are
 * tracked and flattened automatically.
 *
 * Key concepts:
 * - Fragment: an SQL string paired with its bound parameters
 * - Fragments compose via concatenation, AND/OR combinators, IN lists, etc.
 * - The sql`` tagged template is the primary entry point
 * - Parameters are always positional ($1, $2, …) in the final output
 *
 * @example
 * ```typescript
 * const name = "Alice";
 * const age = 30;
 *
 * const base = sql`SELECT * FROM users`;
 * const cond = sql`WHERE name = ${name} AND age > ${age}`;
 * const query = base.append(cond);
 *
 * query.text;   // "SELECT * FROM users WHERE name = $1 AND age > $2"
 * query.params; // ["Alice", 30]
 * ```
 */
/** Values that can be bound as SQL parameters */
type SqlParam = string | number | boolean | null | Date | Buffer | SqlParam[];
/**
 * An SQL fragment: a piece of SQL text with associated parameters.
 *
 * Fragments are the fundamental unit of composition. They track raw SQL
 * segments and parameter values separately, then render to a final
 * parameterised query string on demand.
 *
 * Immutable — every combinator returns a new Fragment.
 */
declare class Fragment {
    readonly segments: readonly string[];
    readonly params: readonly SqlParam[];
    /**
     * @param segments - Raw SQL text segments (one more than params)
     * @param params  - Bound parameter values, interleaved between segments
     */
    constructor(segments: readonly string[], params: readonly SqlParam[]);
    /** Render to a parameterised query with positional placeholders ($1, $2, …) */
    get query(): {
        text: string;
        params: readonly SqlParam[];
    };
    /** Shorthand: rendered SQL text */
    get text(): string;
    /** Shorthand: rendered parameter array */
    get values(): readonly SqlParam[];
    /** Concatenate two fragments with a space separator */
    append(other: Fragment): Fragment;
    /** Prepend another fragment */
    prepend(other: Fragment): Fragment;
    /** Wrap with parentheses */
    parens(): Fragment;
    /** Concatenate without adding a space */
    appendNoSpace(other: Fragment): Fragment;
    /** Join fragments with AND */
    static and(fragments: Fragment[]): Fragment;
    /** Join fragments with OR (wrapped in parens for safety) */
    static or(fragments: Fragment[]): Fragment;
    /** Join fragments with a separator */
    static intercalate(sep: Fragment, fragments: Fragment[]): Fragment;
    /** Comma-separated list */
    static commas(fragments: Fragment[]): Fragment;
    /** Concatenate two fragments with a space */
    static concat(a: Fragment, b: Fragment): Fragment;
    /** Empty fragment */
    static readonly empty: Fragment;
    /** Raw SQL with no parameters */
    static raw(sql: string): Fragment;
    /** A single parameter placeholder */
    static param(value: SqlParam): Fragment;
    /**
     * IN-list: `column IN ($1, $2, $3)`
     *
     * Expands an array into a comma-separated parameter list.
     */
    static inList(column: string, values: SqlParam[]): Fragment;
    /**
     * VALUES clause for bulk inserts.
     *
     * @param rows - Array of row tuples
     */
    static values(rows: SqlParam[][]): Fragment;
    /**
     * SET clause for updates: `SET col1 = $1, col2 = $2`
     */
    static set(assignments: Record<string, SqlParam>): Fragment;
    /**
     * Optional fragment — include only if the condition is true.
     * Useful for dynamic WHERE clauses.
     */
    static when(condition: boolean, fragment: () => Fragment): Fragment;
    /**
     * Build a WHERE clause from optional conditions.
     * Only non-empty fragments are included, joined with AND.
     */
    static whereAnd(fragments: Fragment[]): Fragment;
    /** String representation for debugging */
    toString(): string;
}
/**
 * A SELECT query that returns rows of type R.
 *
 * This is a branded wrapper around Fragment that carries the expected
 * result row type for downstream consumption (e.g. by a database driver).
 */
declare class Query$1<R> {
    readonly fragment: Fragment;
    readonly _tag: "Query";
    constructor(fragment: Fragment);
    get text(): string;
    get params(): readonly SqlParam[];
    /** Map over the expected result type (compile-time only) */
    map<B>(_f: (a: R) => B): Query$1<B>;
    /** Append a fragment to this query */
    append(other: Fragment): Query$1<R>;
    toString(): string;
}
/**
 * An INSERT/UPDATE/DELETE statement that affects rows.
 */
declare class Update$1 {
    readonly fragment: Fragment;
    readonly _tag: "Update";
    constructor(fragment: Fragment);
    get text(): string;
    get params(): readonly SqlParam[];
    toString(): string;
}
/**
 * A description of a database operation, inspired by Doobie's ConnectionIO.
 *
 * ConnectionIO values are pure descriptions — they don't execute anything
 * until interpreted by a Transactor. This allows composition, sequencing,
 * and transactional grouping.
 */
type ConnectionIO<A> = {
    _tag: "Pure";
    value: A;
} | {
    _tag: "QueryIO";
    query: Query$1<A>;
    decoder: (row: Record<string, unknown>) => A;
} | {
    _tag: "UpdateIO";
    update: Update$1;
} | {
    _tag: "FlatMap";
    source: ConnectionIO<unknown>;
    f: (a: unknown) => ConnectionIO<A>;
} | {
    _tag: "Sequence";
    operations: ConnectionIO<unknown>[];
};
declare const ConnectionIO: {
    /** Lift a pure value */
    pure<A>(value: A): ConnectionIO<A>;
    /** Create a query operation */
    query<A>(q: Query$1<A>, decoder: (row: Record<string, unknown>) => A): ConnectionIO<A[]>;
    /** Create an update operation */
    update(u: Update$1): ConnectionIO<number>;
    /** Sequence: run one operation, then use its result to decide the next */
    flatMap<A, B>(source: ConnectionIO<A>, f: (a: A) => ConnectionIO<B>): ConnectionIO<B>;
    /** Map over the result */
    map<A, B>(source: ConnectionIO<A>, f: (a: A) => B): ConnectionIO<B>;
};
/**
 * Minimal database connection interface.
 * Compatible with node-postgres (pg), mysql2, better-sqlite3, etc.
 */
interface DbConnection {
    query(text: string, params: readonly SqlParam[]): Promise<{
        rows: Record<string, unknown>[];
    }>;
}
/**
 * Interprets ConnectionIO programs against a database connection.
 */
declare class Transactor {
    private readonly conn;
    constructor(conn: DbConnection);
    run<A>(program: ConnectionIO<A>): Promise<A>;
}

/**
 * Doobie-like SQL Macro
 *
 * Compile-time transformation of sql`` tagged template literals into
 * Fragment construction calls. The macro:
 *
 * 1. Parses the template literal segments and interpolations
 * 2. Distinguishes between Fragment-typed interpolations (inlined as sub-fragments)
 *    and plain values (bound as parameters)
 * 3. Validates basic SQL syntax at compile time
 * 4. Generates efficient Fragment construction code
 *
 * @example
 * ```typescript
 * // Input:
 * const q = sql`SELECT * FROM users WHERE name = ${name} AND age > ${age}`;
 *
 * // Expands to:
 * const q = new Fragment(
 *   ["SELECT * FROM users WHERE name = ", " AND age > ", ""],
 *   [name, age]
 * );
 * ```
 *
 * Fragment interpolations are composed at the Fragment level:
 * ```typescript
 * const cond = sql`WHERE active = ${true}`;
 * const q = sql`SELECT * FROM users ${cond}`;
 *
 * // Expands to:
 * const q = __sql_compose(
 *   ["SELECT * FROM users ", ""],
 *   [cond]
 * );
 * ```
 */
declare const sqlMacro: _typemacro_core.ExpressionMacro;
declare function register(): void;

/**
 * @typemacro/sql - Doobie-like Type-Safe SQL DSL
 *
 * This module provides:
 * - Fragment class for composable SQL building
 * - Query and Update wrappers with type branding
 * - ConnectionIO for pure database operation descriptions
 * - Transactor for interpreting ConnectionIO programs
 * - sql`` macro for compile-time SQL validation
 *
 * @example
 * ```typescript
 * import { sql, Fragment, Query, Transactor } from "@typemacro/sql";
 *
 * const name = "Alice";
 * const age = 30;
 *
 * const query = sql`SELECT * FROM users WHERE name = ${name} AND age > ${age}`;
 * console.log(query.text);   // "SELECT * FROM users WHERE name = $1 AND age > $2"
 * console.log(query.params); // ["Alice", 30]
 * ```
 */

/**
 * Runtime helper for sql`` macro.
 *
 * Handles both Fragment interpolations (which get inlined) and
 * plain values (which become bound parameters).
 */
declare function __sql_build(segments: string[], interpolations: unknown[]): Fragment;
declare module "./types.js" {
    interface Fragment {
        /** Convert this fragment to a typed Query */
        toQuery<R>(): Query<R>;
        /** Convert this fragment to an Update */
        toUpdate(): Update;
    }
}
/**
 * Tagged template function for SQL - fallback when macro transform isn't applied.
 *
 * This allows the same code to work even without the macro transformer,
 * though you lose compile-time validation.
 */
declare function sql(strings: TemplateStringsArray, ...values: unknown[]): Fragment;

export { ConnectionIO, type DbConnection, Fragment, Query$1 as Query, type SqlParam, Transactor, Update$1 as Update, __sql_build, register, sql, sqlMacro };
