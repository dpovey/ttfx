"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ConnectionIO: () => ConnectionIO,
  Fragment: () => Fragment,
  Query: () => Query,
  Transactor: () => Transactor,
  Update: () => Update,
  __sql_build: () => __sql_build,
  register: () => register,
  sql: () => sql,
  sqlMacro: () => sqlMacro
});
module.exports = __toCommonJS(index_exports);

// src/types.ts
var Fragment = class _Fragment {
  /**
   * @param segments - Raw SQL text segments (one more than params)
   * @param params  - Bound parameter values, interleaved between segments
   */
  constructor(segments, params) {
    this.segments = segments;
    this.params = params;
  }
  // --------------------------------------------------------------------------
  // Rendering
  // --------------------------------------------------------------------------
  /** Render to a parameterised query with positional placeholders ($1, $2, …) */
  get query() {
    const allParams = [];
    const parts = [];
    for (let i = 0; i < this.segments.length; i++) {
      parts.push(this.segments[i]);
      if (i < this.params.length) {
        const param = this.params[i];
        if (param instanceof _Fragment) {
          const nested = param.query;
          const offset = allParams.length;
          const renumbered = nested.text.replace(
            /\$(\d+)/g,
            (_, n) => `$${parseInt(n) + offset}`
          );
          parts.push(renumbered);
          allParams.push(...nested.params);
        } else {
          allParams.push(param);
          parts.push(`$${allParams.length}`);
        }
      }
    }
    return { text: parts.join(""), params: allParams };
  }
  /** Shorthand: rendered SQL text */
  get text() {
    return this.query.text;
  }
  /** Shorthand: rendered parameter array */
  get values() {
    return this.query.params;
  }
  // --------------------------------------------------------------------------
  // Composition
  // --------------------------------------------------------------------------
  /** Concatenate two fragments with a space separator */
  append(other) {
    return _Fragment.concat(this, other);
  }
  /** Prepend another fragment */
  prepend(other) {
    return _Fragment.concat(other, this);
  }
  /** Wrap with parentheses */
  parens() {
    return _Fragment.raw("(").appendNoSpace(this).appendNoSpace(_Fragment.raw(")"));
  }
  /** Concatenate without adding a space */
  appendNoSpace(other) {
    const newSegments = [
      ...this.segments.slice(0, -1),
      this.segments[this.segments.length - 1] + other.segments[0],
      ...other.segments.slice(1)
    ];
    return new _Fragment(newSegments, [...this.params, ...other.params]);
  }
  // --------------------------------------------------------------------------
  // SQL Combinators
  // --------------------------------------------------------------------------
  /** Join fragments with AND */
  static and(fragments) {
    return _Fragment.intercalate(_Fragment.raw(" AND "), fragments);
  }
  /** Join fragments with OR (wrapped in parens for safety) */
  static or(fragments) {
    return _Fragment.intercalate(_Fragment.raw(" OR "), fragments).parens();
  }
  /** Join fragments with a separator */
  static intercalate(sep, fragments) {
    if (fragments.length === 0) return _Fragment.empty;
    let result = fragments[0];
    for (let i = 1; i < fragments.length; i++) {
      result = result.appendNoSpace(sep).appendNoSpace(fragments[i]);
    }
    return result;
  }
  /** Comma-separated list */
  static commas(fragments) {
    return _Fragment.intercalate(_Fragment.raw(", "), fragments);
  }
  /** Concatenate two fragments with a space */
  static concat(a, b) {
    const newSegments = [
      ...a.segments.slice(0, -1),
      a.segments[a.segments.length - 1] + " " + b.segments[0],
      ...b.segments.slice(1)
    ];
    return new _Fragment(newSegments, [...a.params, ...b.params]);
  }
  // --------------------------------------------------------------------------
  // Constructors
  // --------------------------------------------------------------------------
  /** Empty fragment */
  static empty = new _Fragment([""], []);
  /** Raw SQL with no parameters */
  static raw(sql2) {
    return new _Fragment([sql2], []);
  }
  /** A single parameter placeholder */
  static param(value) {
    return new _Fragment(["", ""], [value]);
  }
  /**
   * IN-list: `column IN ($1, $2, $3)`
   *
   * Expands an array into a comma-separated parameter list.
   */
  static inList(column, values) {
    if (values.length === 0) {
      return _Fragment.raw("FALSE");
    }
    const segments = [column + " IN ("];
    const params = [];
    for (let i = 0; i < values.length; i++) {
      segments.push(i < values.length - 1 ? ", " : ")");
      params.push(values[i]);
    }
    return new _Fragment(segments, params);
  }
  /**
   * VALUES clause for bulk inserts.
   *
   * @param rows - Array of row tuples
   */
  static values(rows) {
    const rowFragments = rows.map((row) => {
      const inner = _Fragment.commas(row.map((v) => _Fragment.param(v)));
      return inner.parens();
    });
    return _Fragment.raw("VALUES ").appendNoSpace(
      _Fragment.intercalate(_Fragment.raw(", "), rowFragments)
    );
  }
  /**
   * SET clause for updates: `SET col1 = $1, col2 = $2`
   */
  static set(assignments) {
    const frags = Object.entries(assignments).map(
      ([col, val]) => new _Fragment([`${col} = `, ""], [val])
    );
    return _Fragment.raw("SET ").appendNoSpace(_Fragment.commas(frags));
  }
  /**
   * Optional fragment — include only if the condition is true.
   * Useful for dynamic WHERE clauses.
   */
  static when(condition, fragment) {
    return condition ? fragment() : _Fragment.empty;
  }
  /**
   * Build a WHERE clause from optional conditions.
   * Only non-empty fragments are included, joined with AND.
   */
  static whereAnd(fragments) {
    const nonEmpty = fragments.filter((f) => f.segments.join("").trim() !== "");
    if (nonEmpty.length === 0) return _Fragment.empty;
    return _Fragment.raw("WHERE ").appendNoSpace(_Fragment.and(nonEmpty));
  }
  // --------------------------------------------------------------------------
  // Debugging
  // --------------------------------------------------------------------------
  /** String representation for debugging */
  toString() {
    const { text, params } = this.query;
    return `Fragment(${text}, [${params.map((p) => JSON.stringify(p)).join(", ")}])`;
  }
};
var Query = class _Query {
  constructor(fragment) {
    this.fragment = fragment;
  }
  _tag = "Query";
  get text() {
    return this.fragment.text;
  }
  get params() {
    return this.fragment.values;
  }
  /** Map over the expected result type (compile-time only) */
  map(_f) {
    return new _Query(this.fragment);
  }
  /** Append a fragment to this query */
  append(other) {
    return new _Query(this.fragment.append(other));
  }
  toString() {
    return `Query(${this.fragment.text})`;
  }
};
var Update = class {
  constructor(fragment) {
    this.fragment = fragment;
  }
  _tag = "Update";
  get text() {
    return this.fragment.text;
  }
  get params() {
    return this.fragment.values;
  }
  toString() {
    return `Update(${this.fragment.text})`;
  }
};
var ConnectionIO = {
  /** Lift a pure value */
  pure(value) {
    return { _tag: "Pure", value };
  },
  /** Create a query operation */
  query(q, decoder) {
    return {
      _tag: "QueryIO",
      query: q,
      decoder
    };
  },
  /** Create an update operation */
  update(u) {
    return { _tag: "UpdateIO", update: u };
  },
  /** Sequence: run one operation, then use its result to decide the next */
  flatMap(source, f) {
    return {
      _tag: "FlatMap",
      source,
      f
    };
  },
  /** Map over the result */
  map(source, f) {
    return ConnectionIO.flatMap(source, (a) => ConnectionIO.pure(f(a)));
  }
};
var Transactor = class {
  constructor(conn) {
    this.conn = conn;
  }
  async run(program) {
    switch (program._tag) {
      case "Pure":
        return program.value;
      case "QueryIO": {
        const { text, params } = program.query;
        const result = await this.conn.query(text, params);
        return result.rows.map(program.decoder);
      }
      case "UpdateIO": {
        const { text, params } = program.update;
        const result = await this.conn.query(text, params);
        return result.rows.length ?? 0;
      }
      case "FlatMap": {
        const a = await this.run(program.source);
        return this.run(program.f(a));
      }
      case "Sequence": {
        let last;
        for (const op of program.operations) {
          last = await this.run(op);
        }
        return last;
      }
    }
  }
};

// src/macro.ts
var ts = __toESM(require("typescript"), 1);
var import_core = require("@typemacro/core");
var sqlMacro = (0, import_core.defineExpressionMacro)({
  name: "sql",
  description: "Doobie-style composable SQL fragments with type-safe parameter binding",
  expand(ctx, callExpr, args) {
    const factory = ctx.factory;
    if (args.length !== 1 || !ts.isTemplateLiteral(args[0])) {
      ctx.reportError(
        callExpr,
        "sql expects a tagged template literal: sql`...`"
      );
      return callExpr;
    }
    const template = args[0];
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
      const sqlText = template.text;
      const validationError = validateSqlFragment(sqlText);
      if (validationError) {
        ctx.reportWarning(callExpr, `SQL warning: ${validationError}`);
      }
      return createFragmentConstructor(factory, [sqlText], []);
    }
    if (ts.isTemplateExpression(template)) {
      const segments = [template.head.text];
      const interpolations = [];
      for (const span of template.templateSpans) {
        interpolations.push(span.expression);
        segments.push(span.literal.text);
      }
      const combinedSql = segments.join("?");
      const validationError = validateSqlFragment(combinedSql);
      if (validationError) {
        ctx.reportWarning(callExpr, `SQL warning: ${validationError}`);
      }
      return createSqlBuildCall(factory, segments, interpolations);
    }
    return callExpr;
  }
});
function createFragmentConstructor(factory, segments, params) {
  const segmentsArray = factory.createArrayLiteralExpression(
    segments.map((s) => factory.createStringLiteral(s))
  );
  const paramsArray = factory.createArrayLiteralExpression(params);
  return factory.createNewExpression(
    factory.createIdentifier("Fragment"),
    void 0,
    [segmentsArray, paramsArray]
  );
}
function createSqlBuildCall(factory, segments, interpolations) {
  const segmentsArray = factory.createArrayLiteralExpression(
    segments.map((s) => factory.createStringLiteral(s))
  );
  const interpolationsArray = factory.createArrayLiteralExpression(interpolations);
  return factory.createCallExpression(
    factory.createIdentifier("__sql_build"),
    void 0,
    [segmentsArray, interpolationsArray]
  );
}
function validateSqlFragment(sql2) {
  const normalized = sql2.toLowerCase().trim();
  if (!normalized) return null;
  let depth = 0;
  for (const char of sql2) {
    if (char === "(") depth++;
    if (char === ")") depth--;
    if (depth < 0) return "Unbalanced parentheses";
  }
  if (depth !== 0) return "Unbalanced parentheses";
  const singleQuotes = (sql2.match(/'/g) || []).length;
  if (singleQuotes % 2 !== 0) return "Unbalanced single quotes";
  if (normalized.includes("--")) {
    return "SQL comment detected \u2014 ensure this is intentional";
  }
  return null;
}
function register() {
  import_core.globalRegistry.register(sqlMacro);
}
register();

// src/index.ts
function __sql_build(segments, interpolations) {
  const resultSegments = [];
  const resultParams = [];
  for (let i = 0; i < segments.length; i++) {
    if (i === 0) {
      resultSegments.push(segments[i]);
    } else {
      const interp = interpolations[i - 1];
      if (interp instanceof Fragment) {
        const lastIdx = resultSegments.length - 1;
        resultSegments[lastIdx] += interp.segments[0];
        for (let j = 1; j < interp.segments.length; j++) {
          resultSegments.push(interp.segments[j]);
        }
        resultParams.push(...interp.params);
        resultSegments[resultSegments.length - 1] += segments[i];
      } else {
        resultParams.push(interp);
        resultSegments.push(segments[i]);
      }
    }
  }
  return new Fragment(resultSegments, resultParams);
}
Fragment.prototype.toQuery = function() {
  return new Query(this);
};
Fragment.prototype.toUpdate = function() {
  return new Update(this);
};
function sql(strings, ...values) {
  return __sql_build([...strings], values);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConnectionIO,
  Fragment,
  Query,
  Transactor,
  Update,
  __sql_build,
  register,
  sql,
  sqlMacro
});
//# sourceMappingURL=index.cjs.map