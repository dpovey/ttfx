"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  MacroContextImpl: () => MacroContextImpl,
  createExtensionRegistry: () => createExtensionRegistry,
  createMacroContext: () => createMacroContext,
  createRegistry: () => createRegistry,
  defineAttributeMacro: () => defineAttributeMacro,
  defineDeriveMacro: () => defineDeriveMacro,
  defineExpressionMacro: () => defineExpressionMacro,
  defineLabeledBlockMacro: () => defineLabeledBlockMacro,
  defineTaggedTemplateMacro: () => defineTaggedTemplateMacro,
  defineTypeMacro: () => defineTypeMacro,
  globalExtensionRegistry: () => globalExtensionRegistry,
  globalRegistry: () => globalRegistry,
  registerMacros: () => registerMacros
});
module.exports = __toCommonJS(index_exports);

// src/registry.ts
function moduleKey(mod, exportName) {
  return `${mod}::${exportName}`;
}
var MacroRegistryImpl = class {
  expressionMacros = /* @__PURE__ */ new Map();
  attributeMacros = /* @__PURE__ */ new Map();
  deriveMacros = /* @__PURE__ */ new Map();
  taggedTemplateMacros = /* @__PURE__ */ new Map();
  typeMacros = /* @__PURE__ */ new Map();
  labeledBlockMacros = /* @__PURE__ */ new Map();
  /**
   * Secondary index: module-scoped lookup for macros that declare a `module`.
   * Key is "module::exportName", value is the macro definition.
   */
  moduleScopedMacros = /* @__PURE__ */ new Map();
  register(macro) {
    switch (macro.kind) {
      case "expression":
        if (this.expressionMacros.has(macro.name)) {
          throw new Error(
            `Expression macro '${macro.name}' is already registered`
          );
        }
        this.expressionMacros.set(macro.name, macro);
        break;
      case "attribute":
        if (this.attributeMacros.has(macro.name)) {
          throw new Error(
            `Attribute macro '${macro.name}' is already registered`
          );
        }
        this.attributeMacros.set(macro.name, macro);
        break;
      case "derive":
        if (this.deriveMacros.has(macro.name)) {
          throw new Error(`Derive macro '${macro.name}' is already registered`);
        }
        this.deriveMacros.set(macro.name, macro);
        break;
      case "tagged-template":
        if (this.taggedTemplateMacros.has(macro.name)) {
          throw new Error(
            `Tagged template macro '${macro.name}' is already registered`
          );
        }
        this.taggedTemplateMacros.set(macro.name, macro);
        break;
      case "type":
        if (this.typeMacros.has(macro.name)) {
          throw new Error(`Type macro '${macro.name}' is already registered`);
        }
        this.typeMacros.set(macro.name, macro);
        break;
      case "labeled-block":
        if (this.labeledBlockMacros.has(macro.label)) {
          throw new Error(
            `Labeled block macro for label '${macro.label}' is already registered`
          );
        }
        this.labeledBlockMacros.set(macro.label, macro);
        break;
      default:
        throw new Error(
          `Unknown macro kind: ${macro.kind}`
        );
    }
    if (macro.module) {
      const exportName = macro.exportName ?? macro.name;
      const key = moduleKey(macro.module, exportName);
      this.moduleScopedMacros.set(key, macro);
    }
  }
  getExpression(name) {
    return this.expressionMacros.get(name);
  }
  getAttribute(name) {
    return this.attributeMacros.get(name);
  }
  getDerive(name) {
    return this.deriveMacros.get(name);
  }
  getTaggedTemplate(name) {
    return this.taggedTemplateMacros.get(name);
  }
  getType(name) {
    return this.typeMacros.get(name);
  }
  getLabeledBlock(label) {
    return this.labeledBlockMacros.get(label);
  }
  /**
   * Look up a macro by its source module and export name.
   * Returns the macro if it was registered with a matching module+exportName.
   */
  getByModuleExport(mod, exportName) {
    return this.moduleScopedMacros.get(moduleKey(mod, exportName));
  }
  /**
   * Check whether a macro (looked up by name) requires import-scoping.
   * Returns true if the macro has a `module` field set.
   */
  isImportScoped(name, kind) {
    let macro;
    switch (kind) {
      case "expression":
        macro = this.expressionMacros.get(name);
        break;
      case "attribute":
        macro = this.attributeMacros.get(name);
        break;
      case "derive":
        macro = this.deriveMacros.get(name);
        break;
      case "tagged-template":
        macro = this.taggedTemplateMacros.get(name);
        break;
      case "type":
        macro = this.typeMacros.get(name);
        break;
      case "labeled-block":
        macro = this.labeledBlockMacros.get(name);
        break;
    }
    return macro?.module !== void 0;
  }
  getAll() {
    return [
      ...this.expressionMacros.values(),
      ...this.attributeMacros.values(),
      ...this.deriveMacros.values(),
      ...this.taggedTemplateMacros.values(),
      ...this.typeMacros.values(),
      ...this.labeledBlockMacros.values()
    ];
  }
  /** Clear all registered macros (useful for testing) */
  clear() {
    this.expressionMacros.clear();
    this.attributeMacros.clear();
    this.deriveMacros.clear();
    this.taggedTemplateMacros.clear();
    this.typeMacros.clear();
    this.labeledBlockMacros.clear();
    this.moduleScopedMacros.clear();
  }
};
var globalRegistry = new MacroRegistryImpl();
function createRegistry() {
  return new MacroRegistryImpl();
}
function defineExpressionMacro(definition) {
  return {
    ...definition,
    kind: "expression"
  };
}
function defineAttributeMacro(definition) {
  return {
    ...definition,
    kind: "attribute"
  };
}
function defineDeriveMacro(definition) {
  return {
    ...definition,
    kind: "derive"
  };
}
function defineTaggedTemplateMacro(definition) {
  return {
    ...definition,
    kind: "tagged-template"
  };
}
function defineTypeMacro(definition) {
  return {
    ...definition,
    kind: "type"
  };
}
function defineLabeledBlockMacro(definition) {
  return {
    ...definition,
    kind: "labeled-block"
  };
}
function registerMacros(registry, ...macros) {
  for (const macro of macros) {
    registry.register(macro);
  }
}
var ExtensionMethodRegistryImpl = class {
  extensions = /* @__PURE__ */ new Map();
  makeKey(methodName, forType) {
    return `${forType}::${methodName}`;
  }
  register(info) {
    const key = this.makeKey(info.methodName, info.forType);
    const existing = this.extensions.get(key) ?? [];
    existing.push(info);
    this.extensions.set(key, existing);
  }
  find(methodName, forType) {
    const key = this.makeKey(methodName, forType);
    const matches = this.extensions.get(key);
    return matches?.[0];
  }
  getForType(forType) {
    const results = [];
    for (const [key, infos] of this.extensions) {
      if (key.startsWith(forType + "::")) {
        results.push(...infos);
      }
    }
    return results;
  }
  clear() {
    this.extensions.clear();
  }
};
var globalExtensionRegistry = new ExtensionMethodRegistryImpl();
function createExtensionRegistry() {
  return new ExtensionMethodRegistryImpl();
}

// src/context.ts
var ts = __toESM(require("typescript"), 1);
var MacroContextImpl = class {
  constructor(program, typeChecker, sourceFile, factory, transformContext) {
    this.program = program;
    this.typeChecker = typeChecker;
    this.sourceFile = sourceFile;
    this.factory = factory;
    this.transformContext = transformContext;
  }
  diagnostics = [];
  uniqueNameCounter = 0;
  // -------------------------------------------------------------------------
  // Node Creation Utilities
  // -------------------------------------------------------------------------
  createIdentifier(name) {
    return this.factory.createIdentifier(name);
  }
  createNumericLiteral(value) {
    return this.factory.createNumericLiteral(value);
  }
  createStringLiteral(value) {
    return this.factory.createStringLiteral(value);
  }
  createBooleanLiteral(value) {
    return value ? this.factory.createTrue() : this.factory.createFalse();
  }
  createArrayLiteral(elements) {
    return this.factory.createArrayLiteralExpression(elements);
  }
  createObjectLiteral(properties) {
    const propAssignments = properties.map(
      ({ name, value }) => this.factory.createPropertyAssignment(
        this.factory.createIdentifier(name),
        value
      )
    );
    return this.factory.createObjectLiteralExpression(propAssignments, true);
  }
  parseExpression(code) {
    const tempSource = ts.createSourceFile(
      "__macro_temp__.ts",
      `const __expr__ = ${code};`,
      ts.ScriptTarget.Latest,
      true,
      ts.ScriptKind.TS
    );
    const statement = tempSource.statements[0];
    if (ts.isVariableStatement(statement)) {
      const declaration = statement.declarationList.declarations[0];
      if (declaration.initializer) {
        return declaration.initializer;
      }
    }
    throw new Error(`Failed to parse expression: ${code}`);
  }
  parseStatements(code) {
    const tempSource = ts.createSourceFile(
      "__macro_temp__.ts",
      code,
      ts.ScriptTarget.Latest,
      true,
      ts.ScriptKind.TS
    );
    return Array.from(tempSource.statements);
  }
  // -------------------------------------------------------------------------
  // Type Utilities
  // -------------------------------------------------------------------------
  getTypeOf(node) {
    return this.typeChecker.getTypeAtLocation(node);
  }
  getTypeString(node) {
    const type = this.getTypeOf(node);
    return this.typeChecker.typeToString(type);
  }
  isAssignableTo(source, target) {
    return this.typeChecker.isTypeAssignableTo(source, target);
  }
  getPropertiesOfType(type) {
    return this.typeChecker.getPropertiesOfType(type);
  }
  getSymbol(node) {
    return this.typeChecker.getSymbolAtLocation(node);
  }
  // -------------------------------------------------------------------------
  // Diagnostics
  // -------------------------------------------------------------------------
  reportError(node, message) {
    this.diagnostics.push({
      severity: "error",
      message,
      node
    });
  }
  reportWarning(node, message) {
    this.diagnostics.push({
      severity: "warning",
      message,
      node
    });
  }
  getDiagnostics() {
    return [...this.diagnostics];
  }
  clearDiagnostics() {
    this.diagnostics = [];
  }
  // -------------------------------------------------------------------------
  // Compile-Time Evaluation
  // -------------------------------------------------------------------------
  evaluate(node) {
    return this.evaluateNode(node);
  }
  isComptime(node) {
    if (ts.isLiteralExpression(node)) {
      return true;
    }
    if (ts.isArrayLiteralExpression(node)) {
      return node.elements.every((e) => this.isComptime(e));
    }
    if (ts.isObjectLiteralExpression(node)) {
      return node.properties.every((p) => {
        if (ts.isPropertyAssignment(p)) {
          return this.isComptime(p.initializer);
        }
        return false;
      });
    }
    if (ts.isBinaryExpression(node)) {
      return this.isComptime(node.left) && this.isComptime(node.right);
    }
    if (ts.isPrefixUnaryExpression(node) || ts.isPostfixUnaryExpression(node)) {
      return this.isComptime(node.operand);
    }
    if (ts.isConditionalExpression(node)) {
      return this.isComptime(node.condition) && this.isComptime(node.whenTrue) && this.isComptime(node.whenFalse);
    }
    if (ts.isParenthesizedExpression(node)) {
      return this.isComptime(node.expression);
    }
    if (ts.isIdentifier(node)) {
      const symbol = this.typeChecker.getSymbolAtLocation(node);
      if (symbol) {
        const declarations = symbol.getDeclarations();
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isVariableDeclaration(decl)) {
            const parent = decl.parent;
            if (ts.isVariableDeclarationList(parent)) {
              if (parent.flags & ts.NodeFlags.Const) {
                return decl.initializer ? this.isComptime(decl.initializer) : false;
              }
            }
          }
        }
      }
    }
    return false;
  }
  evaluateNode(node) {
    if (ts.isNumericLiteral(node)) {
      return { kind: "number", value: parseFloat(node.text) };
    }
    if (ts.isStringLiteral(node)) {
      return { kind: "string", value: node.text };
    }
    if (node.kind === ts.SyntaxKind.TrueKeyword) {
      return { kind: "boolean", value: true };
    }
    if (node.kind === ts.SyntaxKind.FalseKeyword) {
      return { kind: "boolean", value: false };
    }
    if (node.kind === ts.SyntaxKind.NullKeyword) {
      return { kind: "null" };
    }
    if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
      return { kind: "undefined" };
    }
    if (ts.isArrayLiteralExpression(node)) {
      const elements = node.elements.map((e) => this.evaluateNode(e));
      const hasError = elements.find((e) => e.kind === "error");
      if (hasError) return hasError;
      return { kind: "array", elements };
    }
    if (ts.isObjectLiteralExpression(node)) {
      const properties = /* @__PURE__ */ new Map();
      for (const prop of node.properties) {
        if (ts.isPropertyAssignment(prop)) {
          const name = ts.isIdentifier(prop.name) ? prop.name.text : ts.isStringLiteral(prop.name) ? prop.name.text : null;
          if (name) {
            const value = this.evaluateNode(prop.initializer);
            if (value.kind === "error") return value;
            properties.set(name, value);
          }
        }
      }
      return { kind: "object", properties };
    }
    if (ts.isParenthesizedExpression(node)) {
      return this.evaluateNode(node.expression);
    }
    if (ts.isBinaryExpression(node)) {
      return this.evaluateBinaryExpression(node);
    }
    if (ts.isPrefixUnaryExpression(node)) {
      return this.evaluatePrefixUnary(node);
    }
    if (ts.isConditionalExpression(node)) {
      const condition = this.evaluateNode(node.condition);
      if (condition.kind === "error") return condition;
      const condValue = this.comptimeToBoolean(condition);
      if (condValue === null) {
        return { kind: "error", message: "Cannot convert to boolean" };
      }
      return condValue ? this.evaluateNode(node.whenTrue) : this.evaluateNode(node.whenFalse);
    }
    if (ts.isTemplateExpression(node)) {
      let result = node.head.text;
      for (const span of node.templateSpans) {
        const value = this.evaluateNode(span.expression);
        if (value.kind === "error") return value;
        result += this.comptimeToString(value) + span.literal.text;
      }
      return { kind: "string", value: result };
    }
    if (ts.isNoSubstitutionTemplateLiteral(node)) {
      return { kind: "string", value: node.text };
    }
    if (ts.isArrowFunction(node)) {
      return {
        kind: "function",
        fn: (..._args) => {
          if (ts.isBlock(node.body)) {
            return {
              kind: "error",
              message: "Block body arrow functions not yet supported"
            };
          }
          return this.evaluateNode(node.body);
        }
      };
    }
    if (ts.isCallExpression(node)) {
      const fn = this.evaluateNode(node.expression);
      if (fn.kind === "function") {
        const args = node.arguments.map((a) => this.evaluateNode(a));
        const errorArg = args.find((a) => a.kind === "error");
        if (errorArg) return errorArg;
        return fn.fn(...args);
      }
    }
    return {
      kind: "error",
      message: `Cannot evaluate node of kind ${ts.SyntaxKind[node.kind]} at compile time`
    };
  }
  evaluateBinaryExpression(node) {
    const left = this.evaluateNode(node.left);
    const right = this.evaluateNode(node.right);
    if (left.kind === "error") return left;
    if (right.kind === "error") return right;
    const op = node.operatorToken.kind;
    if (left.kind === "number" && right.kind === "number") {
      switch (op) {
        case ts.SyntaxKind.PlusToken:
          return { kind: "number", value: left.value + right.value };
        case ts.SyntaxKind.MinusToken:
          return { kind: "number", value: left.value - right.value };
        case ts.SyntaxKind.AsteriskToken:
          return { kind: "number", value: left.value * right.value };
        case ts.SyntaxKind.SlashToken:
          return { kind: "number", value: left.value / right.value };
        case ts.SyntaxKind.PercentToken:
          return { kind: "number", value: left.value % right.value };
        case ts.SyntaxKind.AsteriskAsteriskToken:
          return { kind: "number", value: left.value ** right.value };
        case ts.SyntaxKind.LessThanToken:
          return { kind: "boolean", value: left.value < right.value };
        case ts.SyntaxKind.LessThanEqualsToken:
          return { kind: "boolean", value: left.value <= right.value };
        case ts.SyntaxKind.GreaterThanToken:
          return { kind: "boolean", value: left.value > right.value };
        case ts.SyntaxKind.GreaterThanEqualsToken:
          return { kind: "boolean", value: left.value >= right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
        case ts.SyntaxKind.AmpersandToken:
          return { kind: "number", value: left.value & right.value };
        case ts.SyntaxKind.BarToken:
          return { kind: "number", value: left.value | right.value };
        case ts.SyntaxKind.CaretToken:
          return { kind: "number", value: left.value ^ right.value };
        case ts.SyntaxKind.LessThanLessThanToken:
          return { kind: "number", value: left.value << right.value };
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
          return { kind: "number", value: left.value >> right.value };
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
          return { kind: "number", value: left.value >>> right.value };
      }
    }
    if (left.kind === "string" && right.kind === "string") {
      switch (op) {
        case ts.SyntaxKind.PlusToken:
          return { kind: "string", value: left.value + right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
        case ts.SyntaxKind.LessThanToken:
          return { kind: "boolean", value: left.value < right.value };
        case ts.SyntaxKind.GreaterThanToken:
          return { kind: "boolean", value: left.value > right.value };
      }
    }
    if (left.kind === "string" && right.kind === "number" || left.kind === "number" && right.kind === "string") {
      if (op === ts.SyntaxKind.PlusToken) {
        return {
          kind: "string",
          value: this.comptimeToString(left) + this.comptimeToString(right)
        };
      }
    }
    if (left.kind === "boolean" && right.kind === "boolean") {
      switch (op) {
        case ts.SyntaxKind.AmpersandAmpersandToken:
          return { kind: "boolean", value: left.value && right.value };
        case ts.SyntaxKind.BarBarToken:
          return { kind: "boolean", value: left.value || right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
      }
    }
    return {
      kind: "error",
      message: `Cannot apply operator ${ts.SyntaxKind[op]} to ${left.kind} and ${right.kind}`
    };
  }
  evaluatePrefixUnary(node) {
    const operand = this.evaluateNode(node.operand);
    if (operand.kind === "error") return operand;
    switch (node.operator) {
      case ts.SyntaxKind.MinusToken:
        if (operand.kind === "number") {
          return { kind: "number", value: -operand.value };
        }
        break;
      case ts.SyntaxKind.PlusToken:
        if (operand.kind === "number") {
          return { kind: "number", value: +operand.value };
        }
        break;
      case ts.SyntaxKind.ExclamationToken:
        const boolValue = this.comptimeToBoolean(operand);
        if (boolValue !== null) {
          return { kind: "boolean", value: !boolValue };
        }
        break;
      case ts.SyntaxKind.TildeToken:
        if (operand.kind === "number") {
          return { kind: "number", value: ~operand.value };
        }
        break;
    }
    return {
      kind: "error",
      message: `Cannot apply unary ${ts.SyntaxKind[node.operator]} to ${operand.kind}`
    };
  }
  comptimeToBoolean(value) {
    switch (value.kind) {
      case "boolean":
        return value.value;
      case "number":
        return value.value !== 0;
      case "string":
        return value.value !== "";
      case "null":
      case "undefined":
        return false;
      case "array":
      case "object":
      case "function":
        return true;
      default:
        return null;
    }
  }
  comptimeToString(value) {
    switch (value.kind) {
      case "string":
        return value.value;
      case "number":
        return String(value.value);
      case "boolean":
        return String(value.value);
      case "null":
        return "null";
      case "undefined":
        return "undefined";
      case "array":
        return `[${value.elements.map((e) => this.comptimeToString(e)).join(", ")}]`;
      case "object":
        const entries = Array.from(value.properties.entries()).map(([k, v]) => `${k}: ${this.comptimeToString(v)}`).join(", ");
        return `{ ${entries} }`;
      case "function":
        return "[Function]";
      case "type":
        return "[Type]";
      case "error":
        return `[Error: ${value.message}]`;
    }
  }
  // -------------------------------------------------------------------------
  // Unique Name Generation
  // -------------------------------------------------------------------------
  generateUniqueName(prefix) {
    const name = `__typemacro_${prefix}_${this.uniqueNameCounter++}__`;
    return this.factory.createIdentifier(name);
  }
  // -------------------------------------------------------------------------
  // Helper: Convert ComptimeValue to TypeScript Expression
  // -------------------------------------------------------------------------
  comptimeValueToExpression(value) {
    switch (value.kind) {
      case "number":
        return this.createNumericLiteral(value.value);
      case "string":
        return this.createStringLiteral(value.value);
      case "boolean":
        return this.createBooleanLiteral(value.value);
      case "null":
        return this.factory.createNull();
      case "undefined":
        return this.factory.createIdentifier("undefined");
      case "array":
        return this.createArrayLiteral(
          value.elements.map((e) => this.comptimeValueToExpression(e))
        );
      case "object":
        const props = [];
        value.properties.forEach((v, k) => {
          props.push({ name: k, value: this.comptimeValueToExpression(v) });
        });
        return this.createObjectLiteral(props);
      case "error":
        throw new Error(
          `Cannot convert error value to expression: ${value.message}`
        );
      default:
        throw new Error(`Cannot convert ${value.kind} to expression`);
    }
  }
};
function createMacroContext(program, sourceFile, transformContext) {
  return new MacroContextImpl(
    program,
    program.getTypeChecker(),
    sourceFile,
    transformContext.factory,
    transformContext
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MacroContextImpl,
  createExtensionRegistry,
  createMacroContext,
  createRegistry,
  defineAttributeMacro,
  defineDeriveMacro,
  defineExpressionMacro,
  defineLabeledBlockMacro,
  defineTaggedTemplateMacro,
  defineTypeMacro,
  globalExtensionRegistry,
  globalRegistry,
  registerMacros
});
//# sourceMappingURL=index.cjs.map