{"version":3,"sources":["../src/registry.ts","../src/context.ts"],"sourcesContent":["/**\n * Macro Registry - Stores and retrieves macro definitions\n */\n\nimport {\n  MacroDefinition,\n  MacroRegistry,\n  ExpressionMacro,\n  AttributeMacro,\n  DeriveMacro,\n  TaggedTemplateMacroDef,\n  TypeMacro,\n  LabeledBlockMacro,\n} from \"./types.js\";\n\n/**\n * Key for module-scoped macro lookup: \"module::exportName\"\n */\nfunction moduleKey(mod: string, exportName: string): string {\n  return `${mod}::${exportName}`;\n}\n\nclass MacroRegistryImpl implements MacroRegistry {\n  private expressionMacros = new Map<string, ExpressionMacro>();\n  private attributeMacros = new Map<string, AttributeMacro>();\n  private deriveMacros = new Map<string, DeriveMacro>();\n  private taggedTemplateMacros = new Map<string, TaggedTemplateMacroDef>();\n  private typeMacros = new Map<string, TypeMacro>();\n  private labeledBlockMacros = new Map<string, LabeledBlockMacro>();\n\n  /**\n   * Secondary index: module-scoped lookup for macros that declare a `module`.\n   * Key is \"module::exportName\", value is the macro definition.\n   */\n  private moduleScopedMacros = new Map<string, MacroDefinition>();\n\n  register(macro: MacroDefinition): void {\n    switch (macro.kind) {\n      case \"expression\":\n        if (this.expressionMacros.has(macro.name)) {\n          throw new Error(\n            `Expression macro '${macro.name}' is already registered`,\n          );\n        }\n        this.expressionMacros.set(macro.name, macro);\n        break;\n\n      case \"attribute\":\n        if (this.attributeMacros.has(macro.name)) {\n          throw new Error(\n            `Attribute macro '${macro.name}' is already registered`,\n          );\n        }\n        this.attributeMacros.set(macro.name, macro);\n        break;\n\n      case \"derive\":\n        if (this.deriveMacros.has(macro.name)) {\n          throw new Error(`Derive macro '${macro.name}' is already registered`);\n        }\n        this.deriveMacros.set(macro.name, macro);\n        break;\n\n      case \"tagged-template\":\n        if (this.taggedTemplateMacros.has(macro.name)) {\n          throw new Error(\n            `Tagged template macro '${macro.name}' is already registered`,\n          );\n        }\n        this.taggedTemplateMacros.set(macro.name, macro);\n        break;\n\n      case \"type\":\n        if (this.typeMacros.has(macro.name)) {\n          throw new Error(`Type macro '${macro.name}' is already registered`);\n        }\n        this.typeMacros.set(macro.name, macro);\n        break;\n\n      case \"labeled-block\":\n        if (this.labeledBlockMacros.has(macro.label)) {\n          throw new Error(\n            `Labeled block macro for label '${macro.label}' is already registered`,\n          );\n        }\n        this.labeledBlockMacros.set(macro.label, macro);\n        break;\n\n      default:\n        throw new Error(\n          `Unknown macro kind: ${(macro as MacroDefinition).kind}`,\n        );\n    }\n\n    // Index by module if the macro declares one\n    if (macro.module) {\n      const exportName = macro.exportName ?? macro.name;\n      const key = moduleKey(macro.module, exportName);\n      this.moduleScopedMacros.set(key, macro);\n    }\n  }\n\n  getExpression(name: string): ExpressionMacro | undefined {\n    return this.expressionMacros.get(name);\n  }\n\n  getAttribute(name: string): AttributeMacro | undefined {\n    return this.attributeMacros.get(name);\n  }\n\n  getDerive(name: string): DeriveMacro | undefined {\n    return this.deriveMacros.get(name);\n  }\n\n  getTaggedTemplate(name: string): TaggedTemplateMacroDef | undefined {\n    return this.taggedTemplateMacros.get(name);\n  }\n\n  getType(name: string): TypeMacro | undefined {\n    return this.typeMacros.get(name);\n  }\n\n  getLabeledBlock(label: string): LabeledBlockMacro | undefined {\n    return this.labeledBlockMacros.get(label);\n  }\n\n  /**\n   * Look up a macro by its source module and export name.\n   * Returns the macro if it was registered with a matching module+exportName.\n   */\n  getByModuleExport(\n    mod: string,\n    exportName: string,\n  ): MacroDefinition | undefined {\n    return this.moduleScopedMacros.get(moduleKey(mod, exportName));\n  }\n\n  /**\n   * Check whether a macro (looked up by name) requires import-scoping.\n   * Returns true if the macro has a `module` field set.\n   */\n  isImportScoped(name: string, kind: MacroDefinition[\"kind\"]): boolean {\n    let macro: MacroDefinition | undefined;\n    switch (kind) {\n      case \"expression\":\n        macro = this.expressionMacros.get(name);\n        break;\n      case \"attribute\":\n        macro = this.attributeMacros.get(name);\n        break;\n      case \"derive\":\n        macro = this.deriveMacros.get(name);\n        break;\n      case \"tagged-template\":\n        macro = this.taggedTemplateMacros.get(name);\n        break;\n      case \"type\":\n        macro = this.typeMacros.get(name);\n        break;\n      case \"labeled-block\":\n        macro = this.labeledBlockMacros.get(name);\n        break;\n    }\n    return macro?.module !== undefined;\n  }\n\n  getAll(): MacroDefinition[] {\n    return [\n      ...this.expressionMacros.values(),\n      ...this.attributeMacros.values(),\n      ...this.deriveMacros.values(),\n      ...this.taggedTemplateMacros.values(),\n      ...this.typeMacros.values(),\n      ...this.labeledBlockMacros.values(),\n    ];\n  }\n\n  /** Clear all registered macros (useful for testing) */\n  clear(): void {\n    this.expressionMacros.clear();\n    this.attributeMacros.clear();\n    this.deriveMacros.clear();\n    this.taggedTemplateMacros.clear();\n    this.typeMacros.clear();\n    this.labeledBlockMacros.clear();\n    this.moduleScopedMacros.clear();\n  }\n}\n\n/** Global macro registry singleton */\nexport const globalRegistry = new MacroRegistryImpl();\n\n/** Create a new isolated registry (for testing or scoped usage) */\nexport function createRegistry(): MacroRegistry {\n  return new MacroRegistryImpl();\n}\n\n// ============================================================================\n// Macro Definition Helpers\n// ============================================================================\n\n/**\n * Define an expression macro with type inference\n */\nexport function defineExpressionMacro(\n  definition: Omit<ExpressionMacro, \"kind\">,\n): ExpressionMacro {\n  return {\n    ...definition,\n    kind: \"expression\",\n  };\n}\n\n/**\n * Define an attribute macro with type inference\n */\nexport function defineAttributeMacro(\n  definition: Omit<AttributeMacro, \"kind\">,\n): AttributeMacro {\n  return {\n    ...definition,\n    kind: \"attribute\",\n  };\n}\n\n/**\n * Define a derive macro with type inference\n */\nexport function defineDeriveMacro(\n  definition: Omit<DeriveMacro, \"kind\">,\n): DeriveMacro {\n  return {\n    ...definition,\n    kind: \"derive\",\n  };\n}\n\n/**\n * Define a tagged template macro with type inference\n */\nexport function defineTaggedTemplateMacro(\n  definition: Omit<TaggedTemplateMacroDef, \"kind\">,\n): TaggedTemplateMacroDef {\n  return {\n    ...definition,\n    kind: \"tagged-template\",\n  };\n}\n\n/**\n * Define a type macro with type inference\n */\nexport function defineTypeMacro(\n  definition: Omit<TypeMacro, \"kind\">,\n): TypeMacro {\n  return {\n    ...definition,\n    kind: \"type\",\n  };\n}\n\n/**\n * Define a labeled block macro with type inference\n */\nexport function defineLabeledBlockMacro(\n  definition: Omit<LabeledBlockMacro, \"kind\">,\n): LabeledBlockMacro {\n  return {\n    ...definition,\n    kind: \"labeled-block\",\n  };\n}\n\n/**\n * Register multiple macros at once\n */\nexport function registerMacros(\n  registry: MacroRegistry,\n  ...macros: MacroDefinition[]\n): void {\n  for (const macro of macros) {\n    registry.register(macro);\n  }\n}\n\n// ============================================================================\n// Extension Method Registry Implementation\n// ============================================================================\n\nimport { ExtensionMethodInfo, ExtensionMethodRegistry } from \"./types.js\";\n\nclass ExtensionMethodRegistryImpl implements ExtensionMethodRegistry {\n  private extensions = new Map<string, ExtensionMethodInfo[]>();\n\n  private makeKey(methodName: string, forType: string): string {\n    return `${forType}::${methodName}`;\n  }\n\n  register(info: ExtensionMethodInfo): void {\n    const key = this.makeKey(info.methodName, info.forType);\n    const existing = this.extensions.get(key) ?? [];\n    existing.push(info);\n    this.extensions.set(key, existing);\n  }\n\n  find(methodName: string, forType: string): ExtensionMethodInfo | undefined {\n    const key = this.makeKey(methodName, forType);\n    const matches = this.extensions.get(key);\n    return matches?.[0];\n  }\n\n  getForType(forType: string): ExtensionMethodInfo[] {\n    const results: ExtensionMethodInfo[] = [];\n    for (const [key, infos] of this.extensions) {\n      if (key.startsWith(forType + \"::\")) {\n        results.push(...infos);\n      }\n    }\n    return results;\n  }\n\n  clear(): void {\n    this.extensions.clear();\n  }\n}\n\n/** Global extension method registry singleton */\nexport const globalExtensionRegistry: ExtensionMethodRegistry =\n  new ExtensionMethodRegistryImpl();\n\n/** Create a new isolated extension registry (for testing) */\nexport function createExtensionRegistry(): ExtensionMethodRegistry {\n  return new ExtensionMethodRegistryImpl();\n}\n","/**\n * MacroContext Implementation - Provides utilities for macro expansion\n */\n\nimport * as ts from \"typescript\";\nimport { MacroContext, ComptimeValue, MacroDiagnostic } from \"./types.js\";\n\nexport class MacroContextImpl implements MacroContext {\n  private diagnostics: MacroDiagnostic[] = [];\n  private uniqueNameCounter = 0;\n\n  constructor(\n    public readonly program: ts.Program,\n    public readonly typeChecker: ts.TypeChecker,\n    public readonly sourceFile: ts.SourceFile,\n    public readonly factory: ts.NodeFactory,\n    public readonly transformContext: ts.TransformationContext,\n  ) {}\n\n  // -------------------------------------------------------------------------\n  // Node Creation Utilities\n  // -------------------------------------------------------------------------\n\n  createIdentifier(name: string): ts.Identifier {\n    return this.factory.createIdentifier(name);\n  }\n\n  createNumericLiteral(value: number): ts.NumericLiteral {\n    return this.factory.createNumericLiteral(value);\n  }\n\n  createStringLiteral(value: string): ts.StringLiteral {\n    return this.factory.createStringLiteral(value);\n  }\n\n  createBooleanLiteral(value: boolean): ts.Expression {\n    return value ? this.factory.createTrue() : this.factory.createFalse();\n  }\n\n  createArrayLiteral(elements: ts.Expression[]): ts.ArrayLiteralExpression {\n    return this.factory.createArrayLiteralExpression(elements);\n  }\n\n  createObjectLiteral(\n    properties: Array<{ name: string; value: ts.Expression }>,\n  ): ts.ObjectLiteralExpression {\n    const propAssignments = properties.map(({ name, value }) =>\n      this.factory.createPropertyAssignment(\n        this.factory.createIdentifier(name),\n        value,\n      ),\n    );\n    return this.factory.createObjectLiteralExpression(propAssignments, true);\n  }\n\n  parseExpression(code: string): ts.Expression {\n    // Create a temporary source file to parse the expression\n    const tempSource = ts.createSourceFile(\n      \"__macro_temp__.ts\",\n      `const __expr__ = ${code};`,\n      ts.ScriptTarget.Latest,\n      true,\n      ts.ScriptKind.TS,\n    );\n\n    // Extract the expression from the variable declaration\n    const statement = tempSource.statements[0];\n    if (ts.isVariableStatement(statement)) {\n      const declaration = statement.declarationList.declarations[0];\n      if (declaration.initializer) {\n        return declaration.initializer;\n      }\n    }\n\n    throw new Error(`Failed to parse expression: ${code}`);\n  }\n\n  parseStatements(code: string): ts.Statement[] {\n    const tempSource = ts.createSourceFile(\n      \"__macro_temp__.ts\",\n      code,\n      ts.ScriptTarget.Latest,\n      true,\n      ts.ScriptKind.TS,\n    );\n    return Array.from(tempSource.statements);\n  }\n\n  // -------------------------------------------------------------------------\n  // Type Utilities\n  // -------------------------------------------------------------------------\n\n  getTypeOf(node: ts.Node): ts.Type {\n    return this.typeChecker.getTypeAtLocation(node);\n  }\n\n  getTypeString(node: ts.Node): string {\n    const type = this.getTypeOf(node);\n    return this.typeChecker.typeToString(type);\n  }\n\n  isAssignableTo(source: ts.Type, target: ts.Type): boolean {\n    return this.typeChecker.isTypeAssignableTo(source, target);\n  }\n\n  getPropertiesOfType(type: ts.Type): ts.Symbol[] {\n    return this.typeChecker.getPropertiesOfType(type);\n  }\n\n  getSymbol(node: ts.Node): ts.Symbol | undefined {\n    return this.typeChecker.getSymbolAtLocation(node);\n  }\n\n  // -------------------------------------------------------------------------\n  // Diagnostics\n  // -------------------------------------------------------------------------\n\n  reportError(node: ts.Node, message: string): void {\n    this.diagnostics.push({\n      severity: \"error\",\n      message,\n      node,\n    });\n  }\n\n  reportWarning(node: ts.Node, message: string): void {\n    this.diagnostics.push({\n      severity: \"warning\",\n      message,\n      node,\n    });\n  }\n\n  getDiagnostics(): MacroDiagnostic[] {\n    return [...this.diagnostics];\n  }\n\n  clearDiagnostics(): void {\n    this.diagnostics = [];\n  }\n\n  // -------------------------------------------------------------------------\n  // Compile-Time Evaluation\n  // -------------------------------------------------------------------------\n\n  evaluate(node: ts.Node): ComptimeValue {\n    return this.evaluateNode(node);\n  }\n\n  isComptime(node: ts.Node): boolean {\n    // Check if a node can be evaluated at compile time\n    if (ts.isLiteralExpression(node)) {\n      return true;\n    }\n\n    if (ts.isArrayLiteralExpression(node)) {\n      return node.elements.every((e) => this.isComptime(e));\n    }\n\n    if (ts.isObjectLiteralExpression(node)) {\n      return node.properties.every((p) => {\n        if (ts.isPropertyAssignment(p)) {\n          return this.isComptime(p.initializer);\n        }\n        return false;\n      });\n    }\n\n    if (ts.isBinaryExpression(node)) {\n      return this.isComptime(node.left) && this.isComptime(node.right);\n    }\n\n    if (ts.isPrefixUnaryExpression(node) || ts.isPostfixUnaryExpression(node)) {\n      return this.isComptime(node.operand);\n    }\n\n    if (ts.isConditionalExpression(node)) {\n      return (\n        this.isComptime(node.condition) &&\n        this.isComptime(node.whenTrue) &&\n        this.isComptime(node.whenFalse)\n      );\n    }\n\n    if (ts.isParenthesizedExpression(node)) {\n      return this.isComptime(node.expression);\n    }\n\n    // Identifiers are comptime only if they refer to const values\n    if (ts.isIdentifier(node)) {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n      if (symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0) {\n          const decl = declarations[0];\n          if (ts.isVariableDeclaration(decl)) {\n            const parent = decl.parent;\n            if (ts.isVariableDeclarationList(parent)) {\n              if (parent.flags & ts.NodeFlags.Const) {\n                return decl.initializer\n                  ? this.isComptime(decl.initializer)\n                  : false;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private evaluateNode(node: ts.Node): ComptimeValue {\n    // Numeric literals\n    if (ts.isNumericLiteral(node)) {\n      return { kind: \"number\", value: parseFloat(node.text) };\n    }\n\n    // String literals\n    if (ts.isStringLiteral(node)) {\n      return { kind: \"string\", value: node.text };\n    }\n\n    // Boolean literals\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return { kind: \"boolean\", value: true };\n    }\n    if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return { kind: \"boolean\", value: false };\n    }\n\n    // Null/undefined\n    if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return { kind: \"null\" };\n    }\n    if (node.kind === ts.SyntaxKind.UndefinedKeyword) {\n      return { kind: \"undefined\" };\n    }\n\n    // Array literals\n    if (ts.isArrayLiteralExpression(node)) {\n      const elements = node.elements.map((e) => this.evaluateNode(e));\n      const hasError = elements.find((e) => e.kind === \"error\");\n      if (hasError) return hasError;\n      return { kind: \"array\", elements };\n    }\n\n    // Object literals\n    if (ts.isObjectLiteralExpression(node)) {\n      const properties = new Map<string, ComptimeValue>();\n      for (const prop of node.properties) {\n        if (ts.isPropertyAssignment(prop)) {\n          const name = ts.isIdentifier(prop.name)\n            ? prop.name.text\n            : ts.isStringLiteral(prop.name)\n              ? prop.name.text\n              : null;\n          if (name) {\n            const value = this.evaluateNode(prop.initializer);\n            if (value.kind === \"error\") return value;\n            properties.set(name, value);\n          }\n        }\n      }\n      return { kind: \"object\", properties };\n    }\n\n    // Parenthesized expressions\n    if (ts.isParenthesizedExpression(node)) {\n      return this.evaluateNode(node.expression);\n    }\n\n    // Binary expressions\n    if (ts.isBinaryExpression(node)) {\n      return this.evaluateBinaryExpression(node);\n    }\n\n    // Prefix unary expressions\n    if (ts.isPrefixUnaryExpression(node)) {\n      return this.evaluatePrefixUnary(node);\n    }\n\n    // Conditional expressions (ternary)\n    if (ts.isConditionalExpression(node)) {\n      const condition = this.evaluateNode(node.condition);\n      if (condition.kind === \"error\") return condition;\n      const condValue = this.comptimeToBoolean(condition);\n      if (condValue === null) {\n        return { kind: \"error\", message: \"Cannot convert to boolean\" };\n      }\n      return condValue\n        ? this.evaluateNode(node.whenTrue)\n        : this.evaluateNode(node.whenFalse);\n    }\n\n    // Template literals (simple case)\n    if (ts.isTemplateExpression(node)) {\n      let result = node.head.text;\n      for (const span of node.templateSpans) {\n        const value = this.evaluateNode(span.expression);\n        if (value.kind === \"error\") return value;\n        result += this.comptimeToString(value) + span.literal.text;\n      }\n      return { kind: \"string\", value: result };\n    }\n\n    if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return { kind: \"string\", value: node.text };\n    }\n\n    // Arrow functions - return as function value for later evaluation\n    if (ts.isArrowFunction(node)) {\n      return {\n        kind: \"function\",\n        fn: (..._args: ComptimeValue[]) => {\n          // For now, we only support simple arrow functions\n          if (ts.isBlock(node.body)) {\n            return {\n              kind: \"error\",\n              message: \"Block body arrow functions not yet supported\",\n            };\n          }\n          return this.evaluateNode(node.body);\n        },\n      };\n    }\n\n    // Call expressions - evaluate function calls at compile time\n    if (ts.isCallExpression(node)) {\n      const fn = this.evaluateNode(node.expression);\n      if (fn.kind === \"function\") {\n        const args = node.arguments.map((a) => this.evaluateNode(a));\n        const errorArg = args.find((a) => a.kind === \"error\");\n        if (errorArg) return errorArg;\n        return fn.fn(...args);\n      }\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot evaluate node of kind ${ts.SyntaxKind[node.kind]} at compile time`,\n    };\n  }\n\n  private evaluateBinaryExpression(node: ts.BinaryExpression): ComptimeValue {\n    const left = this.evaluateNode(node.left);\n    const right = this.evaluateNode(node.right);\n\n    if (left.kind === \"error\") return left;\n    if (right.kind === \"error\") return right;\n\n    const op = node.operatorToken.kind;\n\n    // Numeric operations\n    if (left.kind === \"number\" && right.kind === \"number\") {\n      switch (op) {\n        case ts.SyntaxKind.PlusToken:\n          return { kind: \"number\", value: left.value + right.value };\n        case ts.SyntaxKind.MinusToken:\n          return { kind: \"number\", value: left.value - right.value };\n        case ts.SyntaxKind.AsteriskToken:\n          return { kind: \"number\", value: left.value * right.value };\n        case ts.SyntaxKind.SlashToken:\n          return { kind: \"number\", value: left.value / right.value };\n        case ts.SyntaxKind.PercentToken:\n          return { kind: \"number\", value: left.value % right.value };\n        case ts.SyntaxKind.AsteriskAsteriskToken:\n          return { kind: \"number\", value: left.value ** right.value };\n        case ts.SyntaxKind.LessThanToken:\n          return { kind: \"boolean\", value: left.value < right.value };\n        case ts.SyntaxKind.LessThanEqualsToken:\n          return { kind: \"boolean\", value: left.value <= right.value };\n        case ts.SyntaxKind.GreaterThanToken:\n          return { kind: \"boolean\", value: left.value > right.value };\n        case ts.SyntaxKind.GreaterThanEqualsToken:\n          return { kind: \"boolean\", value: left.value >= right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n        case ts.SyntaxKind.AmpersandToken:\n          return { kind: \"number\", value: left.value & right.value };\n        case ts.SyntaxKind.BarToken:\n          return { kind: \"number\", value: left.value | right.value };\n        case ts.SyntaxKind.CaretToken:\n          return { kind: \"number\", value: left.value ^ right.value };\n        case ts.SyntaxKind.LessThanLessThanToken:\n          return { kind: \"number\", value: left.value << right.value };\n        case ts.SyntaxKind.GreaterThanGreaterThanToken:\n          return { kind: \"number\", value: left.value >> right.value };\n        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n          return { kind: \"number\", value: left.value >>> right.value };\n      }\n    }\n\n    // String operations\n    if (left.kind === \"string\" && right.kind === \"string\") {\n      switch (op) {\n        case ts.SyntaxKind.PlusToken:\n          return { kind: \"string\", value: left.value + right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n        case ts.SyntaxKind.LessThanToken:\n          return { kind: \"boolean\", value: left.value < right.value };\n        case ts.SyntaxKind.GreaterThanToken:\n          return { kind: \"boolean\", value: left.value > right.value };\n      }\n    }\n\n    // String + number concatenation\n    if (\n      (left.kind === \"string\" && right.kind === \"number\") ||\n      (left.kind === \"number\" && right.kind === \"string\")\n    ) {\n      if (op === ts.SyntaxKind.PlusToken) {\n        return {\n          kind: \"string\",\n          value: this.comptimeToString(left) + this.comptimeToString(right),\n        };\n      }\n    }\n\n    // Boolean operations\n    if (left.kind === \"boolean\" && right.kind === \"boolean\") {\n      switch (op) {\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n          return { kind: \"boolean\", value: left.value && right.value };\n        case ts.SyntaxKind.BarBarToken:\n          return { kind: \"boolean\", value: left.value || right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n      }\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot apply operator ${ts.SyntaxKind[op]} to ${left.kind} and ${right.kind}`,\n    };\n  }\n\n  private evaluatePrefixUnary(node: ts.PrefixUnaryExpression): ComptimeValue {\n    const operand = this.evaluateNode(node.operand);\n    if (operand.kind === \"error\") return operand;\n\n    switch (node.operator) {\n      case ts.SyntaxKind.MinusToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: -operand.value };\n        }\n        break;\n      case ts.SyntaxKind.PlusToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: +operand.value };\n        }\n        break;\n      case ts.SyntaxKind.ExclamationToken:\n        const boolValue = this.comptimeToBoolean(operand);\n        if (boolValue !== null) {\n          return { kind: \"boolean\", value: !boolValue };\n        }\n        break;\n      case ts.SyntaxKind.TildeToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: ~operand.value };\n        }\n        break;\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot apply unary ${ts.SyntaxKind[node.operator]} to ${operand.kind}`,\n    };\n  }\n\n  private comptimeToBoolean(value: ComptimeValue): boolean | null {\n    switch (value.kind) {\n      case \"boolean\":\n        return value.value;\n      case \"number\":\n        return value.value !== 0;\n      case \"string\":\n        return value.value !== \"\";\n      case \"null\":\n      case \"undefined\":\n        return false;\n      case \"array\":\n      case \"object\":\n      case \"function\":\n        return true;\n      default:\n        return null;\n    }\n  }\n\n  private comptimeToString(value: ComptimeValue): string {\n    switch (value.kind) {\n      case \"string\":\n        return value.value;\n      case \"number\":\n        return String(value.value);\n      case \"boolean\":\n        return String(value.value);\n      case \"null\":\n        return \"null\";\n      case \"undefined\":\n        return \"undefined\";\n      case \"array\":\n        return `[${value.elements.map((e) => this.comptimeToString(e)).join(\", \")}]`;\n      case \"object\":\n        const entries = Array.from(value.properties.entries())\n          .map(([k, v]) => `${k}: ${this.comptimeToString(v)}`)\n          .join(\", \");\n        return `{ ${entries} }`;\n      case \"function\":\n        return \"[Function]\";\n      case \"type\":\n        return \"[Type]\";\n      case \"error\":\n        return `[Error: ${value.message}]`;\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Unique Name Generation\n  // -------------------------------------------------------------------------\n\n  generateUniqueName(prefix: string): ts.Identifier {\n    const name = `__typemacro_${prefix}_${this.uniqueNameCounter++}__`;\n    return this.factory.createIdentifier(name);\n  }\n\n  // -------------------------------------------------------------------------\n  // Helper: Convert ComptimeValue to TypeScript Expression\n  // -------------------------------------------------------------------------\n\n  comptimeValueToExpression(value: ComptimeValue): ts.Expression {\n    switch (value.kind) {\n      case \"number\":\n        return this.createNumericLiteral(value.value);\n      case \"string\":\n        return this.createStringLiteral(value.value);\n      case \"boolean\":\n        return this.createBooleanLiteral(value.value);\n      case \"null\":\n        return this.factory.createNull();\n      case \"undefined\":\n        return this.factory.createIdentifier(\"undefined\");\n      case \"array\":\n        return this.createArrayLiteral(\n          value.elements.map((e) => this.comptimeValueToExpression(e)),\n        );\n      case \"object\":\n        const props: Array<{ name: string; value: ts.Expression }> = [];\n        value.properties.forEach((v, k) => {\n          props.push({ name: k, value: this.comptimeValueToExpression(v) });\n        });\n        return this.createObjectLiteral(props);\n      case \"error\":\n        throw new Error(\n          `Cannot convert error value to expression: ${value.message}`,\n        );\n      default:\n        throw new Error(`Cannot convert ${value.kind} to expression`);\n    }\n  }\n}\n\n/**\n * Create a macro context for a given program and source file\n */\nexport function createMacroContext(\n  program: ts.Program,\n  sourceFile: ts.SourceFile,\n  transformContext: ts.TransformationContext,\n): MacroContextImpl {\n  return new MacroContextImpl(\n    program,\n    program.getTypeChecker(),\n    sourceFile,\n    transformContext.factory,\n    transformContext,\n  );\n}\n"],"mappings":"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","names":[]}