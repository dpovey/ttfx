// src/language-service/index.ts
var EXPRESSION_MACROS = /* @__PURE__ */ new Set([
  "comptime",
  "ops",
  "pipe",
  "compose",
  "summon",
  "extend",
  "typeInfo",
  "fieldNames",
  "validator"
]);
var DECORATOR_MACROS = /* @__PURE__ */ new Set([
  "derive",
  "operators",
  "reflect",
  "typeclass",
  "instance",
  "deriving",
  "inline"
]);
var DERIVE_MACROS = [
  { name: "Eq", description: "Generate equality comparison function" },
  { name: "Ord", description: "Generate ordering/comparison function" },
  { name: "Clone", description: "Generate deep clone function" },
  { name: "Debug", description: "Generate debug string representation" },
  { name: "Hash", description: "Generate hash function" },
  { name: "Default", description: "Generate default value factory" },
  { name: "Json", description: "Generate JSON serialization/deserialization" },
  { name: "Builder", description: "Generate builder pattern class" }
];
var TAGGED_TEMPLATE_MACROS = /* @__PURE__ */ new Set([
  "sql",
  "regex",
  "html",
  "fmt",
  "json",
  "raw",
  "units"
]);
var SUPPRESSED_DIAGNOSTIC_CODES = /* @__PURE__ */ new Set([
  // "Decorators are not valid here" -- interfaces with @derive
  1206,
  // "An expression of type 'void' cannot be tested for truthiness" -- macro returns
  1345,
  // "'XYZ' is declared but its value is never read" -- macro-generated bindings
  6133,
  // "Cannot find name 'XYZ'" -- references to macro-generated identifiers
  2304
]);
function init(modules) {
  const tsModule = modules.typescript;
  function create(info) {
    const log = (msg) => {
      info.project.projectService.logger.info(`[typemacro] ${msg}`);
    };
    log("Language service plugin initialized");
    const proxy = /* @__PURE__ */ Object.create(null);
    const oldLS = info.languageService;
    for (const k of Object.keys(oldLS)) {
      const prop = oldLS[k];
      if (typeof prop === "function") {
        proxy[k] = (...args) => {
          return prop.apply(oldLS, args);
        };
      }
    }
    proxy.getSemanticDiagnostics = (fileName) => {
      const diagnostics = oldLS.getSemanticDiagnostics(fileName);
      const program = oldLS.getProgram();
      if (!program) return diagnostics;
      const sourceFile = program.getSourceFile(fileName);
      if (!sourceFile) return diagnostics;
      return diagnostics.filter((diag) => {
        if (!SUPPRESSED_DIAGNOSTIC_CODES.has(diag.code)) return true;
        if (diag.start === void 0) return true;
        const node = findNodeAtPosition(
          tsModule,
          sourceFile,
          diag.start
        );
        if (!node) return true;
        if (diag.code === 1206) {
          const decorator = findAncestor(tsModule, node, tsModule.isDecorator);
          if (decorator && tsModule.isDecorator(decorator)) {
            const name = getDecoratorName(tsModule, decorator);
            if (name && DECORATOR_MACROS.has(name)) {
              log(`Suppressed diagnostic ${diag.code} for @${name}`);
              return false;
            }
          }
        }
        if (diag.code === 2304) {
          if (isNearMacroInvocation(tsModule, sourceFile, node)) {
            log(
              `Suppressed diagnostic ${diag.code} near macro invocation`
            );
            return false;
          }
        }
        return true;
      });
    };
    proxy.getCompletionsAtPosition = (fileName, position, options) => {
      const prior = oldLS.getCompletionsAtPosition(
        fileName,
        position,
        options
      );
      const program = oldLS.getProgram();
      if (!program) return prior;
      const sourceFile = program.getSourceFile(fileName);
      if (!sourceFile) return prior;
      const node = findNodeAtPosition(tsModule, sourceFile, position);
      if (!node) return prior;
      const deriveContext = findDeriveContext(tsModule, node);
      if (deriveContext) {
        const deriveEntries = DERIVE_MACROS.map(
          (macro) => ({
            name: macro.name,
            kind: tsModule.ScriptElementKind.constElement,
            kindModifiers: "",
            sortText: `0${macro.name}`,
            labelDetails: {
              description: macro.description
            }
          })
        );
        if (prior) {
          return {
            ...prior,
            entries: [...deriveEntries, ...prior.entries]
          };
        }
        return {
          isGlobalCompletion: false,
          isMemberCompletion: false,
          isNewIdentifierLocation: false,
          entries: deriveEntries
        };
      }
      return prior;
    };
    proxy.getQuickInfoAtPosition = (fileName, position) => {
      const prior = oldLS.getQuickInfoAtPosition(fileName, position);
      const program = oldLS.getProgram();
      if (!program) return prior;
      const sourceFile = program.getSourceFile(fileName);
      if (!sourceFile) return prior;
      const node = findNodeAtPosition(tsModule, sourceFile, position);
      if (!node) return prior;
      if (tsModule.isIdentifier(node)) {
        const name = node.text;
        if (EXPRESSION_MACROS.has(name)) {
          return {
            kind: tsModule.ScriptElementKind.functionElement,
            kindModifiers: "typemacro",
            textSpan: {
              start: node.getStart(sourceFile),
              length: node.getWidth(sourceFile)
            },
            displayParts: [
              {
                text: `(typemacro expression macro) ${name}`,
                kind: "text"
              }
            ],
            documentation: [
              {
                text: "This call is expanded at compile time by the typemacro transformer.",
                kind: "text"
              }
            ]
          };
        }
        if (DECORATOR_MACROS.has(name)) {
          return {
            kind: tsModule.ScriptElementKind.functionElement,
            kindModifiers: "typemacro",
            textSpan: {
              start: node.getStart(sourceFile),
              length: node.getWidth(sourceFile)
            },
            displayParts: [
              {
                text: `(typemacro decorator macro) @${name}`,
                kind: "text"
              }
            ],
            documentation: [
              {
                text: "This decorator is processed at compile time by the typemacro transformer.",
                kind: "text"
              }
            ]
          };
        }
        if (TAGGED_TEMPLATE_MACROS.has(name)) {
          return {
            kind: tsModule.ScriptElementKind.functionElement,
            kindModifiers: "typemacro",
            textSpan: {
              start: node.getStart(sourceFile),
              length: node.getWidth(sourceFile)
            },
            displayParts: [
              {
                text: `(typemacro tagged template macro) ${name}\`...\``,
                kind: "text"
              }
            ],
            documentation: [
              {
                text: "This tagged template is processed at compile time by the typemacro transformer.",
                kind: "text"
              }
            ]
          };
        }
      }
      return prior;
    };
    return proxy;
  }
  return { create };
}
function findNodeAtPosition(ts, sourceFile, position) {
  function find(node) {
    if (position >= node.getStart(sourceFile) && position < node.getEnd()) {
      return ts.forEachChild(node, find) ?? node;
    }
    return void 0;
  }
  return find(sourceFile);
}
function findAncestor(ts, node, predicate) {
  let current = node;
  while (current) {
    if (predicate(current)) return current;
    current = current.parent;
  }
  return void 0;
}
function getDecoratorName(ts, decorator) {
  const expr = decorator.expression;
  if (ts.isIdentifier(expr)) return expr.text;
  if (ts.isCallExpression(expr) && ts.isIdentifier(expr.expression)) {
    return expr.expression.text;
  }
  return void 0;
}
function findDeriveContext(ts, node) {
  let current = node;
  while (current) {
    if (ts.isCallExpression(current)) {
      if (ts.isIdentifier(current.expression) && current.expression.text === "derive") {
        return true;
      }
    }
    if (ts.isDecorator(current)) {
      const name = getDecoratorName(ts, current);
      if (name === "derive") return true;
    }
    current = current.parent;
  }
  return false;
}
function isNearMacroInvocation(ts, sourceFile, node) {
  let current = node;
  while (current) {
    if (ts.isCallExpression(current)) {
      if (ts.isIdentifier(current.expression)) {
        if (EXPRESSION_MACROS.has(current.expression.text)) return true;
      }
    }
    if (ts.isTaggedTemplateExpression(current)) {
      if (ts.isIdentifier(current.tag)) {
        if (TAGGED_TEMPLATE_MACROS.has(current.tag.text)) return true;
      }
    }
    if (ts.isBlock(current) || ts.isSourceFile(current)) {
      for (const stmt of current.statements ?? []) {
        if (ts.isExpressionStatement(stmt) && ts.isCallExpression(stmt.expression)) {
          if (ts.isIdentifier(stmt.expression.expression)) {
            if (EXPRESSION_MACROS.has(stmt.expression.expression.text))
              return true;
          }
        }
      }
    }
    current = current.parent;
  }
  return false;
}
var language_service_default = init;
export {
  language_service_default as default
};
//# sourceMappingURL=language-service.js.map