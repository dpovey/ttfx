import * as ts from 'typescript';

/**
 * Core types for the typemacro macro system
 */

type MacroKind = "expression" | "attribute" | "derive";
interface MacroContext {
    /** The TypeScript Program instance */
    program: ts.Program;
    /** Type checker for semantic analysis */
    typeChecker: ts.TypeChecker;
    /** Current source file being processed */
    sourceFile: ts.SourceFile;
    /** TypeScript factory for creating nodes */
    factory: ts.NodeFactory;
    /** The transformer context */
    transformContext: ts.TransformationContext;
    /** Create an identifier node */
    createIdentifier(name: string): ts.Identifier;
    /** Create a numeric literal */
    createNumericLiteral(value: number): ts.NumericLiteral;
    /** Create a string literal */
    createStringLiteral(value: string): ts.StringLiteral;
    /** Create a boolean literal (true/false) */
    createBooleanLiteral(value: boolean): ts.Expression;
    /** Create an array literal from expressions */
    createArrayLiteral(elements: ts.Expression[]): ts.ArrayLiteralExpression;
    /** Create an object literal from properties */
    createObjectLiteral(properties: Array<{
        name: string;
        value: ts.Expression;
    }>): ts.ObjectLiteralExpression;
    /** Parse a code string into an expression */
    parseExpression(code: string): ts.Expression;
    /** Parse a code string into statements */
    parseStatements(code: string): ts.Statement[];
    /** Get the type of a node */
    getTypeOf(node: ts.Node): ts.Type;
    /** Get the type of a node as a string */
    getTypeString(node: ts.Node): string;
    /** Check if a type is assignable to another */
    isAssignableTo(source: ts.Type, target: ts.Type): boolean;
    /** Get properties of a type */
    getPropertiesOfType(type: ts.Type): ts.Symbol[];
    /** Get the symbol of a node */
    getSymbol(node: ts.Node): ts.Symbol | undefined;
    /** Report a compile-time error */
    reportError(node: ts.Node, message: string): void;
    /** Report a compile-time warning */
    reportWarning(node: ts.Node, message: string): void;
    /** Evaluate an expression at compile time */
    evaluate(node: ts.Node): ComptimeValue;
    /** Check if a node can be evaluated at compile time */
    isComptime(node: ts.Node): boolean;
    /** Generate a unique identifier to avoid name collisions */
    generateUniqueName(prefix: string): ts.Identifier;
}
type ComptimeValue = {
    kind: "number";
    value: number;
} | {
    kind: "string";
    value: string;
} | {
    kind: "boolean";
    value: boolean;
} | {
    kind: "null";
} | {
    kind: "undefined";
} | {
    kind: "array";
    elements: ComptimeValue[];
} | {
    kind: "object";
    properties: Map<string, ComptimeValue>;
} | {
    kind: "function";
    fn: (...args: ComptimeValue[]) => ComptimeValue;
} | {
    kind: "type";
    type: ts.Type;
} | {
    kind: "error";
    message: string;
};
/** Base interface for all macro definitions */
interface MacroDefinitionBase {
    /** Unique name of the macro */
    name: string;
    /** Optional description for documentation */
    description?: string;
}
/** Expression macro - transforms expressions */
interface ExpressionMacro extends MacroDefinitionBase {
    kind: "expression";
    /**
     * Expand the macro call into new AST nodes
     * @param ctx - The macro context
     * @param callExpr - The macro call expression
     * @param args - The arguments passed to the macro
     */
    expand(ctx: MacroContext, callExpr: ts.CallExpression, args: readonly ts.Expression[]): ts.Expression;
}
/** Attribute macro - transforms declarations */
interface AttributeMacro extends MacroDefinitionBase {
    kind: "attribute";
    /**
     * Valid targets for this attribute
     */
    validTargets: AttributeTarget[];
    /**
     * Expand the attribute macro
     * @param ctx - The macro context
     * @param decorator - The decorator node
     * @param target - The decorated declaration
     * @param args - Arguments passed to the decorator
     */
    expand(ctx: MacroContext, decorator: ts.Decorator, target: ts.Declaration, args: readonly ts.Expression[]): ts.Node | ts.Node[];
}
type AttributeTarget = "class" | "method" | "property" | "function" | "parameter" | "interface" | "type";
/** Derive macro - generates code for types */
interface DeriveMacro extends MacroDefinitionBase {
    kind: "derive";
    /**
     * Expand the derive macro for a type
     * @param ctx - The macro context
     * @param target - The type being derived
     * @param typeInfo - Extracted type information
     */
    expand(ctx: MacroContext, target: ts.InterfaceDeclaration | ts.ClassDeclaration | ts.TypeAliasDeclaration, typeInfo: DeriveTypeInfo): ts.Statement[];
}
/** Information about a type for derive macros */
interface DeriveTypeInfo {
    /** Name of the type */
    name: string;
    /** Fields/properties of the type */
    fields: DeriveFieldInfo[];
    /** Type parameters if generic */
    typeParameters: ts.TypeParameterDeclaration[];
    /** The original type node */
    type: ts.Type;
}
interface DeriveFieldInfo {
    /** Field name */
    name: string;
    /** Field type as a string */
    typeString: string;
    /** Field type */
    type: ts.Type;
    /** Is the field optional? */
    optional: boolean;
    /** Is the field readonly? */
    readonly: boolean;
}
/** Tagged template macro - transforms tagged template literals */
interface TaggedTemplateMacroDef extends MacroDefinitionBase {
    kind: "tagged-template";
    /**
     * Expand a tagged template literal
     * @param ctx - The macro context
     * @param node - The tagged template expression
     */
    expand(ctx: MacroContext, node: ts.TaggedTemplateExpression): ts.Expression;
    /**
     * Optional compile-time validation of the template
     * @param ctx - The macro context
     * @param node - The tagged template expression
     * @returns true if valid, false to abort expansion
     */
    validate?(ctx: MacroContext, node: ts.TaggedTemplateExpression): boolean;
}
/** Union of all macro types */
type MacroDefinition = ExpressionMacro | AttributeMacro | DeriveMacro | TaggedTemplateMacroDef | TypeMacro;
interface MacroRegistry {
    /** Register a new macro */
    register(macro: MacroDefinition): void;
    /** Get an expression macro by name */
    getExpression(name: string): ExpressionMacro | undefined;
    /** Get an attribute macro by name */
    getAttribute(name: string): AttributeMacro | undefined;
    /** Get a derive macro by name */
    getDerive(name: string): DeriveMacro | undefined;
    /** Get a tagged template macro by name */
    getTaggedTemplate(name: string): TaggedTemplateMacroDef | undefined;
    /** Get a type macro by name */
    getType(name: string): TypeMacro | undefined;
    /** Get all registered macros */
    getAll(): MacroDefinition[];
}
interface MacroExpansionResult {
    /** Whether expansion was successful */
    success: boolean;
    /** Expanded nodes (if successful) */
    nodes?: ts.Node[];
    /** Diagnostics from expansion */
    diagnostics: MacroDiagnostic[];
}
interface MacroDiagnostic {
    /** Severity level */
    severity: "error" | "warning" | "info";
    /** Diagnostic message */
    message: string;
    /** Source node that caused the diagnostic */
    node?: ts.Node;
    /** Optional fix suggestion */
    suggestion?: string;
}
interface TypeMacro extends MacroDefinitionBase {
    kind: "type";
    /**
     * Transform a type reference
     * @param ctx - The macro context
     * @param typeRef - The type reference node
     * @param args - Type arguments
     */
    expand(ctx: MacroContext, typeRef: ts.TypeReferenceNode, args: readonly ts.TypeNode[]): ts.TypeNode;
}

/**
 * MacroContext Implementation - Provides utilities for macro expansion
 */

declare class MacroContextImpl implements MacroContext {
    readonly program: ts.Program;
    readonly typeChecker: ts.TypeChecker;
    readonly sourceFile: ts.SourceFile;
    readonly factory: ts.NodeFactory;
    readonly transformContext: ts.TransformationContext;
    private diagnostics;
    private uniqueNameCounter;
    constructor(program: ts.Program, typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile, factory: ts.NodeFactory, transformContext: ts.TransformationContext);
    createIdentifier(name: string): ts.Identifier;
    createNumericLiteral(value: number): ts.NumericLiteral;
    createStringLiteral(value: string): ts.StringLiteral;
    createBooleanLiteral(value: boolean): ts.Expression;
    createArrayLiteral(elements: ts.Expression[]): ts.ArrayLiteralExpression;
    createObjectLiteral(properties: Array<{
        name: string;
        value: ts.Expression;
    }>): ts.ObjectLiteralExpression;
    parseExpression(code: string): ts.Expression;
    parseStatements(code: string): ts.Statement[];
    getTypeOf(node: ts.Node): ts.Type;
    getTypeString(node: ts.Node): string;
    isAssignableTo(source: ts.Type, target: ts.Type): boolean;
    getPropertiesOfType(type: ts.Type): ts.Symbol[];
    getSymbol(node: ts.Node): ts.Symbol | undefined;
    reportError(node: ts.Node, message: string): void;
    reportWarning(node: ts.Node, message: string): void;
    getDiagnostics(): MacroDiagnostic[];
    clearDiagnostics(): void;
    evaluate(node: ts.Node): ComptimeValue;
    isComptime(node: ts.Node): boolean;
    private evaluateNode;
    private evaluateBinaryExpression;
    private evaluatePrefixUnary;
    private comptimeToBoolean;
    private comptimeToString;
    generateUniqueName(prefix: string): ts.Identifier;
    comptimeValueToExpression(value: ComptimeValue): ts.Expression;
}
/**
 * Create a macro context for a given program and source file
 */
declare function createMacroContext(program: ts.Program, sourceFile: ts.SourceFile, transformContext: ts.TransformationContext): MacroContextImpl;

export { type AttributeMacro as A, type ComptimeValue as C, type DeriveMacro as D, type ExpressionMacro as E, MacroContextImpl as M, type TaggedTemplateMacroDef as T, type MacroRegistry as a, type TypeMacro as b, type MacroDefinition as c, type DeriveFieldInfo as d, type AttributeTarget as e, type DeriveTypeInfo as f, type MacroContext as g, type MacroDefinitionBase as h, type MacroDiagnostic as i, type MacroExpansionResult as j, type MacroKind as k, createMacroContext as l };
