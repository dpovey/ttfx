import { a as MacroRegistry, A as AttributeMacro, D as DeriveMacro, E as ExpressionMacro, T as TaggedTemplateMacroDef, b as TypeMacro, c as MacroDefinition, d as DeriveFieldInfo } from './context-Di7cnxkh.cjs';
export { e as AttributeTarget, C as ComptimeValue, f as DeriveTypeInfo, g as MacroContext, M as MacroContextImpl, h as MacroDefinitionBase, i as MacroDiagnostic, j as MacroExpansionResult, k as MacroKind, l as createMacroContext } from './context-Di7cnxkh.cjs';
import 'typescript';

/**
 * Macro Registry - Stores and retrieves macro definitions
 */

declare class MacroRegistryImpl implements MacroRegistry {
    private expressionMacros;
    private attributeMacros;
    private deriveMacros;
    private taggedTemplateMacros;
    private typeMacros;
    register(macro: MacroDefinition): void;
    getExpression(name: string): ExpressionMacro | undefined;
    getAttribute(name: string): AttributeMacro | undefined;
    getDerive(name: string): DeriveMacro | undefined;
    getTaggedTemplate(name: string): TaggedTemplateMacroDef | undefined;
    getType(name: string): TypeMacro | undefined;
    getAll(): MacroDefinition[];
    /** Clear all registered macros (useful for testing) */
    clear(): void;
}
/** Global macro registry singleton */
declare const globalRegistry: MacroRegistryImpl;
/** Create a new isolated registry (for testing or scoped usage) */
declare function createRegistry(): MacroRegistry;
/**
 * Define an expression macro with type inference
 */
declare function defineExpressionMacro(definition: Omit<ExpressionMacro, "kind">): ExpressionMacro;
/**
 * Define an attribute macro with type inference
 */
declare function defineAttributeMacro(definition: Omit<AttributeMacro, "kind">): AttributeMacro;
/**
 * Define a derive macro with type inference
 */
declare function defineDeriveMacro(definition: Omit<DeriveMacro, "kind">): DeriveMacro;
/**
 * Define a tagged template macro with type inference
 */
declare function defineTaggedTemplateMacro(definition: Omit<TaggedTemplateMacroDef, "kind">): TaggedTemplateMacroDef;
/**
 * Define a type macro with type inference
 */
declare function defineTypeMacro(definition: Omit<TypeMacro, "kind">): TypeMacro;
/**
 * Register multiple macros at once
 */
declare function registerMacros(registry: MacroRegistry, ...macros: MacroDefinition[]): void;

declare const comptimeMacro: ExpressionMacro;

/**
 * Derive Macros - Auto-generate common implementations
 *
 * Inspired by Rust's derive macros, these automatically generate
 * implementations for common traits/interfaces.
 *
 * Usage:
 *   @derive(Eq, Ord, Clone, Debug)
 *   interface Point {
 *     x: number;
 *     y: number;
 *   }
 */
declare const EqDerive: DeriveMacro;
declare const OrdDerive: DeriveMacro;
declare const CloneDerive: DeriveMacro;
declare const DebugDerive: DeriveMacro;
declare const HashDerive: DeriveMacro;
declare const DefaultDerive: DeriveMacro;
declare const JsonDerive: DeriveMacro;
declare const BuilderDerive: DeriveMacro;

/**
 * Register operator mappings for a type
 */
declare function registerOperators(typeName: string, mappings: Record<string, string>): void;
/**
 * Get the method name for an operator on a type.
 * Falls back to checking well-known method names by convention
 * if no explicit mapping is registered.
 */
declare function getOperatorMethod(typeName: string, operator: string): string | undefined;
declare const operatorsAttribute: AttributeMacro;
declare const opsMacro: ExpressionMacro;
declare const pipeMacro: ExpressionMacro;
declare const composeMacro: ExpressionMacro;

/**
 * Compile-Time Reflection Macros
 *
 * Provides compile-time type introspection capabilities, allowing you to
 * examine types, generate code based on type information, and more.
 *
 * Inspired by:
 * - Rust's proc_macro with derive
 * - Java/C# reflection but at compile time
 * - Zig's @typeInfo
 *
 * @example
 * ```typescript
 * @reflect
 * interface User {
 *   id: number;
 *   name: string;
 *   email: string;
 * }
 *
 * // Get metadata at compile time
 * const userMeta = typeInfo<User>();
 * // { name: "User", fields: [{ name: "id", type: "number" }, ...] }
 *
 * // Generate a validator
 * const validateUser = validator<User>();
 * ```
 */
interface TypeInfo {
    name: string;
    kind: "interface" | "class" | "type" | "enum" | "primitive" | "union" | "intersection" | "array" | "tuple" | "function";
    fields?: FieldInfo[];
    methods?: MethodInfo[];
    typeParameters?: string[];
    extends?: string[];
    modifiers?: string[];
}
interface FieldInfo {
    name: string;
    type: string;
    optional: boolean;
    readonly: boolean;
    defaultValue?: string;
}
interface MethodInfo {
    name: string;
    parameters: ParameterInfo[];
    returnType: string;
    isAsync: boolean;
    isStatic: boolean;
}
interface ParameterInfo {
    name: string;
    type: string;
    optional: boolean;
    defaultValue?: string;
}
declare const reflectAttribute: AttributeMacro;
declare const typeInfoMacro: ExpressionMacro;
declare const fieldNamesMacro: ExpressionMacro;
declare const validatorMacro: ExpressionMacro;
type ValidationResult<T> = {
    success: true;
    value: T;
} | {
    success: false;
    errors: string[];
};

interface TypeclassInfo {
    /** Name of the typeclass (e.g., "Show", "Eq") */
    name: string;
    /** Type parameter name (e.g., "A" in Show<A>) */
    typeParam: string;
    /** Methods defined by the typeclass */
    methods: TypeclassMethod[];
    /** Whether this typeclass supports auto-derivation for products */
    canDeriveProduct: boolean;
    /** Whether this typeclass supports auto-derivation for sums */
    canDeriveSum: boolean;
}
interface TypeclassMethod {
    name: string;
    /** Parameters (excluding the typeclass's type param, which is the "self") */
    params: Array<{
        name: string;
        typeString: string;
    }>;
    /** Return type as string */
    returnType: string;
    /** Whether the first parameter is the "self" type (for extension methods) */
    isSelfMethod: boolean;
}
interface InstanceInfo {
    /** Typeclass name */
    typeclassName: string;
    /** Concrete type this instance is for */
    forType: string;
    /** Variable name holding the instance */
    instanceName: string;
    /** Whether this was auto-derived */
    derived: boolean;
}
/** Global compile-time registry of typeclasses and instances */
declare const typeclassRegistry: Map<string, TypeclassInfo>;
declare const instanceRegistry: InstanceInfo[];
declare function instanceVarName(tcName: string, typeName: string): string;
/**
 * Find a registered instance for a given typeclass and type.
 */
declare function findInstance(tcName: string, typeName: string): InstanceInfo | undefined;
/**
 * Get the typeclass info for a given name.
 */
declare function getTypeclass(name: string): TypeclassInfo | undefined;
declare const typeclassAttribute: AttributeMacro;
declare const instanceAttribute: AttributeMacro;
/**
 * Built-in typeclass definitions with their derivation strategies.
 *
 * These define how to auto-derive instances for product and sum types.
 * Each entry specifies:
 * - methods: The typeclass methods to generate
 * - productDerive: How to combine field instances for product types
 * - sumDerive: How to dispatch on variants for sum types
 */
interface BuiltinTypeclassDerivation {
    /** Generate instance code for a product type */
    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string;
    /** Generate instance code for a sum type */
    deriveSum(typeName: string, discriminant: string, variants: Array<{
        tag: string;
        typeName: string;
    }>): string;
}
declare const builtinDerivations: Record<string, BuiltinTypeclassDerivation>;
/**
 * Create a derive macro for a specific typeclass that uses auto-derivation.
 */
declare function createTypeclassDeriveMacro(tcName: string): DeriveMacro;
declare const derivingAttribute: AttributeMacro;
declare const summonMacro: ExpressionMacro;
declare const extendMacro: ExpressionMacro;
/**
 * Generate code for standard typeclass interfaces.
 * Users can call this or define their own.
 */
declare function generateStandardTypeclasses(): string;

/**
 * typemacro - Compile-time macros for TypeScript
 *
 * typemacro provides compile-time metaprogramming capabilities inspired by:
 * - Rust's proc_macro system
 * - Scala 3's inline/transparent macros
 * - Zig's comptime
 *
 * @example
 * ```typescript
 * import { comptime, derive, ops } from "typemacro";
 *
 * // Compile-time evaluation
 * const factorial5 = comptime(() => {
 *   let result = 1;
 *   for (let i = 1; i <= 5; i++) result *= i;
 *   return result;
 * }); // Expands to: const factorial5 = 120;
 *
 * // Derive macros
 * @derive(Eq, Clone, Debug)
 * interface Point {
 *   x: number;
 *   y: number;
 * }
 *
 * // Operator overloading
 * @operators({ "+": "add", "-": "sub" })
 * class Vector { ... }
 * const c = ops(a + b); // Expands to: a.add(b)
 * ```
 *
 * @packageDocumentation
 */

/**
 * Marker function for compile-time evaluation.
 * The expression passed to comptime() will be evaluated during compilation.
 *
 * @param fn - A function that will be evaluated at compile time
 * @returns The computed value (replaced at compile time)
 *
 * @example
 * ```typescript
 * const result = comptime(() => 5 * 5); // Becomes: const result = 25;
 * ```
 */
declare function comptime<T>(fn: () => T): T;
/**
 * Decorator to generate implementations for a type.
 * Available derives: Eq, Ord, Clone, Debug, Hash, Default, Json, Builder
 *
 * @param derives - Names of the implementations to generate
 *
 * @example
 * ```typescript
 * @derive(Eq, Clone, Debug)
 * interface Point { x: number; y: number; }
 * // Generates: pointEq(), clonePoint(), debugPoint()
 * ```
 */
declare function derive(..._derives: string[]): ClassDecorator & PropertyDecorator;
/**
 * Decorator to define operator overloading for a class.
 *
 * @param mappings - Object mapping operators to method names
 *
 * @example
 * ```typescript
 * @operators({ "+": "add", "-": "sub", "*": "mul" })
 * class Vector { add(other: Vector): Vector { ... } }
 * ```
 */
declare function operators(_mappings: Record<string, string>): ClassDecorator;
/**
 * Transform operator expressions into method calls.
 * Used with classes that have @operators decorator.
 *
 * @param expr - Expression with operators to transform
 * @returns The result of the transformed expression
 *
 * @example
 * ```typescript
 * const c = ops(a + b * c); // Becomes: a.add(b.mul(c))
 * ```
 */
declare function ops<T>(expr: T): T;
/**
 * Pipe a value through a series of functions.
 *
 * @param value - Initial value
 * @param fns - Functions to apply in order
 * @returns The final result
 *
 * @example
 * ```typescript
 * const result = pipe(5, double, addOne, toString);
 * // Becomes: toString(addOne(double(5)))
 * ```
 */
declare function pipe<T, R>(value: T, ...fns: Array<(arg: unknown) => unknown>): R;
/**
 * Compose functions right-to-left.
 *
 * @param fns - Functions to compose
 * @returns A new function that applies all functions
 *
 * @example
 * ```typescript
 * const process = compose(toString, addOne, double);
 * // Becomes: (x) => toString(addOne(double(x)))
 * ```
 */
declare function compose<T, R>(...fns: Array<(arg: unknown) => unknown>): (value: T) => R;
/**
 * Decorator to mark an interface as a typeclass.
 * Generates companion namespace with summon/register utilities.
 *
 * @example
 * ```typescript
 * @typeclass
 * interface Show<A> {
 *   show(a: A): string;
 * }
 * ```
 */
declare function typeclass(target: any, _context?: ClassDecoratorContext): any;
/**
 * Decorator to register a typeclass instance for a specific type.
 *
 * @param typeName - The name of the type this instance is for
 *
 * @example
 * ```typescript
 * @instance("number")
 * const showNumber: Show<number> = {
 *   show: (a) => String(a),
 * };
 * ```
 */
declare function instance(_typeName: string): PropertyDecorator & ClassDecorator;
/**
 * Decorator to auto-derive typeclass instances for a type.
 * Follows Scala 3 derivation rules:
 * - Product types: derive field-by-field if all fields have instances
 * - Sum types: derive variant-by-variant if all variants have instances
 *
 * @param typeclasses - Typeclass names to derive
 *
 * @example
 * ```typescript
 * @deriving(Show, Eq, Ord)
 * interface Point {
 *   x: number;
 *   y: number;
 * }
 * // Generates: showPoint, eqPoint, ordPoint instances
 * ```
 */
declare function deriving(..._typeclasses: string[]): ClassDecorator & PropertyDecorator;
/**
 * Resolve a typeclass instance at compile time (Scala 3-like summon).
 *
 * @example
 * ```typescript
 * const showPoint = summon<Show<Point>>();
 * showPoint.show({ x: 1, y: 2 }); // "Point(x = 1, y = 2)"
 * ```
 */
declare function summon<T>(): T;
/**
 * Call extension methods on a value via typeclass instances.
 * Scala 3-like extension method syntax.
 *
 * @example
 * ```typescript
 * extend(point).show();    // Uses Show<Point>
 * extend(point).eq(other); // Uses Eq<Point>
 * ```
 */
declare function extend<T>(value: T): any;
/**
 * Assert a condition at compile time.
 * If the condition is false, a compile error is generated.
 *
 * @example
 * ```typescript
 * static_assert<Equal<typeof result, number>>();
 * ```
 */
declare function static_assert<_T extends true>(): void;
/**
 * Type-level equality check
 */
type Equal<A, B> = (<T>() => T extends A ? 1 : 2) extends <T>() => T extends B ? 1 : 2 ? true : false;
/**
 * Type-level extends check
 */
type Extends<A, B> = A extends B ? true : false;

export { AttributeMacro, BuilderDerive, type BuiltinTypeclassDerivation, CloneDerive, DebugDerive, DefaultDerive, DeriveFieldInfo, DeriveMacro, EqDerive, type Equal, ExpressionMacro, type Extends, type FieldInfo, HashDerive, type InstanceInfo, JsonDerive, MacroDefinition, MacroRegistry, type MethodInfo, OrdDerive, type ParameterInfo, TaggedTemplateMacroDef, type TypeInfo, TypeMacro, type TypeclassInfo, type TypeclassMethod, type ValidationResult, builtinDerivations, compose, composeMacro, comptime, comptimeMacro, createRegistry, createTypeclassDeriveMacro, defineAttributeMacro, defineDeriveMacro, defineExpressionMacro, defineTaggedTemplateMacro, defineTypeMacro, derive, deriving, derivingAttribute, extend, extendMacro, fieldNamesMacro, findInstance, generateStandardTypeclasses, getOperatorMethod, getTypeclass, globalRegistry, instance, instanceAttribute, instanceRegistry, instanceVarName, operators, operatorsAttribute, ops, opsMacro, pipe, pipeMacro, reflectAttribute, registerMacros, registerOperators, static_assert, summon, summonMacro, typeInfoMacro, typeclass, typeclassAttribute, typeclassRegistry, validatorMacro };
