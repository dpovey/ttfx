{"version":3,"sources":["../src/language-service/index.ts"],"sourcesContent":["/**\n * typemacro TypeScript Language Service Plugin\n *\n * Provides IDE integration for typemacro:\n * - Suppresses false-positive diagnostics from macro invocations\n * - Adds custom diagnostics for macro errors\n * - Provides completions inside @derive() decorators\n * - Shows macro expansion info on hover\n *\n * Configure in tsconfig.json:\n * {\n *   \"compilerOptions\": {\n *     \"plugins\": [{ \"name\": \"typemacro/language-service\" }]\n *   }\n * }\n */\n\nimport type * as ts from \"typescript\";\n\n/** Known expression macro names from the typemacro core */\nconst EXPRESSION_MACROS = new Set([\n  \"comptime\",\n  \"ops\",\n  \"pipe\",\n  \"compose\",\n  \"summon\",\n  \"extend\",\n  \"typeInfo\",\n  \"fieldNames\",\n  \"validator\",\n]);\n\n/** Known decorator macro names */\nconst DECORATOR_MACROS = new Set([\n  \"derive\",\n  \"operators\",\n  \"reflect\",\n  \"typeclass\",\n  \"instance\",\n  \"deriving\",\n  \"inline\",\n]);\n\n/** Known derive macro names */\nconst DERIVE_MACROS = [\n  { name: \"Eq\", description: \"Generate equality comparison function\" },\n  { name: \"Ord\", description: \"Generate ordering/comparison function\" },\n  { name: \"Clone\", description: \"Generate deep clone function\" },\n  { name: \"Debug\", description: \"Generate debug string representation\" },\n  { name: \"Hash\", description: \"Generate hash function\" },\n  { name: \"Default\", description: \"Generate default value factory\" },\n  { name: \"Json\", description: \"Generate JSON serialization/deserialization\" },\n  { name: \"Builder\", description: \"Generate builder pattern class\" },\n];\n\n/** Known tagged template macro names */\nconst TAGGED_TEMPLATE_MACROS = new Set([\n  \"sql\",\n  \"regex\",\n  \"html\",\n  \"fmt\",\n  \"json\",\n  \"raw\",\n  \"units\",\n]);\n\n/** Diagnostic codes that are commonly false positives from macro usage */\nconst SUPPRESSED_DIAGNOSTIC_CODES = new Set([\n  // \"Decorators are not valid here\" -- interfaces with @derive\n  1206,\n  // \"An expression of type 'void' cannot be tested for truthiness\" -- macro returns\n  1345,\n  // \"'XYZ' is declared but its value is never read\" -- macro-generated bindings\n  6133,\n  // \"Cannot find name 'XYZ'\" -- references to macro-generated identifiers\n  2304,\n]);\n\nfunction init(modules: { typescript: typeof ts }) {\n  const tsModule = modules.typescript;\n\n  function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n    const log = (msg: string) => {\n      info.project.projectService.logger.info(`[typemacro] ${msg}`);\n    };\n\n    log(\"Language service plugin initialized\");\n\n    const proxy = Object.create(null) as ts.LanguageService;\n    const oldLS = info.languageService;\n\n    // Create pass-through proxy for all methods\n    for (const k of Object.keys(oldLS)) {\n      const prop = (oldLS as unknown as Record<string, unknown>)[k];\n      if (typeof prop === \"function\") {\n        (proxy as unknown as Record<string, unknown>)[k] = (\n          ...args: unknown[]\n        ): unknown => {\n          return (prop as Function).apply(oldLS, args);\n        };\n      }\n    }\n\n    // -----------------------------------------------------------------------\n    // Override: getSemanticDiagnostics\n    // Suppress false positives from macro invocations\n    // -----------------------------------------------------------------------\n    proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n      const diagnostics = oldLS.getSemanticDiagnostics(fileName);\n      const program = oldLS.getProgram();\n      if (!program) return diagnostics;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return diagnostics;\n\n      return diagnostics.filter((diag) => {\n        // Always keep diagnostics that aren't from our suppression list\n        if (!SUPPRESSED_DIAGNOSTIC_CODES.has(diag.code)) return true;\n\n        // Check if the diagnostic is near a macro invocation\n        if (diag.start === undefined) return true;\n\n        const node = findNodeAtPosition(\n          tsModule,\n          sourceFile,\n          diag.start,\n        );\n        if (!node) return true;\n\n        // Suppress \"Decorators are not valid here\" on macro decorators\n        if (diag.code === 1206) {\n          const decorator = findAncestor(tsModule, node, tsModule.isDecorator);\n          if (decorator && tsModule.isDecorator(decorator)) {\n            const name = getDecoratorName(tsModule, decorator as ts.Decorator);\n            if (name && DECORATOR_MACROS.has(name)) {\n              log(`Suppressed diagnostic ${diag.code} for @${name}`);\n              return false;\n            }\n          }\n        }\n\n        // Suppress \"Cannot find name\" for macro-generated identifiers\n        if (diag.code === 2304) {\n          if (isNearMacroInvocation(tsModule, sourceFile, node)) {\n            log(\n              `Suppressed diagnostic ${diag.code} near macro invocation`,\n            );\n            return false;\n          }\n        }\n\n        return true;\n      });\n    };\n\n    // -----------------------------------------------------------------------\n    // Override: getCompletionsAtPosition\n    // Provide completions inside @derive() and other macro contexts\n    // -----------------------------------------------------------------------\n    proxy.getCompletionsAtPosition = (\n      fileName: string,\n      position: number,\n      options: ts.GetCompletionsAtPositionOptions | undefined,\n    ): ts.WithMetadata<ts.CompletionInfo> | undefined => {\n      const prior = oldLS.getCompletionsAtPosition(\n        fileName,\n        position,\n        options,\n      );\n\n      const program = oldLS.getProgram();\n      if (!program) return prior;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return prior;\n\n      const node = findNodeAtPosition(tsModule, sourceFile, position);\n      if (!node) return prior;\n\n      // Check if we're inside a @derive() call\n      const deriveContext = findDeriveContext(tsModule, node);\n      if (deriveContext) {\n        const deriveEntries: ts.CompletionEntry[] = DERIVE_MACROS.map(\n          (macro) => ({\n            name: macro.name,\n            kind: tsModule.ScriptElementKind.constElement,\n            kindModifiers: \"\",\n            sortText: `0${macro.name}`,\n            labelDetails: {\n              description: macro.description,\n            },\n          }),\n        );\n\n        if (prior) {\n          return {\n            ...prior,\n            entries: [...deriveEntries, ...prior.entries],\n          };\n        }\n\n        return {\n          isGlobalCompletion: false,\n          isMemberCompletion: false,\n          isNewIdentifierLocation: false,\n          entries: deriveEntries,\n        };\n      }\n\n      return prior;\n    };\n\n    // -----------------------------------------------------------------------\n    // Override: getQuickInfoAtPosition\n    // Show macro info on hover\n    // -----------------------------------------------------------------------\n    proxy.getQuickInfoAtPosition = (\n      fileName: string,\n      position: number,\n    ): ts.QuickInfo | undefined => {\n      const prior = oldLS.getQuickInfoAtPosition(fileName, position);\n\n      const program = oldLS.getProgram();\n      if (!program) return prior;\n\n      const sourceFile = program.getSourceFile(fileName);\n      if (!sourceFile) return prior;\n\n      const node = findNodeAtPosition(tsModule, sourceFile, position);\n      if (!node) return prior;\n\n      if (tsModule.isIdentifier(node)) {\n        const name = node.text;\n\n        if (EXPRESSION_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro expression macro) ${name}`,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This call is expanded at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n\n        if (DECORATOR_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro decorator macro) @${name}`,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This decorator is processed at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n\n        if (TAGGED_TEMPLATE_MACROS.has(name)) {\n          return {\n            kind: tsModule.ScriptElementKind.functionElement,\n            kindModifiers: \"typemacro\",\n            textSpan: {\n              start: node.getStart(sourceFile),\n              length: node.getWidth(sourceFile),\n            },\n            displayParts: [\n              {\n                text: `(typemacro tagged template macro) ${name}\\`...\\``,\n                kind: \"text\",\n              },\n            ],\n            documentation: [\n              {\n                text: \"This tagged template is processed at compile time by the typemacro transformer.\",\n                kind: \"text\",\n              },\n            ],\n          };\n        }\n      }\n\n      return prior;\n    };\n\n    return proxy;\n  }\n\n  return { create };\n}\n\n// ---------------------------------------------------------------------------\n// AST Utility Functions\n// ---------------------------------------------------------------------------\n\nfunction findNodeAtPosition(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  position: number,\n): ts.Node | undefined {\n  function find(node: ts.Node): ts.Node | undefined {\n    if (position >= node.getStart(sourceFile) && position < node.getEnd()) {\n      return ts.forEachChild(node, find) ?? node;\n    }\n    return undefined;\n  }\n  return find(sourceFile);\n}\n\nfunction findAncestor(\n  ts: typeof import(\"typescript\"),\n  node: ts.Node,\n  predicate: (node: ts.Node) => boolean,\n): ts.Node | undefined {\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (predicate(current)) return current;\n    current = current.parent;\n  }\n  return undefined;\n}\n\nfunction getDecoratorName(\n  ts: typeof import(\"typescript\"),\n  decorator: ts.Decorator,\n): string | undefined {\n  const expr = decorator.expression;\n  if (ts.isIdentifier(expr)) return expr.text;\n  if (ts.isCallExpression(expr) && ts.isIdentifier(expr.expression)) {\n    return expr.expression.text;\n  }\n  return undefined;\n}\n\nfunction findDeriveContext(\n  ts: typeof import(\"typescript\"),\n  node: ts.Node,\n): boolean {\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (ts.isCallExpression(current)) {\n      if (\n        ts.isIdentifier(current.expression) &&\n        current.expression.text === \"derive\"\n      ) {\n        return true;\n      }\n    }\n    if (ts.isDecorator(current)) {\n      const name = getDecoratorName(ts, current);\n      if (name === \"derive\") return true;\n    }\n    current = current.parent;\n  }\n  return false;\n}\n\nfunction isNearMacroInvocation(\n  ts: typeof import(\"typescript\"),\n  sourceFile: ts.SourceFile,\n  node: ts.Node,\n): boolean {\n  // Walk up to find if this node is inside or adjacent to a macro call\n  let current: ts.Node | undefined = node;\n  while (current) {\n    if (ts.isCallExpression(current)) {\n      if (ts.isIdentifier(current.expression)) {\n        if (EXPRESSION_MACROS.has(current.expression.text)) return true;\n      }\n    }\n    if (ts.isTaggedTemplateExpression(current)) {\n      if (ts.isIdentifier(current.tag)) {\n        if (TAGGED_TEMPLATE_MACROS.has(current.tag.text)) return true;\n      }\n    }\n    // Check siblings in the same block for macro-generated code\n    if (ts.isBlock(current) || ts.isSourceFile(current)) {\n      for (const stmt of current.statements ?? []) {\n        if (ts.isExpressionStatement(stmt) && ts.isCallExpression(stmt.expression)) {\n          if (ts.isIdentifier(stmt.expression.expression)) {\n            if (EXPRESSION_MACROS.has(stmt.expression.expression.text))\n              return true;\n          }\n        }\n      }\n    }\n    current = current.parent;\n  }\n  return false;\n}\n\n// TS language service plugins use CommonJS module.exports = init pattern.\n// tsup handles the CJS/ESM interop, so we use default export here.\nexport default init;\n"],"mappings":"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","names":[]}