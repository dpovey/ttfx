"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/integrations/webpack.ts
var webpack_exports = {};
__export(webpack_exports, {
  default: () => webpack_default
});
module.exports = __toCommonJS(webpack_exports);

// src/integrations/unplugin.ts
var ts7 = __toESM(require("typescript"), 1);
var path = __toESM(require("path"), 1);
var import_unplugin = require("unplugin");

// src/transforms/macro-transformer.ts
var ts6 = __toESM(require("typescript"), 1);

// src/core/context.ts
var ts = __toESM(require("typescript"), 1);
var MacroContextImpl = class {
  constructor(program, typeChecker, sourceFile, factory, transformContext) {
    this.program = program;
    this.typeChecker = typeChecker;
    this.sourceFile = sourceFile;
    this.factory = factory;
    this.transformContext = transformContext;
  }
  diagnostics = [];
  uniqueNameCounter = 0;
  // -------------------------------------------------------------------------
  // Node Creation Utilities
  // -------------------------------------------------------------------------
  createIdentifier(name) {
    return this.factory.createIdentifier(name);
  }
  createNumericLiteral(value) {
    return this.factory.createNumericLiteral(value);
  }
  createStringLiteral(value) {
    return this.factory.createStringLiteral(value);
  }
  createBooleanLiteral(value) {
    return value ? this.factory.createTrue() : this.factory.createFalse();
  }
  createArrayLiteral(elements) {
    return this.factory.createArrayLiteralExpression(elements);
  }
  createObjectLiteral(properties) {
    const propAssignments = properties.map(
      ({ name, value }) => this.factory.createPropertyAssignment(
        this.factory.createIdentifier(name),
        value
      )
    );
    return this.factory.createObjectLiteralExpression(propAssignments, true);
  }
  parseExpression(code) {
    const tempSource = ts.createSourceFile(
      "__macro_temp__.ts",
      `const __expr__ = ${code};`,
      ts.ScriptTarget.Latest,
      true,
      ts.ScriptKind.TS
    );
    const statement = tempSource.statements[0];
    if (ts.isVariableStatement(statement)) {
      const declaration = statement.declarationList.declarations[0];
      if (declaration.initializer) {
        return declaration.initializer;
      }
    }
    throw new Error(`Failed to parse expression: ${code}`);
  }
  parseStatements(code) {
    const tempSource = ts.createSourceFile(
      "__macro_temp__.ts",
      code,
      ts.ScriptTarget.Latest,
      true,
      ts.ScriptKind.TS
    );
    return Array.from(tempSource.statements);
  }
  // -------------------------------------------------------------------------
  // Type Utilities
  // -------------------------------------------------------------------------
  getTypeOf(node) {
    return this.typeChecker.getTypeAtLocation(node);
  }
  getTypeString(node) {
    const type = this.getTypeOf(node);
    return this.typeChecker.typeToString(type);
  }
  isAssignableTo(source, target) {
    return this.typeChecker.isTypeAssignableTo(source, target);
  }
  getPropertiesOfType(type) {
    return this.typeChecker.getPropertiesOfType(type);
  }
  getSymbol(node) {
    return this.typeChecker.getSymbolAtLocation(node);
  }
  // -------------------------------------------------------------------------
  // Diagnostics
  // -------------------------------------------------------------------------
  reportError(node, message) {
    this.diagnostics.push({
      severity: "error",
      message,
      node
    });
  }
  reportWarning(node, message) {
    this.diagnostics.push({
      severity: "warning",
      message,
      node
    });
  }
  getDiagnostics() {
    return [...this.diagnostics];
  }
  clearDiagnostics() {
    this.diagnostics = [];
  }
  // -------------------------------------------------------------------------
  // Compile-Time Evaluation
  // -------------------------------------------------------------------------
  evaluate(node) {
    return this.evaluateNode(node);
  }
  isComptime(node) {
    if (ts.isLiteralExpression(node)) {
      return true;
    }
    if (ts.isArrayLiteralExpression(node)) {
      return node.elements.every((e) => this.isComptime(e));
    }
    if (ts.isObjectLiteralExpression(node)) {
      return node.properties.every((p) => {
        if (ts.isPropertyAssignment(p)) {
          return this.isComptime(p.initializer);
        }
        return false;
      });
    }
    if (ts.isBinaryExpression(node)) {
      return this.isComptime(node.left) && this.isComptime(node.right);
    }
    if (ts.isPrefixUnaryExpression(node) || ts.isPostfixUnaryExpression(node)) {
      return this.isComptime(node.operand);
    }
    if (ts.isConditionalExpression(node)) {
      return this.isComptime(node.condition) && this.isComptime(node.whenTrue) && this.isComptime(node.whenFalse);
    }
    if (ts.isParenthesizedExpression(node)) {
      return this.isComptime(node.expression);
    }
    if (ts.isIdentifier(node)) {
      const symbol = this.typeChecker.getSymbolAtLocation(node);
      if (symbol) {
        const declarations = symbol.getDeclarations();
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          if (ts.isVariableDeclaration(decl)) {
            const parent = decl.parent;
            if (ts.isVariableDeclarationList(parent)) {
              if (parent.flags & ts.NodeFlags.Const) {
                return decl.initializer ? this.isComptime(decl.initializer) : false;
              }
            }
          }
        }
      }
    }
    return false;
  }
  evaluateNode(node) {
    if (ts.isNumericLiteral(node)) {
      return { kind: "number", value: parseFloat(node.text) };
    }
    if (ts.isStringLiteral(node)) {
      return { kind: "string", value: node.text };
    }
    if (node.kind === ts.SyntaxKind.TrueKeyword) {
      return { kind: "boolean", value: true };
    }
    if (node.kind === ts.SyntaxKind.FalseKeyword) {
      return { kind: "boolean", value: false };
    }
    if (node.kind === ts.SyntaxKind.NullKeyword) {
      return { kind: "null" };
    }
    if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
      return { kind: "undefined" };
    }
    if (ts.isArrayLiteralExpression(node)) {
      const elements = node.elements.map((e) => this.evaluateNode(e));
      const hasError = elements.find((e) => e.kind === "error");
      if (hasError) return hasError;
      return { kind: "array", elements };
    }
    if (ts.isObjectLiteralExpression(node)) {
      const properties = /* @__PURE__ */ new Map();
      for (const prop of node.properties) {
        if (ts.isPropertyAssignment(prop)) {
          const name = ts.isIdentifier(prop.name) ? prop.name.text : ts.isStringLiteral(prop.name) ? prop.name.text : null;
          if (name) {
            const value = this.evaluateNode(prop.initializer);
            if (value.kind === "error") return value;
            properties.set(name, value);
          }
        }
      }
      return { kind: "object", properties };
    }
    if (ts.isParenthesizedExpression(node)) {
      return this.evaluateNode(node.expression);
    }
    if (ts.isBinaryExpression(node)) {
      return this.evaluateBinaryExpression(node);
    }
    if (ts.isPrefixUnaryExpression(node)) {
      return this.evaluatePrefixUnary(node);
    }
    if (ts.isConditionalExpression(node)) {
      const condition = this.evaluateNode(node.condition);
      if (condition.kind === "error") return condition;
      const condValue = this.comptimeToBoolean(condition);
      if (condValue === null) {
        return { kind: "error", message: "Cannot convert to boolean" };
      }
      return condValue ? this.evaluateNode(node.whenTrue) : this.evaluateNode(node.whenFalse);
    }
    if (ts.isTemplateExpression(node)) {
      let result = node.head.text;
      for (const span of node.templateSpans) {
        const value = this.evaluateNode(span.expression);
        if (value.kind === "error") return value;
        result += this.comptimeToString(value) + span.literal.text;
      }
      return { kind: "string", value: result };
    }
    if (ts.isNoSubstitutionTemplateLiteral(node)) {
      return { kind: "string", value: node.text };
    }
    if (ts.isArrowFunction(node)) {
      return {
        kind: "function",
        fn: (..._args) => {
          if (ts.isBlock(node.body)) {
            return {
              kind: "error",
              message: "Block body arrow functions not yet supported"
            };
          }
          return this.evaluateNode(node.body);
        }
      };
    }
    if (ts.isCallExpression(node)) {
      const fn = this.evaluateNode(node.expression);
      if (fn.kind === "function") {
        const args = node.arguments.map((a) => this.evaluateNode(a));
        const errorArg = args.find((a) => a.kind === "error");
        if (errorArg) return errorArg;
        return fn.fn(...args);
      }
    }
    return {
      kind: "error",
      message: `Cannot evaluate node of kind ${ts.SyntaxKind[node.kind]} at compile time`
    };
  }
  evaluateBinaryExpression(node) {
    const left = this.evaluateNode(node.left);
    const right = this.evaluateNode(node.right);
    if (left.kind === "error") return left;
    if (right.kind === "error") return right;
    const op = node.operatorToken.kind;
    if (left.kind === "number" && right.kind === "number") {
      switch (op) {
        case ts.SyntaxKind.PlusToken:
          return { kind: "number", value: left.value + right.value };
        case ts.SyntaxKind.MinusToken:
          return { kind: "number", value: left.value - right.value };
        case ts.SyntaxKind.AsteriskToken:
          return { kind: "number", value: left.value * right.value };
        case ts.SyntaxKind.SlashToken:
          return { kind: "number", value: left.value / right.value };
        case ts.SyntaxKind.PercentToken:
          return { kind: "number", value: left.value % right.value };
        case ts.SyntaxKind.AsteriskAsteriskToken:
          return { kind: "number", value: left.value ** right.value };
        case ts.SyntaxKind.LessThanToken:
          return { kind: "boolean", value: left.value < right.value };
        case ts.SyntaxKind.LessThanEqualsToken:
          return { kind: "boolean", value: left.value <= right.value };
        case ts.SyntaxKind.GreaterThanToken:
          return { kind: "boolean", value: left.value > right.value };
        case ts.SyntaxKind.GreaterThanEqualsToken:
          return { kind: "boolean", value: left.value >= right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
        case ts.SyntaxKind.AmpersandToken:
          return { kind: "number", value: left.value & right.value };
        case ts.SyntaxKind.BarToken:
          return { kind: "number", value: left.value | right.value };
        case ts.SyntaxKind.CaretToken:
          return { kind: "number", value: left.value ^ right.value };
        case ts.SyntaxKind.LessThanLessThanToken:
          return { kind: "number", value: left.value << right.value };
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
          return { kind: "number", value: left.value >> right.value };
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
          return { kind: "number", value: left.value >>> right.value };
      }
    }
    if (left.kind === "string" && right.kind === "string") {
      switch (op) {
        case ts.SyntaxKind.PlusToken:
          return { kind: "string", value: left.value + right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
        case ts.SyntaxKind.LessThanToken:
          return { kind: "boolean", value: left.value < right.value };
        case ts.SyntaxKind.GreaterThanToken:
          return { kind: "boolean", value: left.value > right.value };
      }
    }
    if (left.kind === "string" && right.kind === "number" || left.kind === "number" && right.kind === "string") {
      if (op === ts.SyntaxKind.PlusToken) {
        return {
          kind: "string",
          value: this.comptimeToString(left) + this.comptimeToString(right)
        };
      }
    }
    if (left.kind === "boolean" && right.kind === "boolean") {
      switch (op) {
        case ts.SyntaxKind.AmpersandAmpersandToken:
          return { kind: "boolean", value: left.value && right.value };
        case ts.SyntaxKind.BarBarToken:
          return { kind: "boolean", value: left.value || right.value };
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
          return { kind: "boolean", value: left.value === right.value };
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          return { kind: "boolean", value: left.value !== right.value };
      }
    }
    return {
      kind: "error",
      message: `Cannot apply operator ${ts.SyntaxKind[op]} to ${left.kind} and ${right.kind}`
    };
  }
  evaluatePrefixUnary(node) {
    const operand = this.evaluateNode(node.operand);
    if (operand.kind === "error") return operand;
    switch (node.operator) {
      case ts.SyntaxKind.MinusToken:
        if (operand.kind === "number") {
          return { kind: "number", value: -operand.value };
        }
        break;
      case ts.SyntaxKind.PlusToken:
        if (operand.kind === "number") {
          return { kind: "number", value: +operand.value };
        }
        break;
      case ts.SyntaxKind.ExclamationToken:
        const boolValue = this.comptimeToBoolean(operand);
        if (boolValue !== null) {
          return { kind: "boolean", value: !boolValue };
        }
        break;
      case ts.SyntaxKind.TildeToken:
        if (operand.kind === "number") {
          return { kind: "number", value: ~operand.value };
        }
        break;
    }
    return {
      kind: "error",
      message: `Cannot apply unary ${ts.SyntaxKind[node.operator]} to ${operand.kind}`
    };
  }
  comptimeToBoolean(value) {
    switch (value.kind) {
      case "boolean":
        return value.value;
      case "number":
        return value.value !== 0;
      case "string":
        return value.value !== "";
      case "null":
      case "undefined":
        return false;
      case "array":
      case "object":
      case "function":
        return true;
      default:
        return null;
    }
  }
  comptimeToString(value) {
    switch (value.kind) {
      case "string":
        return value.value;
      case "number":
        return String(value.value);
      case "boolean":
        return String(value.value);
      case "null":
        return "null";
      case "undefined":
        return "undefined";
      case "array":
        return `[${value.elements.map((e) => this.comptimeToString(e)).join(", ")}]`;
      case "object":
        const entries = Array.from(value.properties.entries()).map(([k, v]) => `${k}: ${this.comptimeToString(v)}`).join(", ");
        return `{ ${entries} }`;
      case "function":
        return "[Function]";
      case "type":
        return "[Type]";
      case "error":
        return `[Error: ${value.message}]`;
    }
  }
  // -------------------------------------------------------------------------
  // Unique Name Generation
  // -------------------------------------------------------------------------
  generateUniqueName(prefix) {
    const name = `__typemacro_${prefix}_${this.uniqueNameCounter++}__`;
    return this.factory.createIdentifier(name);
  }
  // -------------------------------------------------------------------------
  // Helper: Convert ComptimeValue to TypeScript Expression
  // -------------------------------------------------------------------------
  comptimeValueToExpression(value) {
    switch (value.kind) {
      case "number":
        return this.createNumericLiteral(value.value);
      case "string":
        return this.createStringLiteral(value.value);
      case "boolean":
        return this.createBooleanLiteral(value.value);
      case "null":
        return this.factory.createNull();
      case "undefined":
        return this.factory.createIdentifier("undefined");
      case "array":
        return this.createArrayLiteral(
          value.elements.map((e) => this.comptimeValueToExpression(e))
        );
      case "object":
        const props = [];
        value.properties.forEach((v, k) => {
          props.push({ name: k, value: this.comptimeValueToExpression(v) });
        });
        return this.createObjectLiteral(props);
      case "error":
        throw new Error(
          `Cannot convert error value to expression: ${value.message}`
        );
      default:
        throw new Error(`Cannot convert ${value.kind} to expression`);
    }
  }
};
function createMacroContext(program, sourceFile, transformContext) {
  return new MacroContextImpl(
    program,
    program.getTypeChecker(),
    sourceFile,
    transformContext.factory,
    transformContext
  );
}

// src/core/registry.ts
var MacroRegistryImpl = class {
  expressionMacros = /* @__PURE__ */ new Map();
  attributeMacros = /* @__PURE__ */ new Map();
  deriveMacros = /* @__PURE__ */ new Map();
  taggedTemplateMacros = /* @__PURE__ */ new Map();
  typeMacros = /* @__PURE__ */ new Map();
  register(macro) {
    switch (macro.kind) {
      case "expression":
        if (this.expressionMacros.has(macro.name)) {
          throw new Error(
            `Expression macro '${macro.name}' is already registered`
          );
        }
        this.expressionMacros.set(macro.name, macro);
        break;
      case "attribute":
        if (this.attributeMacros.has(macro.name)) {
          throw new Error(
            `Attribute macro '${macro.name}' is already registered`
          );
        }
        this.attributeMacros.set(macro.name, macro);
        break;
      case "derive":
        if (this.deriveMacros.has(macro.name)) {
          throw new Error(`Derive macro '${macro.name}' is already registered`);
        }
        this.deriveMacros.set(macro.name, macro);
        break;
      case "tagged-template":
        if (this.taggedTemplateMacros.has(macro.name)) {
          throw new Error(
            `Tagged template macro '${macro.name}' is already registered`
          );
        }
        this.taggedTemplateMacros.set(macro.name, macro);
        break;
      case "type":
        if (this.typeMacros.has(macro.name)) {
          throw new Error(
            `Type macro '${macro.name}' is already registered`
          );
        }
        this.typeMacros.set(macro.name, macro);
        break;
      default:
        throw new Error(
          `Unknown macro kind: ${macro.kind}`
        );
    }
  }
  getExpression(name) {
    return this.expressionMacros.get(name);
  }
  getAttribute(name) {
    return this.attributeMacros.get(name);
  }
  getDerive(name) {
    return this.deriveMacros.get(name);
  }
  getTaggedTemplate(name) {
    return this.taggedTemplateMacros.get(name);
  }
  getType(name) {
    return this.typeMacros.get(name);
  }
  getAll() {
    return [
      ...this.expressionMacros.values(),
      ...this.attributeMacros.values(),
      ...this.deriveMacros.values(),
      ...this.taggedTemplateMacros.values(),
      ...this.typeMacros.values()
    ];
  }
  /** Clear all registered macros (useful for testing) */
  clear() {
    this.expressionMacros.clear();
    this.attributeMacros.clear();
    this.deriveMacros.clear();
    this.taggedTemplateMacros.clear();
    this.typeMacros.clear();
  }
};
var globalRegistry = new MacroRegistryImpl();
function defineExpressionMacro(definition) {
  return {
    ...definition,
    kind: "expression"
  };
}
function defineAttributeMacro(definition) {
  return {
    ...definition,
    kind: "attribute"
  };
}
function defineDeriveMacro(definition) {
  return {
    ...definition,
    kind: "derive"
  };
}

// src/macros/comptime.ts
var ts2 = __toESM(require("typescript"), 1);
var vm = __toESM(require("vm"), 1);
var COMPTIME_TIMEOUT_MS = 5e3;
var comptimeMacro = defineExpressionMacro({
  name: "comptime",
  description: "Evaluate an expression at compile time",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(callExpr, "comptime expects exactly one argument");
      return callExpr;
    }
    const arg = args[0];
    if (ts2.isArrowFunction(arg) || ts2.isFunctionExpression(arg)) {
      return evaluateViaVm(ctx, arg, callExpr);
    }
    const result = ctx.evaluate(arg);
    if (result.kind === "error") {
      return evaluateViaVm(ctx, arg, callExpr);
    }
    return ctx.comptimeValueToExpression(result);
  }
});
function evaluateViaVm(ctx, node, callExpr) {
  const sourceText = node.getText ? node.getText() : nodeToString(node, ctx);
  const isFunction = ts2.isArrowFunction(node) || ts2.isFunctionExpression(node);
  const codeToEval = isFunction ? `(${sourceText})()` : `(${sourceText})`;
  const { outputText, diagnostics } = ts2.transpileModule(codeToEval, {
    compilerOptions: {
      target: ts2.ScriptTarget.ES2022,
      module: ts2.ModuleKind.CommonJS,
      strict: false,
      removeComments: true
    },
    reportDiagnostics: true
  });
  if (diagnostics && diagnostics.length > 0) {
    const messages = diagnostics.map(
      (d) => ts2.flattenDiagnosticMessageText(d.messageText, "\n")
    );
    ctx.reportError(
      callExpr,
      `Cannot transpile comptime expression: ${messages.join("; ")}`
    );
    return callExpr;
  }
  const cleanedJs = outputText.replace(/^"use strict";\s*/, "").replace(/\s*Object\.defineProperty\(exports.*\n?/g, "").replace(/\s*exports\.\S+ = void 0;\s*/g, "");
  try {
    const sandbox = createComptimeSandbox();
    const context = vm.createContext(sandbox);
    const result = vm.runInContext(cleanedJs, context, {
      timeout: COMPTIME_TIMEOUT_MS,
      filename: "comptime-eval.js"
    });
    return jsValueToExpression(ctx, result, callExpr);
  } catch (error) {
    ctx.reportError(callExpr, formatComptimeError(error, sourceText, ctx, callExpr));
    return callExpr;
  }
}
function formatComptimeError(error, sourceText, ctx, callExpr) {
  const rawMessage = error instanceof Error ? error.message : String(error);
  const sourceFile = ctx.sourceFile;
  const start = callExpr.getStart(sourceFile);
  const { line, character } = sourceFile.getLineAndCharacterOfPosition(start);
  const location = `${sourceFile.fileName}:${line + 1}:${character + 1}`;
  const maxSnippetLen = 200;
  const snippet = sourceText.length > maxSnippetLen ? sourceText.slice(0, maxSnippetLen) + "..." : sourceText;
  let hint = "";
  if (rawMessage.includes("Script execution timed out")) {
    hint = `
  Hint: The expression took longer than ${COMPTIME_TIMEOUT_MS}ms to evaluate. Check for infinite loops or very expensive computations.`;
  } else if (rawMessage.includes("is not defined") || rawMessage.includes("is not a function")) {
    const match = rawMessage.match(/(\w+) is not (defined|a function)/);
    const name = match?.[1] ?? "unknown";
    hint = `
  Hint: '${name}' is not available in the comptime sandbox. Only safe built-ins (Math, JSON, Array, etc.) are accessible. File I/O, network, and process access are intentionally blocked.`;
  } else if (rawMessage.includes("Cannot read properties of")) {
    hint = "\n  Hint: A null/undefined value was accessed. Check that all variables are properly initialized.";
  }
  return `Compile-time evaluation failed at ${location}
  Source: comptime(${snippet})
  Error: ${rawMessage}${hint}`;
}
function createComptimeSandbox() {
  return {
    // Safe built-ins
    Math,
    Number,
    String,
    Boolean,
    Array,
    Object,
    Map,
    Set,
    WeakMap,
    WeakSet,
    JSON,
    Date,
    RegExp,
    Error,
    TypeError,
    RangeError,
    SyntaxError,
    parseInt,
    parseFloat,
    isNaN,
    isFinite,
    NaN: NaN,
    Infinity: Infinity,
    undefined: void 0,
    // Console for debugging (output goes to build log)
    console: {
      log: (...args) => console.log("[comptime]", ...args),
      warn: (...args) => console.warn("[comptime]", ...args),
      error: (...args) => console.error("[comptime]", ...args)
    }
  };
}
function jsValueToExpression(ctx, value, errorNode) {
  if (value === null) {
    return ctx.factory.createNull();
  }
  if (value === void 0) {
    return ctx.factory.createIdentifier("undefined");
  }
  if (typeof value === "number") {
    if (value < 0) {
      return ctx.factory.createPrefixUnaryExpression(
        ts2.SyntaxKind.MinusToken,
        ctx.factory.createNumericLiteral(Math.abs(value))
      );
    }
    if (!isFinite(value)) {
      return ctx.factory.createIdentifier(value > 0 ? "Infinity" : "-Infinity");
    }
    if (isNaN(value)) {
      return ctx.factory.createIdentifier("NaN");
    }
    return ctx.factory.createNumericLiteral(value);
  }
  if (typeof value === "string") {
    return ctx.factory.createStringLiteral(value);
  }
  if (typeof value === "boolean") {
    return value ? ctx.factory.createTrue() : ctx.factory.createFalse();
  }
  if (typeof value === "bigint") {
    return ctx.factory.createBigIntLiteral(value.toString());
  }
  if (Array.isArray(value)) {
    const elements = value.map((el) => jsValueToExpression(ctx, el, errorNode));
    return ctx.factory.createArrayLiteralExpression(elements);
  }
  if (value instanceof RegExp) {
    return ctx.factory.createCallExpression(
      ctx.factory.createIdentifier("RegExp"),
      void 0,
      [
        ctx.factory.createStringLiteral(value.source),
        ctx.factory.createStringLiteral(value.flags)
      ]
    );
  }
  if (typeof value === "object") {
    const properties = [];
    for (const [key, val] of Object.entries(value)) {
      properties.push(
        ctx.factory.createPropertyAssignment(
          /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? ctx.factory.createIdentifier(key) : ctx.factory.createStringLiteral(key),
          jsValueToExpression(ctx, val, errorNode)
        )
      );
    }
    return ctx.factory.createObjectLiteralExpression(properties, true);
  }
  ctx.reportError(
    errorNode,
    `Cannot serialize comptime result of type ${typeof value} to AST`
  );
  return ctx.factory.createIdentifier("undefined");
}
function nodeToString(node, ctx) {
  const printer = ts2.createPrinter({ newLine: ts2.NewLineKind.LineFeed });
  return printer.printNode(ts2.EmitHint.Expression, node, ctx.sourceFile);
}
globalRegistry.register(comptimeMacro);

// src/macros/derive.ts
var EqDerive = defineDeriveMacro({
  name: "Eq",
  description: "Generate an equality comparison function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `${uncapitalize(name)}Eq`;
    const comparisons = fields.map(
      (field) => `a.${field.name} === b.${field.name}`
    );
    const body = comparisons.length > 0 ? comparisons.join(" && ") : "true";
    const code = `
export function ${fnName}(a: ${name}, b: ${name}): boolean {
  return ${body};
}
`;
    return ctx.parseStatements(code);
  }
});
var OrdDerive = defineDeriveMacro({
  name: "Ord",
  description: "Generate a comparison function for ordering",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `${uncapitalize(name)}Compare`;
    const comparisons = fields.map((field) => {
      return `
  if (a.${field.name} < b.${field.name}) return -1;
  if (a.${field.name} > b.${field.name}) return 1;`;
    }).join("\n");
    const code = `
export function ${fnName}(a: ${name}, b: ${name}): -1 | 0 | 1 {
${comparisons}
  return 0;
}
`;
    return ctx.parseStatements(code);
  }
});
var CloneDerive = defineDeriveMacro({
  name: "Clone",
  description: "Generate a deep clone function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `clone${name}`;
    const copies = fields.map((field) => {
      return `    ${field.name}: value.${field.name}`;
    });
    const code = `
export function ${fnName}(value: ${name}): ${name} {
  return {
${copies.join(",\n")}
  };
}
`;
    return ctx.parseStatements(code);
  }
});
var DebugDerive = defineDeriveMacro({
  name: "Debug",
  description: "Generate a debug string representation function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `debug${name}`;
    const fieldStrs = fields.map(
      (field) => `\${JSON.stringify(value.${field.name})}`
    );
    const fieldNames = fields.map((f) => f.name);
    const pairs = fieldNames.map((n, i) => `${n}: ${fieldStrs[i]}`);
    const code = `
export function ${fnName}(value: ${name}): string {
  return \`${name} { ${pairs.join(", ")} }\`;
}
`;
    return ctx.parseStatements(code);
  }
});
var HashDerive = defineDeriveMacro({
  name: "Hash",
  description: "Generate a hash function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `hash${name}`;
    const hashCode = fields.map((field) => {
      const fieldType = getBaseType(field);
      if (fieldType === "number") {
        return `  hash = ((hash << 5) + hash) + (value.${field.name} | 0);`;
      } else if (fieldType === "string") {
        return `  for (let i = 0; i < value.${field.name}.length; i++) {
    hash = ((hash << 5) + hash) + value.${field.name}.charCodeAt(i);
  }`;
      } else if (fieldType === "boolean") {
        return `  hash = ((hash << 5) + hash) + (value.${field.name} ? 1 : 0);`;
      }
      return `  hash = ((hash << 5) + hash) + String(value.${field.name}).length;`;
    }).join("\n");
    const code = `
export function ${fnName}(value: ${name}): number {
  let hash = 5381;
${hashCode}
  return hash >>> 0;
}
`;
    return ctx.parseStatements(code);
  }
});
var DefaultDerive = defineDeriveMacro({
  name: "Default",
  description: "Generate a default value factory function",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const fnName = `default${name}`;
    const defaults = fields.map((field) => {
      const defaultValue = getDefaultForType(field);
      return `    ${field.name}: ${defaultValue}`;
    });
    const code = `
export function ${fnName}(): ${name} {
  return {
${defaults.join(",\n")}
  };
}
`;
    return ctx.parseStatements(code);
  }
});
var JsonDerive = defineDeriveMacro({
  name: "Json",
  description: "Generate JSON serialization and deserialization functions",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const serializeCode = `
export function ${uncapitalize(name)}ToJson(value: ${name}): string {
  return JSON.stringify(value);
}
`;
    const validations = fields.map((field) => {
      const baseType = getBaseType(field);
      const optionalCheck = field.optional ? "" : `
    if (obj.${field.name} === undefined) {
      throw new Error("Missing required field: ${field.name}");
    }`;
      const typeCheck = `
    if (obj.${field.name} !== undefined && typeof obj.${field.name} !== "${baseType}") {
      throw new Error("Field ${field.name} must be ${baseType}");
    }`;
      return optionalCheck + typeCheck;
    }).join("\n");
    const deserializeCode = `
export function ${uncapitalize(name)}FromJson(json: string): ${name} {
  const obj = JSON.parse(json);
${validations}
  return obj as ${name};
}
`;
    return [
      ...ctx.parseStatements(serializeCode),
      ...ctx.parseStatements(deserializeCode)
    ];
  }
});
var BuilderDerive = defineDeriveMacro({
  name: "Builder",
  description: "Generate a builder pattern class",
  expand(ctx, _target, typeInfo) {
    const { name, fields } = typeInfo;
    const builderName = `${name}Builder`;
    const setters = fields.map((field) => {
      const methodName = `with${capitalize(field.name)}`;
      return `
  ${methodName}(${field.name}: ${field.typeString}): ${builderName} {
    this._${field.name} = ${field.name};
    return this;
  }`;
    }).join("\n");
    const privateFields = fields.map((field) => {
      const defaultValue = getDefaultForType(field);
      return `  private _${field.name}: ${field.typeString} = ${defaultValue};`;
    }).join("\n");
    const buildProps = fields.map((field) => `      ${field.name}: this._${field.name}`).join(",\n");
    const code = `
export class ${builderName} {
${privateFields}

${setters}

  build(): ${name} {
    return {
${buildProps}
    };
  }
}
`;
    return ctx.parseStatements(code);
  }
});
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getBaseType(field) {
  const typeStr = field.typeString.toLowerCase();
  if (typeStr === "number" || typeStr.includes("number")) return "number";
  if (typeStr === "string" || typeStr.includes("string")) return "string";
  if (typeStr === "boolean" || typeStr.includes("boolean")) return "boolean";
  if (typeStr.startsWith("array") || typeStr.includes("[]")) return "object";
  return "object";
}
function getDefaultForType(field) {
  if (field.optional) {
    return "undefined";
  }
  const baseType = getBaseType(field);
  switch (baseType) {
    case "number":
      return "0";
    case "string":
      return '""';
    case "boolean":
      return "false";
    default:
      return "{}";
  }
}
globalRegistry.register(EqDerive);
globalRegistry.register(OrdDerive);
globalRegistry.register(CloneDerive);
globalRegistry.register(DebugDerive);
globalRegistry.register(HashDerive);
globalRegistry.register(DefaultDerive);
globalRegistry.register(JsonDerive);
globalRegistry.register(BuilderDerive);

// src/macros/operators.ts
var ts3 = __toESM(require("typescript"), 1);
var operatorMappings = /* @__PURE__ */ new Map();
function registerOperators(typeName, mappings) {
  const typeMap = operatorMappings.get(typeName) ?? /* @__PURE__ */ new Map();
  for (const [op, method] of Object.entries(mappings)) {
    typeMap.set(op, method);
  }
  operatorMappings.set(typeName, typeMap);
}
function getOperatorMethod(typeName, operator) {
  const explicit = operatorMappings.get(typeName)?.get(operator);
  if (explicit) return explicit;
  return void 0;
}
var operatorsAttribute = defineAttributeMacro({
  name: "operators",
  description: "Define operator overloading mappings for a class",
  validTargets: ["class"],
  expand(ctx, decorator, target, args) {
    if (!ts3.isClassDeclaration(target) || !target.name) {
      ctx.reportError(
        decorator,
        "@operators can only be applied to named classes"
      );
      return target;
    }
    const className = target.name.text;
    if (args.length !== 1 || !ts3.isObjectLiteralExpression(args[0])) {
      ctx.reportError(
        decorator,
        "@operators requires an object literal argument"
      );
      return target;
    }
    const mappings = {};
    for (const prop of args[0].properties) {
      if (ts3.isPropertyAssignment(prop)) {
        let keyName;
        if (ts3.isStringLiteral(prop.name)) {
          keyName = prop.name.text;
        } else if (ts3.isIdentifier(prop.name)) {
          keyName = prop.name.text;
        }
        if (keyName && ts3.isStringLiteral(prop.initializer)) {
          mappings[keyName] = prop.initializer.text;
        }
      }
    }
    registerOperators(className, mappings);
    return target;
  }
});
var opsMacro = defineExpressionMacro({
  name: "ops",
  description: "Transform operators into method calls",
  expand(ctx, callExpr, args) {
    if (args.length !== 1) {
      ctx.reportError(
        callExpr,
        "ops() expects exactly one expression argument"
      );
      return callExpr;
    }
    const expr = args[0];
    return transformExpression(ctx, expr);
  }
});
function transformExpression(ctx, expr) {
  const factory = ctx.factory;
  if (ts3.isBinaryExpression(expr)) {
    const operator = getOperatorString(expr.operatorToken.kind);
    if (!operator) {
      return factory.updateBinaryExpression(
        expr,
        transformExpression(ctx, expr.left),
        expr.operatorToken,
        transformExpression(ctx, expr.right)
      );
    }
    const leftType = ctx.getTypeOf(expr.left);
    const typeName = ctx.typeChecker.typeToString(leftType);
    const baseTypeName = typeName.split("<")[0].trim();
    const method = getOperatorMethod(baseTypeName, operator);
    if (method) {
      const left = transformExpression(ctx, expr.left);
      const right = transformExpression(ctx, expr.right);
      return factory.createCallExpression(
        factory.createPropertyAccessExpression(left, method),
        void 0,
        [right]
      );
    }
    return factory.updateBinaryExpression(
      expr,
      transformExpression(ctx, expr.left),
      expr.operatorToken,
      transformExpression(ctx, expr.right)
    );
  }
  if (ts3.isPrefixUnaryExpression(expr)) {
    const operator = getPrefixOperatorString(expr.operator);
    if (operator) {
      const operandType = ctx.getTypeOf(expr.operand);
      const typeName = ctx.typeChecker.typeToString(operandType).split("<")[0].trim();
      const method = getOperatorMethod(typeName, operator);
      if (method) {
        const operand = transformExpression(ctx, expr.operand);
        return factory.createCallExpression(
          factory.createPropertyAccessExpression(operand, method),
          void 0,
          []
        );
      }
    }
    return factory.updatePrefixUnaryExpression(
      expr,
      transformExpression(ctx, expr.operand)
    );
  }
  if (ts3.isParenthesizedExpression(expr)) {
    return factory.updateParenthesizedExpression(
      expr,
      transformExpression(ctx, expr.expression)
    );
  }
  if (ts3.isCallExpression(expr)) {
    return factory.updateCallExpression(
      expr,
      transformExpression(ctx, expr.expression),
      expr.typeArguments,
      expr.arguments.map((arg) => transformExpression(ctx, arg))
    );
  }
  if (ts3.isPropertyAccessExpression(expr)) {
    return factory.updatePropertyAccessExpression(
      expr,
      transformExpression(ctx, expr.expression),
      expr.name
    );
  }
  return expr;
}
function getOperatorString(kind) {
  switch (kind) {
    case ts3.SyntaxKind.PlusToken:
      return "+";
    case ts3.SyntaxKind.MinusToken:
      return "-";
    case ts3.SyntaxKind.AsteriskToken:
      return "*";
    case ts3.SyntaxKind.SlashToken:
      return "/";
    case ts3.SyntaxKind.PercentToken:
      return "%";
    case ts3.SyntaxKind.AsteriskAsteriskToken:
      return "**";
    case ts3.SyntaxKind.LessThanToken:
      return "<";
    case ts3.SyntaxKind.LessThanEqualsToken:
      return "<=";
    case ts3.SyntaxKind.GreaterThanToken:
      return ">";
    case ts3.SyntaxKind.GreaterThanEqualsToken:
      return ">=";
    case ts3.SyntaxKind.EqualsEqualsToken:
      return "==";
    case ts3.SyntaxKind.EqualsEqualsEqualsToken:
      return "===";
    case ts3.SyntaxKind.ExclamationEqualsToken:
      return "!=";
    case ts3.SyntaxKind.ExclamationEqualsEqualsToken:
      return "!==";
    case ts3.SyntaxKind.AmpersandToken:
      return "&";
    case ts3.SyntaxKind.BarToken:
      return "|";
    case ts3.SyntaxKind.CaretToken:
      return "^";
    case ts3.SyntaxKind.LessThanLessThanToken:
      return "<<";
    case ts3.SyntaxKind.GreaterThanGreaterThanToken:
      return ">>";
    default:
      return void 0;
  }
}
function getPrefixOperatorString(kind) {
  switch (kind) {
    case ts3.SyntaxKind.MinusToken:
      return "-unary";
    case ts3.SyntaxKind.PlusToken:
      return "+unary";
    case ts3.SyntaxKind.ExclamationToken:
      return "!";
    case ts3.SyntaxKind.TildeToken:
      return "~";
    default:
      return void 0;
  }
}
var pipeMacro = defineExpressionMacro({
  name: "pipe",
  description: "Pipe a value through a series of functions",
  expand(ctx, callExpr, args) {
    if (args.length < 2) {
      ctx.reportError(
        callExpr,
        "pipe() requires at least an initial value and one function"
      );
      return callExpr;
    }
    const factory = ctx.factory;
    let result = args[0];
    for (let i = 1; i < args.length; i++) {
      result = factory.createCallExpression(args[i], void 0, [result]);
    }
    return result;
  }
});
var composeMacro = defineExpressionMacro({
  name: "compose",
  description: "Compose functions right-to-left",
  expand(ctx, callExpr, args) {
    if (args.length < 1) {
      ctx.reportError(callExpr, "compose() requires at least one function");
      return callExpr;
    }
    const factory = ctx.factory;
    const paramName = ctx.generateUniqueName("x");
    let body = paramName;
    for (let i = args.length - 1; i >= 0; i--) {
      body = factory.createCallExpression(args[i], void 0, [body]);
    }
    return factory.createArrowFunction(
      void 0,
      void 0,
      [factory.createParameterDeclaration(void 0, void 0, paramName)],
      void 0,
      factory.createToken(ts3.SyntaxKind.EqualsGreaterThanToken),
      body
    );
  }
});
globalRegistry.register(operatorsAttribute);
globalRegistry.register(opsMacro);
globalRegistry.register(pipeMacro);
globalRegistry.register(composeMacro);

// src/macros/reflect.ts
var ts4 = __toESM(require("typescript"), 1);
var reflectAttribute = defineAttributeMacro({
  name: "reflect",
  description: "Enable compile-time reflection for a type",
  validTargets: ["interface", "class", "type"],
  expand(ctx, decorator, target, _args) {
    const typeInfo = extractTypeInfo(ctx, target);
    if (typeInfo) {
      const metaName = `__${typeInfo.name}_meta__`;
      const metaDecl = generateTypeInfoDeclaration(ctx, metaName, typeInfo);
      return [target, metaDecl];
    }
    return target;
  }
});
function extractTypeInfo(ctx, node) {
  if (ts4.isInterfaceDeclaration(node)) {
    return extractInterfaceInfo(ctx, node);
  }
  if (ts4.isClassDeclaration(node)) {
    return extractClassInfo(ctx, node);
  }
  if (ts4.isTypeAliasDeclaration(node)) {
    return extractTypeAliasInfo(ctx, node);
  }
  return null;
}
function extractInterfaceInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const properties = ctx.typeChecker.getPropertiesOfType(type);
  const fields = properties.map((prop) => {
    const decls = prop.getDeclarations();
    const decl = decls?.[0];
    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
      prop,
      decl || node
    );
    return {
      name: prop.name,
      type: ctx.typeChecker.typeToString(propType),
      optional: (prop.flags & ts4.SymbolFlags.Optional) !== 0,
      readonly: decl && (ts4.isPropertySignature(decl) || ts4.isPropertyDeclaration(decl)) ? decl.modifiers?.some(
        (m) => m.kind === ts4.SyntaxKind.ReadonlyKeyword
      ) ?? false : false
    };
  });
  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];
  const extendsTypes = node.heritageClauses?.filter((hc) => hc.token === ts4.SyntaxKind.ExtendsKeyword).flatMap((hc) => hc.types.map((t) => t.expression.getText())) ?? [];
  return {
    name: node.name.text,
    kind: "interface",
    fields,
    typeParameters,
    extends: extendsTypes
  };
}
function extractClassInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const properties = ctx.typeChecker.getPropertiesOfType(type);
  const fields = [];
  const methods = [];
  for (const prop of properties) {
    const decls = prop.getDeclarations();
    const decl = decls?.[0];
    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
      prop,
      decl || node
    );
    const typeStr = ctx.typeChecker.typeToString(propType);
    if (decl && ts4.isMethodDeclaration(decl)) {
      const params = decl.parameters.map((p) => ({
        name: ts4.isIdentifier(p.name) ? p.name.text : "param",
        type: p.type ? p.type.getText() : "unknown",
        optional: !!p.questionToken,
        defaultValue: p.initializer?.getText()
      }));
      methods.push({
        name: prop.name,
        parameters: params,
        returnType: decl.type?.getText() ?? "void",
        isAsync: !!decl.modifiers?.some(
          (m) => m.kind === ts4.SyntaxKind.AsyncKeyword
        ),
        isStatic: !!decl.modifiers?.some(
          (m) => m.kind === ts4.SyntaxKind.StaticKeyword
        )
      });
    } else {
      fields.push({
        name: prop.name,
        type: typeStr,
        optional: (prop.flags & ts4.SymbolFlags.Optional) !== 0,
        readonly: decl && ts4.isPropertyDeclaration(decl) ? decl.modifiers?.some(
          (m) => m.kind === ts4.SyntaxKind.ReadonlyKeyword
        ) ?? false : false
      });
    }
  }
  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];
  return {
    name: node.name?.text ?? "Anonymous",
    kind: "class",
    fields,
    methods,
    typeParameters
  };
}
function extractTypeAliasInfo(ctx, node) {
  const type = ctx.typeChecker.getTypeAtLocation(node);
  const typeString = ctx.typeChecker.typeToString(type);
  if (type.isClassOrInterface() || type.flags & ts4.TypeFlags.Object) {
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    const fields = properties.map((prop) => {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, node);
      return {
        name: prop.name,
        type: ctx.typeChecker.typeToString(propType),
        optional: (prop.flags & ts4.SymbolFlags.Optional) !== 0,
        readonly: false
      };
    });
    return {
      name: node.name.text,
      kind: "type",
      fields,
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  if (type.isUnion()) {
    return {
      name: node.name.text,
      kind: "union",
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  if (type.isIntersection()) {
    return {
      name: node.name.text,
      kind: "intersection",
      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? []
    };
  }
  return {
    name: node.name.text,
    kind: "type"
  };
}
function generateTypeInfoDeclaration(ctx, name, info) {
  const factory = ctx.factory;
  const fieldsArray = info.fields?.map(
    (f) => factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(f.name)
        ),
        factory.createPropertyAssignment(
          "type",
          factory.createStringLiteral(f.type)
        ),
        factory.createPropertyAssignment(
          "optional",
          f.optional ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "readonly",
          f.readonly ? factory.createTrue() : factory.createFalse()
        )
      ],
      true
    )
  ) ?? [];
  const methodsArray = info.methods?.map(
    (m) => factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(m.name)
        ),
        factory.createPropertyAssignment(
          "returnType",
          factory.createStringLiteral(m.returnType)
        ),
        factory.createPropertyAssignment(
          "isAsync",
          m.isAsync ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "isStatic",
          m.isStatic ? factory.createTrue() : factory.createFalse()
        ),
        factory.createPropertyAssignment(
          "parameters",
          factory.createArrayLiteralExpression(
            m.parameters.map(
              (p) => factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "name",
                    factory.createStringLiteral(p.name)
                  ),
                  factory.createPropertyAssignment(
                    "type",
                    factory.createStringLiteral(p.type)
                  ),
                  factory.createPropertyAssignment(
                    "optional",
                    p.optional ? factory.createTrue() : factory.createFalse()
                  )
                ],
                true
              )
            )
          )
        )
      ],
      true
    )
  ) ?? [];
  const infoObj = factory.createObjectLiteralExpression(
    [
      factory.createPropertyAssignment(
        "name",
        factory.createStringLiteral(info.name)
      ),
      factory.createPropertyAssignment(
        "kind",
        factory.createStringLiteral(info.kind)
      ),
      factory.createPropertyAssignment(
        "fields",
        factory.createArrayLiteralExpression(fieldsArray, true)
      ),
      factory.createPropertyAssignment(
        "methods",
        factory.createArrayLiteralExpression(methodsArray, true)
      ),
      factory.createPropertyAssignment(
        "typeParameters",
        factory.createArrayLiteralExpression(
          (info.typeParameters ?? []).map(
            (tp) => factory.createStringLiteral(tp)
          )
        )
      )
    ],
    true
  );
  return factory.createVariableStatement(
    [factory.createModifier(ts4.SyntaxKind.ExportKeyword)],
    factory.createVariableDeclarationList(
      [factory.createVariableDeclaration(name, void 0, void 0, infoObj)],
      ts4.NodeFlags.Const
    )
  );
}
var typeInfoMacro = defineExpressionMacro({
  name: "typeInfo",
  description: "Get compile-time type information",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(callExpr, "typeInfo requires exactly one type argument");
      return callExpr;
    }
    const typeArg = typeArgs[0];
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArg);
    const typeName = ctx.typeChecker.typeToString(type);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    let kind = "type";
    const symbol = type.getSymbol();
    if (symbol) {
      const decls = symbol.getDeclarations();
      if (decls && decls.length > 0) {
        const decl = decls[0];
        if (ts4.isInterfaceDeclaration(decl)) kind = "interface";
        else if (ts4.isClassDeclaration(decl)) kind = "class";
        else if (ts4.isEnumDeclaration(decl)) kind = "enum";
      }
    }
    const fieldsArray = properties.map((prop) => {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
        prop,
        callExpr
      );
      const decls = prop.getDeclarations();
      const decl = decls?.[0];
      const isReadonly = decl && (ts4.isPropertySignature(decl) || ts4.isPropertyDeclaration(decl)) ? decl.modifiers?.some(
        (m) => m.kind === ts4.SyntaxKind.ReadonlyKeyword
      ) ?? false : false;
      return factory.createObjectLiteralExpression(
        [
          factory.createPropertyAssignment(
            "name",
            factory.createStringLiteral(prop.name)
          ),
          factory.createPropertyAssignment(
            "type",
            factory.createStringLiteral(ctx.typeChecker.typeToString(propType))
          ),
          factory.createPropertyAssignment(
            "optional",
            (prop.flags & ts4.SymbolFlags.Optional) !== 0 ? factory.createTrue() : factory.createFalse()
          ),
          factory.createPropertyAssignment(
            "readonly",
            isReadonly ? factory.createTrue() : factory.createFalse()
          )
        ],
        true
      );
    });
    return factory.createObjectLiteralExpression(
      [
        factory.createPropertyAssignment(
          "name",
          factory.createStringLiteral(typeName)
        ),
        factory.createPropertyAssignment(
          "kind",
          factory.createStringLiteral(kind)
        ),
        factory.createPropertyAssignment(
          "fields",
          factory.createArrayLiteralExpression(fieldsArray, true)
        )
      ],
      true
    );
  }
});
var fieldNamesMacro = defineExpressionMacro({
  name: "fieldNames",
  description: "Get field names of a type as an array",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(
        callExpr,
        "fieldNames requires exactly one type argument"
      );
      return callExpr;
    }
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    return factory.createArrayLiteralExpression(
      properties.map((prop) => factory.createStringLiteral(prop.name))
    );
  }
});
var validatorMacro = defineExpressionMacro({
  name: "validator",
  description: "Generate a runtime validator for a type",
  expand(ctx, callExpr, _args) {
    const factory = ctx.factory;
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length !== 1) {
      ctx.reportError(callExpr, "validator requires exactly one type argument");
      return callExpr;
    }
    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    const typeName = ctx.typeChecker.typeToString(type);
    const checks = [];
    for (const prop of properties) {
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
        prop,
        callExpr
      );
      const propTypeStr = ctx.typeChecker.typeToString(propType);
      const isOptional = (prop.flags & ts4.SymbolFlags.Optional) !== 0;
      let checkExpr;
      if (propTypeStr === "string") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts4.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("string")
        );
      } else if (propTypeStr === "number") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts4.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("number")
        );
      } else if (propTypeStr === "boolean") {
        checkExpr = factory.createBinaryExpression(
          factory.createTypeOfExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            )
          ),
          factory.createToken(ts4.SyntaxKind.ExclamationEqualsEqualsToken),
          factory.createStringLiteral("boolean")
        );
      } else {
        continue;
      }
      if (isOptional) {
        checkExpr = factory.createBinaryExpression(
          factory.createBinaryExpression(
            factory.createPropertyAccessExpression(
              factory.createIdentifier("value"),
              prop.name
            ),
            factory.createToken(ts4.SyntaxKind.ExclamationEqualsEqualsToken),
            factory.createIdentifier("undefined")
          ),
          factory.createToken(ts4.SyntaxKind.AmpersandAmpersandToken),
          checkExpr
        );
      }
      checks.push(
        factory.createIfStatement(
          checkExpr,
          factory.createBlock([
            factory.createExpressionStatement(
              factory.createCallExpression(
                factory.createPropertyAccessExpression(
                  factory.createIdentifier("errors"),
                  "push"
                ),
                void 0,
                [
                  factory.createStringLiteral(
                    `Invalid type for field '${prop.name}': expected ${propTypeStr}`
                  )
                ]
              )
            )
          ])
        )
      );
    }
    return factory.createArrowFunction(
      void 0,
      void 0,
      [
        factory.createParameterDeclaration(
          void 0,
          void 0,
          factory.createIdentifier("value"),
          void 0,
          factory.createKeywordTypeNode(ts4.SyntaxKind.UnknownKeyword)
        )
      ],
      factory.createTypeReferenceNode("ValidationResult", [typeArgs[0]]),
      factory.createToken(ts4.SyntaxKind.EqualsGreaterThanToken),
      factory.createBlock(
        [
          // const errors: string[] = [];
          factory.createVariableStatement(
            void 0,
            factory.createVariableDeclarationList(
              [
                factory.createVariableDeclaration(
                  "errors",
                  void 0,
                  factory.createArrayTypeNode(
                    factory.createKeywordTypeNode(ts4.SyntaxKind.StringKeyword)
                  ),
                  factory.createArrayLiteralExpression([])
                )
              ],
              ts4.NodeFlags.Const
            )
          ),
          // Type check: if (typeof value !== "object" || value === null)
          factory.createIfStatement(
            factory.createBinaryExpression(
              factory.createBinaryExpression(
                factory.createTypeOfExpression(
                  factory.createIdentifier("value")
                ),
                factory.createToken(ts4.SyntaxKind.ExclamationEqualsEqualsToken),
                factory.createStringLiteral("object")
              ),
              factory.createToken(ts4.SyntaxKind.BarBarToken),
              factory.createBinaryExpression(
                factory.createIdentifier("value"),
                factory.createToken(ts4.SyntaxKind.EqualsEqualsEqualsToken),
                factory.createNull()
              )
            ),
            factory.createBlock([
              factory.createReturnStatement(
                factory.createObjectLiteralExpression(
                  [
                    factory.createPropertyAssignment(
                      "success",
                      factory.createFalse()
                    ),
                    factory.createPropertyAssignment(
                      "errors",
                      factory.createArrayLiteralExpression([
                        factory.createStringLiteral(
                          `Expected object, got ${"object"}`
                        )
                      ])
                    )
                  ],
                  true
                )
              )
            ])
          ),
          ...checks,
          // Return result
          factory.createReturnStatement(
            factory.createConditionalExpression(
              factory.createBinaryExpression(
                factory.createPropertyAccessExpression(
                  factory.createIdentifier("errors"),
                  "length"
                ),
                factory.createToken(ts4.SyntaxKind.EqualsEqualsEqualsToken),
                factory.createNumericLiteral(0)
              ),
              factory.createToken(ts4.SyntaxKind.QuestionToken),
              factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "success",
                    factory.createTrue()
                  ),
                  factory.createPropertyAssignment(
                    "value",
                    factory.createAsExpression(
                      factory.createIdentifier("value"),
                      typeArgs[0]
                    )
                  )
                ],
                true
              ),
              factory.createToken(ts4.SyntaxKind.ColonToken),
              factory.createObjectLiteralExpression(
                [
                  factory.createPropertyAssignment(
                    "success",
                    factory.createFalse()
                  ),
                  factory.createPropertyAssignment(
                    "errors",
                    factory.createIdentifier("errors")
                  )
                ],
                true
              )
            )
          )
        ],
        true
      )
    );
  }
});
globalRegistry.register(reflectAttribute);
globalRegistry.register(typeInfoMacro);
globalRegistry.register(fieldNamesMacro);
globalRegistry.register(validatorMacro);

// src/macros/typeclass.ts
var ts5 = __toESM(require("typescript"), 1);
var typeclassRegistry = /* @__PURE__ */ new Map();
var instanceRegistry = [];
function uncapitalize2(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function capitalize2(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function instanceVarName(tcName, typeName) {
  return `${uncapitalize2(tcName)}${capitalize2(typeName)}`;
}
function getBaseType2(field) {
  const typeStr = field.typeString.toLowerCase();
  if (typeStr === "number" || typeStr.includes("number")) return "number";
  if (typeStr === "string" || typeStr.includes("string")) return "string";
  if (typeStr === "boolean" || typeStr.includes("boolean")) return "boolean";
  if (typeStr.startsWith("array") || typeStr.includes("[]")) return "array";
  return "object";
}
var typeclassAttribute = defineAttributeMacro({
  name: "typeclass",
  description: "Define a typeclass from an interface, enabling derivation and extension methods",
  validTargets: ["interface"],
  expand(ctx, _decorator, target, _args) {
    if (!ts5.isInterfaceDeclaration(target)) {
      ctx.reportError(target, "@typeclass can only be applied to interfaces");
      return target;
    }
    const tcName = target.name.text;
    const typeParams = target.typeParameters;
    if (!typeParams || typeParams.length === 0) {
      ctx.reportError(
        target,
        "@typeclass interface must have at least one type parameter (e.g., interface Show<A>)"
      );
      return target;
    }
    const typeParam = typeParams[0].name.text;
    const methods = [];
    for (const member of target.members) {
      if (ts5.isMethodSignature(member) && member.name) {
        const methodName = ts5.isIdentifier(member.name) ? member.name.text : member.name.getText();
        const params = [];
        let isSelfMethod = false;
        for (let i = 0; i < member.parameters.length; i++) {
          const param = member.parameters[i];
          const paramName = ts5.isIdentifier(param.name) ? param.name.text : param.name.getText();
          const paramType = param.type ? param.type.getText() : "unknown";
          if (i === 0 && paramType === typeParam) {
            isSelfMethod = true;
          }
          params.push({ name: paramName, typeString: paramType });
        }
        const returnType = member.type ? member.type.getText() : "void";
        methods.push({
          name: methodName,
          params,
          returnType,
          isSelfMethod
        });
      }
    }
    const tcInfo = {
      name: tcName,
      typeParam,
      methods,
      canDeriveProduct: true,
      canDeriveSum: true
    };
    typeclassRegistry.set(tcName, tcInfo);
    const companionCode = generateCompanionNamespace(tcInfo);
    const extensionCode = generateExtensionHelpers(tcInfo);
    const statements = [
      ...ctx.parseStatements(companionCode),
      ...ctx.parseStatements(extensionCode)
    ];
    return [target, ...statements];
  }
});
function generateCompanionNamespace(tc) {
  const { name } = tc;
  const registryVar = `__${uncapitalize2(name)}Instances__`;
  return `
// Typeclass instance registry for ${name}
const ${registryVar}: Map<string, ${name}<any>> = new Map();

namespace ${name} {
  /** Register an instance of ${name} for type T */
  export function registerInstance<T>(typeName: string, instance: ${name}<T>): void {
    ${registryVar}.set(typeName, instance);
  }

  /** Summon (resolve) an instance of ${name} for type T */
  export function summon<T>(typeName: string): ${name}<T> {
    const instance = ${registryVar}.get(typeName);
    if (!instance) {
      throw new Error(\`No ${name} instance found for type '\${typeName}'\`);
    }
    return instance as ${name}<T>;
  }

  /** Check if an instance exists for the given type */
  export function hasInstance(typeName: string): boolean {
    return ${registryVar}.has(typeName);
  }

  /** Get all registered type names */
  export function registeredTypes(): string[] {
    return Array.from(${registryVar}.keys());
  }
}
`;
}
function generateExtensionHelpers(tc) {
  const { name, methods } = tc;
  const extensionFns = [];
  for (const method of methods) {
    if (method.isSelfMethod) {
      const otherParams = method.params.slice(1);
      const otherParamDecls = otherParams.map((p) => `${p.name}: ${p.typeString}`).join(", ");
      const otherParamNames = otherParams.map((p) => p.name).join(", ");
      const allArgs = ["self", ...otherParams.map((p) => p.name)].join(", ");
      const paramList = otherParamDecls ? `self: any, ${otherParamDecls}, typeName: string` : `self: any, typeName: string`;
      extensionFns.push(`
/** Extension method: ${method.name} via ${name} typeclass */
function ${uncapitalize2(name)}${capitalize2(method.name)}<A>(${paramList}): ${method.returnType} {
  return ${name}.summon<A>(typeName).${method.name}(${allArgs});
}
`);
    }
  }
  return extensionFns.join("\n");
}
var instanceAttribute = defineAttributeMacro({
  name: "instance",
  description: "Register a typeclass instance for a specific type",
  validTargets: ["property", "class"],
  expand(ctx, _decorator, target, args) {
    if (args.length === 0) {
      ctx.reportError(
        target,
        '@instance requires a type name argument, e.g., @instance("number")'
      );
      return target;
    }
    const typeNameArg = args[0];
    let typeName;
    if (ts5.isStringLiteral(typeNameArg)) {
      typeName = typeNameArg.text;
    } else {
      ctx.reportError(
        typeNameArg,
        "@instance argument must be a string literal"
      );
      return target;
    }
    let tcName;
    let varName;
    if (ts5.isVariableStatement(target)) {
      const decl = target.declarationList.declarations[0];
      if (decl && ts5.isIdentifier(decl.name)) {
        varName = decl.name.text;
      }
      if (decl && decl.type && ts5.isTypeReferenceNode(decl.type)) {
        tcName = decl.type.typeName.getText();
      }
    } else if (ts5.isVariableDeclaration(target)) {
      if (ts5.isIdentifier(target.name)) {
        varName = target.name.text;
      }
      if (target.type && ts5.isTypeReferenceNode(target.type)) {
        tcName = target.type.typeName.getText();
      }
    }
    if (!tcName && args.length > 1 && ts5.isStringLiteral(args[1])) {
      tcName = args[1].text;
    }
    if (!tcName || !varName) {
      ctx.reportError(
        target,
        "@instance: could not determine typeclass name. Ensure the variable has a type annotation like Show<number>"
      );
      return target;
    }
    instanceRegistry.push({
      typeclassName: tcName,
      forType: typeName,
      instanceName: varName,
      derived: false
    });
    const registrationCode = `${tcName}.registerInstance<${typeName}>("${typeName}", ${varName});`;
    const registrationStatements = ctx.parseStatements(registrationCode);
    return [target, ...registrationStatements];
  }
});
var builtinDerivations = {
  Show: {
    deriveProduct(typeName, fields) {
      const fieldShows = fields.map((f) => {
        const inst = instanceVarName("show", getBaseType2(f));
        return `${f.name} = \${${inst}.show(a.${f.name})}`;
      }).join(", ");
      const varName = instanceVarName("show", typeName);
      return `
const ${varName}: Show<${typeName}> = {
  show: (a: ${typeName}): string => \`${typeName}(${fieldShows})\`,
};
Show.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    },
    deriveSum(typeName, discriminant, variants) {
      const varName = instanceVarName("show", typeName);
      const cases = variants.map((v) => {
        const inst = instanceVarName("show", v.typeName);
        return `    case "${v.tag}": return ${inst}.show(a as any);`;
      }).join("\n");
      return `
const ${varName}: Show<${typeName}> = {
  show: (a: ${typeName}): string => {
    switch ((a as any).${discriminant}) {
${cases}
      default: return String(a);
    }
  },
};
Show.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    }
  },
  Eq: {
    deriveProduct(typeName, fields) {
      const fieldEqs = fields.map((f) => {
        const inst = instanceVarName("eq", getBaseType2(f));
        return `${inst}.eq(a.${f.name}, b.${f.name})`;
      });
      const body = fieldEqs.length > 0 ? fieldEqs.join(" && ") : "true";
      const varName = instanceVarName("eq", typeName);
      return `
const ${varName}: Eq<${typeName}> = {
  eq: (a: ${typeName}, b: ${typeName}): boolean => ${body},
  neq: (a: ${typeName}, b: ${typeName}): boolean => !(${body}),
};
Eq.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    },
    deriveSum(typeName, discriminant, variants) {
      const varName = instanceVarName("eq", typeName);
      const cases = variants.map((v) => {
        const inst = instanceVarName("eq", v.typeName);
        return `    case "${v.tag}": return (b as any).${discriminant} === "${v.tag}" && ${inst}.eq(a as any, b as any);`;
      }).join("\n");
      return `
const ${varName}: Eq<${typeName}> = {
  eq: (a: ${typeName}, b: ${typeName}): boolean => {
    if ((a as any).${discriminant} !== (b as any).${discriminant}) return false;
    switch ((a as any).${discriminant}) {
${cases}
      default: return false;
    }
  },
  neq: (a: ${typeName}, b: ${typeName}): boolean => !${varName}.eq(a, b),
};
Eq.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    }
  },
  Ord: {
    deriveProduct(typeName, fields) {
      const varName = instanceVarName("ord", typeName);
      const fieldComparisons = fields.map((f) => {
        const inst = instanceVarName("ord", getBaseType2(f));
        return `  { const c = ${inst}.compare(a.${f.name}, b.${f.name}); if (c !== 0) return c; }`;
      }).join("\n");
      return `
const ${varName}: Ord<${typeName}> = {
  compare: (a: ${typeName}, b: ${typeName}): -1 | 0 | 1 => {
${fieldComparisons}
    return 0;
  },
};
Ord.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    },
    deriveSum(typeName, discriminant, variants) {
      const varName = instanceVarName("ord", typeName);
      const tagOrder = variants.map((v, i) => `"${v.tag}": ${i}`).join(", ");
      const cases = variants.map((v) => {
        const inst = instanceVarName("ord", v.typeName);
        return `    case "${v.tag}": return ${inst}.compare(a as any, b as any);`;
      }).join("\n");
      return `
const ${varName}: Ord<${typeName}> = {
  compare: (a: ${typeName}, b: ${typeName}): -1 | 0 | 1 => {
    const tagOrder: Record<string, number> = { ${tagOrder} };
    const aTag = (a as any).${discriminant};
    const bTag = (b as any).${discriminant};
    if (aTag !== bTag) return aTag < bTag ? -1 : 1;
    switch (aTag) {
${cases}
      default: return 0;
    }
  },
};
Ord.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    }
  },
  Hash: {
    deriveProduct(typeName, fields) {
      const varName = instanceVarName("hash", typeName);
      const fieldHashes = fields.map((f) => {
        const inst = instanceVarName("hash", getBaseType2(f));
        return `  hash = ((hash << 5) + hash) ^ ${inst}.hash(a.${f.name});`;
      }).join("\n");
      return `
const ${varName}: Hash<${typeName}> = {
  hash: (a: ${typeName}): number => {
    let hash = 5381;
${fieldHashes}
    return hash >>> 0;
  },
};
Hash.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    },
    deriveSum(typeName, discriminant, variants) {
      const varName = instanceVarName("hash", typeName);
      const cases = variants.map((v, i) => {
        const inst = instanceVarName("hash", v.typeName);
        return `    case "${v.tag}": return ((${i} << 16) | ${inst}.hash(a as any)) >>> 0;`;
      }).join("\n");
      return `
const ${varName}: Hash<${typeName}> = {
  hash: (a: ${typeName}): number => {
    switch ((a as any).${discriminant}) {
${cases}
      default: return 0;
    }
  },
};
Hash.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    }
  },
  Functor: {
    deriveProduct(typeName, fields) {
      const varName = instanceVarName("functor", typeName);
      return `
const ${varName}: Functor<${typeName}> = {
  map: <A, B>(fa: ${typeName}, f: (a: A) => B): ${typeName} => {
    return { ...fa } as any;
  },
};
Functor.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    },
    deriveSum(typeName, discriminant, variants) {
      const varName = instanceVarName("functor", typeName);
      const cases = variants.map((v) => {
        const inst = instanceVarName("functor", v.typeName);
        return `    case "${v.tag}": return ${inst}.map(fa as any, f) as any;`;
      }).join("\n");
      return `
const ${varName}: Functor<${typeName}> = {
  map: <A, B>(fa: ${typeName}, f: (a: A) => B): ${typeName} => {
    switch ((fa as any).${discriminant}) {
${cases}
      default: return fa;
    }
  },
};
Functor.registerInstance<${typeName}>("${typeName}", ${varName});
`;
    }
  }
};
function createTypeclassDeriveMacro(tcName) {
  return defineDeriveMacro({
    name: `${tcName}TC`,
    description: `Auto-derive ${tcName} typeclass instance`,
    expand(ctx, target, typeInfo) {
      const derivation = builtinDerivations[tcName];
      if (!derivation) {
        ctx.reportError(
          target,
          `No built-in derivation strategy for typeclass '${tcName}'. Register a custom derivation or provide a manual instance.`
        );
        return [];
      }
      const { name: typeName, fields } = typeInfo;
      if (ts5.isTypeAliasDeclaration(target) && target.type) {
        const sumInfo = tryExtractSumType(ctx, target);
        if (sumInfo) {
          const code2 = derivation.deriveSum(
            typeName,
            sumInfo.discriminant,
            sumInfo.variants
          );
          const stmts2 = ctx.parseStatements(code2);
          instanceRegistry.push({
            typeclassName: tcName,
            forType: typeName,
            instanceName: instanceVarName(uncapitalize2(tcName), typeName),
            derived: true
          });
          return stmts2;
        }
      }
      const code = derivation.deriveProduct(typeName, fields);
      const stmts = ctx.parseStatements(code);
      instanceRegistry.push({
        typeclassName: tcName,
        forType: typeName,
        instanceName: instanceVarName(uncapitalize2(tcName), typeName),
        derived: true
      });
      return stmts;
    }
  });
}
function tryExtractSumType(ctx, target) {
  if (!ts5.isUnionTypeNode(target.type)) {
    return void 0;
  }
  const variants = [];
  let discriminant;
  for (const member of target.type.types) {
    if (!ts5.isTypeReferenceNode(member)) {
      return void 0;
    }
    const typeName = member.typeName.getText();
    const type = ctx.typeChecker.getTypeFromTypeNode(member);
    const props = ctx.typeChecker.getPropertiesOfType(type);
    for (const prop of props) {
      const name = prop.name;
      if (name === "kind" || name === "_tag" || name === "type" || name === "tag") {
        if (!discriminant) {
          discriminant = name;
        } else if (discriminant !== name) {
          continue;
        }
        const declarations = prop.getDeclarations();
        if (declarations && declarations.length > 0) {
          const decl = declarations[0];
          const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(
            prop,
            decl
          );
          if (propType.isStringLiteral()) {
            variants.push({ tag: propType.value, typeName });
          }
        }
      }
    }
  }
  if (discriminant && variants.length > 0) {
    return { discriminant, variants };
  }
  return void 0;
}
var showTCDerive = createTypeclassDeriveMacro("Show");
var eqTCDerive = createTypeclassDeriveMacro("Eq");
var ordTCDerive = createTypeclassDeriveMacro("Ord");
var hashTCDerive = createTypeclassDeriveMacro("Hash");
var functorTCDerive = createTypeclassDeriveMacro("Functor");
var derivingAttribute = defineAttributeMacro({
  name: "deriving",
  description: "Auto-derive typeclass instances for a type (Scala 3-like derives clause)",
  validTargets: ["interface", "class", "type"],
  expand(ctx, _decorator, target, args) {
    if (!ts5.isInterfaceDeclaration(target) && !ts5.isClassDeclaration(target) && !ts5.isTypeAliasDeclaration(target)) {
      ctx.reportError(
        target,
        "@deriving can only be applied to interfaces, classes, or type aliases"
      );
      return target;
    }
    const typeName = target.name?.text ?? "Anonymous";
    const type = ctx.typeChecker.getTypeAtLocation(target);
    const typeParameters = target.typeParameters ? Array.from(target.typeParameters) : [];
    const fields = [];
    const properties = ctx.typeChecker.getPropertiesOfType(type);
    for (const prop of properties) {
      const declarations = prop.getDeclarations();
      if (!declarations || declarations.length === 0) continue;
      const decl = declarations[0];
      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, decl);
      const propTypeString = ctx.typeChecker.typeToString(propType);
      const optional = (prop.flags & ts5.SymbolFlags.Optional) !== 0;
      const readonly = ts5.isPropertyDeclaration(decl) || ts5.isPropertySignature(decl) ? decl.modifiers?.some(
        (m) => m.kind === ts5.SyntaxKind.ReadonlyKeyword
      ) ?? false : false;
      fields.push({
        name: prop.name,
        typeString: propTypeString,
        type: propType,
        optional,
        readonly
      });
    }
    const typeInfo = {
      name: typeName,
      fields,
      typeParameters,
      type
    };
    const allStatements = [];
    for (const arg of args) {
      if (!ts5.isIdentifier(arg)) {
        ctx.reportError(arg, "@deriving arguments must be typeclass names");
        continue;
      }
      const tcName = arg.text;
      const derivation = builtinDerivations[tcName];
      if (derivation) {
        let code;
        if (ts5.isTypeAliasDeclaration(target)) {
          const sumInfo = tryExtractSumType(ctx, target);
          if (sumInfo) {
            code = derivation.deriveSum(
              typeName,
              sumInfo.discriminant,
              sumInfo.variants
            );
          } else {
            code = derivation.deriveProduct(typeName, fields);
          }
        } else {
          code = derivation.deriveProduct(typeName, fields);
        }
        allStatements.push(...ctx.parseStatements(code));
        instanceRegistry.push({
          typeclassName: tcName,
          forType: typeName,
          instanceName: instanceVarName(uncapitalize2(tcName), typeName),
          derived: true
        });
      } else {
        const deriveMacro = globalRegistry.getDerive(`${tcName}TC`);
        if (deriveMacro) {
          const stmts = deriveMacro.expand(ctx, target, typeInfo);
          allStatements.push(...stmts);
        } else {
          ctx.reportError(
            arg,
            `No derivation strategy found for typeclass '${tcName}'. Define a custom derivation or provide a manual instance.`
          );
        }
      }
    }
    return [target, ...allStatements];
  }
});
var summonMacro = defineExpressionMacro({
  name: "summon",
  description: "Resolve a typeclass instance at compile time (Scala 3-like summon)",
  expand(ctx, callExpr, _args) {
    const typeArgs = callExpr.typeArguments;
    if (!typeArgs || typeArgs.length === 0) {
      ctx.reportError(
        callExpr,
        "summon requires a type argument, e.g., summon<Show<Point>>()"
      );
      return callExpr;
    }
    const typeArg = typeArgs[0];
    if (!ts5.isTypeReferenceNode(typeArg)) {
      ctx.reportError(
        callExpr,
        "summon type argument must be a type reference like Show<Point>"
      );
      return callExpr;
    }
    const tcName = typeArg.typeName.getText();
    const innerTypeArgs = typeArg.typeArguments;
    if (!innerTypeArgs || innerTypeArgs.length === 0) {
      ctx.reportError(
        callExpr,
        `summon<${tcName}<...>>() requires the typeclass to have a type argument`
      );
      return callExpr;
    }
    const innerType = innerTypeArgs[0];
    let typeName;
    if (ts5.isTypeReferenceNode(innerType)) {
      typeName = innerType.typeName.getText();
    } else if (innerType.kind === ts5.SyntaxKind.NumberKeyword) {
      typeName = "number";
    } else if (innerType.kind === ts5.SyntaxKind.StringKeyword) {
      typeName = "string";
    } else if (innerType.kind === ts5.SyntaxKind.BooleanKeyword) {
      typeName = "boolean";
    } else {
      typeName = innerType.getText();
    }
    const code = `${tcName}.summon<${typeName}>("${typeName}")`;
    return ctx.parseExpression(code);
  }
});
var extendMacro = defineExpressionMacro({
  name: "extend",
  description: "Call extension methods on a value via typeclass instances",
  expand(ctx, callExpr, args) {
    if (args.length === 0) {
      ctx.reportError(callExpr, "extend() requires a value argument");
      return callExpr;
    }
    const parent = callExpr.parent;
    if (!parent || !ts5.isPropertyAccessExpression(parent)) {
      ctx.reportError(
        callExpr,
        "extend() must be followed by a method call, e.g., extend(value).show()"
      );
      return callExpr;
    }
    const methodName = parent.name.text;
    const value = args[0];
    const valueType = ctx.typeChecker.getTypeAtLocation(value);
    const typeName = ctx.typeChecker.typeToString(valueType);
    for (const [tcName, tcInfo] of typeclassRegistry) {
      const method = tcInfo.methods.find((m) => m.name === methodName);
      if (method) {
        const grandParent = parent.parent;
        if (grandParent && ts5.isCallExpression(grandParent)) {
          const extraArgs = Array.from(grandParent.arguments).map((a) => a.getText()).join(", ");
          const allArgs = extraArgs ? `${value.getText()}, ${extraArgs}` : value.getText();
          const code2 = `${tcName}.summon<${typeName}>("${typeName}").${methodName}(${allArgs})`;
          return ctx.parseExpression(code2);
        }
        const code = `${tcName}.summon<${typeName}>("${typeName}").${methodName}(${value.getText()})`;
        return ctx.parseExpression(code);
      }
    }
    ctx.reportError(
      parent,
      `No typeclass instance found providing method '${methodName}' for type '${typeName}'`
    );
    return callExpr;
  }
});
builtinDerivations["Semigroup"] = {
  deriveProduct(typeName, fields) {
    const varName = instanceVarName("semigroup", typeName);
    const fieldCombines = fields.map((f) => {
      const inst = instanceVarName("semigroup", getBaseType2(f));
      return `    ${f.name}: ${inst}.combine(a.${f.name}, b.${f.name})`;
    }).join(",\n");
    return `
const ${varName}: Semigroup<${typeName}> = {
  combine: (a: ${typeName}, b: ${typeName}): ${typeName} => ({
${fieldCombines}
  }),
};
Semigroup.registerInstance<${typeName}>("${typeName}", ${varName});
`;
  },
  deriveSum(_typeName, _discriminant, _variants) {
    return `// Semigroup cannot be auto-derived for sum types`;
  }
};
builtinDerivations["Monoid"] = {
  deriveProduct(typeName, fields) {
    const varName = instanceVarName("monoid", typeName);
    const fieldEmpties = fields.map((f) => {
      const inst = instanceVarName("monoid", getBaseType2(f));
      return `    ${f.name}: ${inst}.empty()`;
    }).join(",\n");
    const fieldCombines = fields.map((f) => {
      const inst = instanceVarName("monoid", getBaseType2(f));
      return `    ${f.name}: ${inst}.combine(a.${f.name}, b.${f.name})`;
    }).join(",\n");
    return `
const ${varName}: Monoid<${typeName}> = {
  empty: (): ${typeName} => ({
${fieldEmpties}
  }),
  combine: (a: ${typeName}, b: ${typeName}): ${typeName} => ({
${fieldCombines}
  }),
};
Monoid.registerInstance<${typeName}>("${typeName}", ${varName});
`;
  },
  deriveSum(_typeName, _discriminant, _variants) {
    return `// Monoid cannot be auto-derived for sum types`;
  }
};
globalRegistry.register(typeclassAttribute);
globalRegistry.register(instanceAttribute);
globalRegistry.register(derivingAttribute);
globalRegistry.register(summonMacro);
globalRegistry.register(extendMacro);
globalRegistry.register(showTCDerive);
globalRegistry.register(eqTCDerive);
globalRegistry.register(ordTCDerive);
globalRegistry.register(hashTCDerive);
globalRegistry.register(functorTCDerive);

// src/transforms/macro-transformer.ts
function macroTransformerFactory(program, config) {
  const verbose = config?.verbose ?? false;
  if (verbose) {
    console.log("[typemacro] Initializing transformer");
    console.log(
      `[typemacro] Registered macros: ${globalRegistry.getAll().map((m) => m.name).join(", ")}`
    );
  }
  return (context) => {
    return (sourceFile) => {
      if (verbose) {
        console.log(`[typemacro] Processing: ${sourceFile.fileName}`);
      }
      const ctx = createMacroContext(program, sourceFile, context);
      const transformer = new MacroTransformer(ctx, verbose);
      const result = ts6.visitNode(
        sourceFile,
        transformer.visit.bind(transformer)
      );
      const macroDiagnostics = ctx.getDiagnostics();
      for (const diag of macroDiagnostics) {
        const start = diag.node ? diag.node.getStart(sourceFile) : 0;
        const length = diag.node ? diag.node.getWidth(sourceFile) : 0;
        const tsDiag = {
          file: sourceFile,
          start,
          length,
          messageText: `[typemacro] ${diag.message}`,
          category: diag.severity === "error" ? ts6.DiagnosticCategory.Error : ts6.DiagnosticCategory.Warning,
          code: 9e4,
          // Custom diagnostic code range for typemacro
          source: "typemacro"
        };
        const ctxWithDiag = context;
        if (ctxWithDiag.addDiagnostic) {
          ctxWithDiag.addDiagnostic(tsDiag);
        }
        if (verbose) {
          const prefix = diag.severity === "error" ? "ERROR" : "WARNING";
          const loc = diag.node ? ` at ${sourceFile.fileName}:${sourceFile.getLineAndCharacterOfPosition(start).line + 1}` : "";
          console.log(`[typemacro ${prefix}]${loc} ${diag.message}`);
        }
      }
      return result;
    };
  };
}
var MacroTransformer = class {
  constructor(ctx, verbose) {
    this.ctx = ctx;
    this.verbose = verbose;
  }
  additionalStatements = [];
  /**
   * Visit a node and potentially transform it
   */
  visit(node) {
    const transformed = this.tryTransform(node);
    if (transformed !== void 0) {
      return transformed;
    }
    return ts6.visitEachChild(
      node,
      this.visit.bind(this),
      this.ctx.transformContext
    );
  }
  /**
   * Try to transform a node if it's a macro invocation
   */
  tryTransform(node) {
    if (ts6.isCallExpression(node)) {
      const result = this.tryExpandExpressionMacro(node);
      if (result !== void 0) {
        return result;
      }
    }
    if (this.hasDecorators(node)) {
      const result = this.tryExpandAttributeMacros(node);
      if (result !== void 0) {
        return result;
      }
    }
    if (ts6.isTaggedTemplateExpression(node)) {
      const result = this.tryExpandTaggedTemplate(node);
      if (result !== void 0) {
        return result;
      }
    }
    if (ts6.isTypeReferenceNode(node)) {
      const result = this.tryExpandTypeMacro(node);
      if (result !== void 0) {
        return result;
      }
    }
    return void 0;
  }
  /**
   * Check if a node has decorators
   */
  hasDecorators(node) {
    return ts6.canHaveDecorators(node) && ts6.getDecorators(node) !== void 0;
  }
  /**
   * Try to expand an expression macro
   */
  tryExpandExpressionMacro(node) {
    let macroName;
    if (ts6.isIdentifier(node.expression)) {
      macroName = node.expression.text;
    } else if (ts6.isPropertyAccessExpression(node.expression)) {
      if (ts6.isIdentifier(node.expression.expression) && node.expression.expression.text === "macro") {
        macroName = node.expression.name.text;
      }
    }
    if (!macroName) return void 0;
    const macro = globalRegistry.getExpression(macroName);
    if (!macro) return void 0;
    if (this.verbose) {
      console.log(`[typemacro] Expanding expression macro: ${macroName}`);
    }
    try {
      const result = macro.expand(this.ctx, node, node.arguments);
      return ts6.visitNode(result, this.visit.bind(this));
    } catch (error) {
      this.ctx.reportError(node, `Macro expansion failed: ${error}`);
      return this.createMacroErrorExpression(
        `typemacro: expansion of '${macroName}' failed: ${error}`
      );
    }
  }
  /**
   * Try to expand attribute macros on a declaration
   */
  tryExpandAttributeMacros(node) {
    const decorators = ts6.getDecorators(node);
    if (!decorators || decorators.length === 0) return void 0;
    let currentNode = node;
    const extraStatements = [];
    const remainingDecorators = [];
    let wasTransformed = false;
    for (const decorator of decorators) {
      const { macroName, args } = this.parseDecorator(decorator);
      if (macroName === "derive") {
        const derives = this.expandDeriveDecorator(decorator, node, args);
        if (derives) {
          extraStatements.push(...derives);
          wasTransformed = true;
          continue;
        }
      }
      const macro = globalRegistry.getAttribute(macroName);
      if (macro) {
        if (this.verbose) {
          console.log(`[typemacro] Expanding attribute macro: ${macroName}`);
        }
        try {
          const result = macro.expand(
            this.ctx,
            decorator,
            currentNode,
            args
          );
          if (Array.isArray(result)) {
            if (result.length > 0) {
              currentNode = result[0];
              extraStatements.push(...result.slice(1).filter(ts6.isStatement));
            }
          } else {
            currentNode = result;
          }
          wasTransformed = true;
        } catch (error) {
          this.ctx.reportError(
            decorator,
            `Attribute macro expansion failed: ${error}`
          );
          extraStatements.push(
            this.createMacroErrorStatement(
              `typemacro: attribute macro '${macroName}' failed: ${error}`
            )
          );
          remainingDecorators.push(decorator);
          wasTransformed = true;
        }
      } else {
        remainingDecorators.push(decorator);
      }
    }
    if (!wasTransformed) return void 0;
    if (remainingDecorators.length !== decorators.length) {
      currentNode = this.updateDecorators(currentNode, remainingDecorators);
    }
    const visited = ts6.visitNode(currentNode, this.visit.bind(this));
    if (extraStatements.length > 0) {
      return [visited, ...extraStatements];
    }
    return visited;
  }
  /**
   * Parse a decorator to extract macro name and arguments
   */
  parseDecorator(decorator) {
    const expr = decorator.expression;
    if (ts6.isIdentifier(expr)) {
      return { macroName: expr.text, args: [] };
    }
    if (ts6.isCallExpression(expr)) {
      if (ts6.isIdentifier(expr.expression)) {
        return {
          macroName: expr.expression.text,
          args: Array.from(expr.arguments)
        };
      }
    }
    return { macroName: "", args: [] };
  }
  /**
   * Expand @derive decorator
   */
  expandDeriveDecorator(decorator, node, args) {
    if (!ts6.isInterfaceDeclaration(node) && !ts6.isClassDeclaration(node) && !ts6.isTypeAliasDeclaration(node)) {
      this.ctx.reportError(
        decorator,
        "@derive can only be applied to interfaces, classes, or type aliases"
      );
      return void 0;
    }
    const statements = [];
    const typeInfo = this.extractTypeInfo(node);
    for (const arg of args) {
      if (!ts6.isIdentifier(arg)) {
        this.ctx.reportError(arg, "derive arguments must be identifiers");
        continue;
      }
      const deriveName = arg.text;
      const macro = globalRegistry.getDerive(deriveName);
      if (!macro) {
        this.ctx.reportError(arg, `Unknown derive macro: ${deriveName}`);
        continue;
      }
      if (this.verbose) {
        console.log(`[typemacro] Expanding derive macro: ${deriveName}`);
      }
      try {
        const result = macro.expand(this.ctx, node, typeInfo);
        statements.push(...result);
      } catch (error) {
        this.ctx.reportError(arg, `Derive macro expansion failed: ${error}`);
      }
    }
    return statements.length > 0 ? statements : void 0;
  }
  /**
   * Extract type information for derive macros
   */
  extractTypeInfo(node) {
    const name = node.name?.text ?? "Anonymous";
    const type = this.ctx.typeChecker.getTypeAtLocation(node);
    const typeParameters = node.typeParameters ? Array.from(node.typeParameters) : [];
    const fields = [];
    const properties = this.ctx.typeChecker.getPropertiesOfType(type);
    for (const prop of properties) {
      const declarations = prop.getDeclarations();
      if (!declarations || declarations.length === 0) continue;
      const decl = declarations[0];
      const propType = this.ctx.typeChecker.getTypeOfSymbolAtLocation(
        prop,
        decl
      );
      const propTypeString = this.ctx.typeChecker.typeToString(propType);
      const optional = (prop.flags & ts6.SymbolFlags.Optional) !== 0;
      const readonly = ts6.isPropertyDeclaration(decl) || ts6.isPropertySignature(decl) ? decl.modifiers?.some(
        (m) => m.kind === ts6.SyntaxKind.ReadonlyKeyword
      ) ?? false : false;
      fields.push({
        name: prop.name,
        typeString: propTypeString,
        type: propType,
        optional,
        readonly
      });
    }
    return { name, fields, typeParameters, type };
  }
  /**
   * Try to expand a tagged template expression
   */
  tryExpandTaggedTemplate(node) {
    if (!ts6.isIdentifier(node.tag)) return void 0;
    const tagName = node.tag.text;
    const taggedMacro = globalRegistry.getTaggedTemplate(tagName);
    if (taggedMacro) {
      if (this.verbose) {
        console.log(`[typemacro] Expanding tagged template macro: ${tagName}`);
      }
      try {
        if (taggedMacro.validate && !taggedMacro.validate(this.ctx, node)) {
          this.ctx.reportError(
            node,
            `Tagged template validation failed for '${tagName}'`
          );
          return this.createMacroErrorExpression(
            `typemacro: tagged template '${tagName}' validation failed`
          );
        }
        const result = taggedMacro.expand(this.ctx, node);
        return ts6.visitNode(result, this.visit.bind(this));
      } catch (error) {
        this.ctx.reportError(
          node,
          `Tagged template macro expansion failed: ${error}`
        );
        return this.createMacroErrorExpression(
          `typemacro: tagged template '${tagName}' expansion failed: ${error}`
        );
      }
    }
    const exprMacro = globalRegistry.getExpression(tagName);
    if (!exprMacro) return void 0;
    if (this.verbose) {
      console.log(
        `[typemacro] Expanding tagged template via expression macro: ${tagName}`
      );
    }
    try {
      const result = exprMacro.expand(
        this.ctx,
        node,
        [node.template]
      );
      return ts6.visitNode(result, this.visit.bind(this));
    } catch (error) {
      this.ctx.reportError(
        node,
        `Tagged template macro expansion failed: ${error}`
      );
      return this.createMacroErrorExpression(
        `typemacro: tagged template '${tagName}' expansion failed: ${error}`
      );
    }
  }
  /**
   * Try to expand a type macro (type-level macros like Add<3, 4>)
   */
  tryExpandTypeMacro(node) {
    let macroName;
    if (ts6.isIdentifier(node.typeName)) {
      macroName = node.typeName.text;
    } else if (ts6.isQualifiedName(node.typeName)) {
      if (ts6.isIdentifier(node.typeName.left) && node.typeName.left.text === "typemacro") {
        macroName = node.typeName.right.text;
      }
    }
    if (!macroName) return void 0;
    const macro = globalRegistry.getType(macroName);
    if (!macro) return void 0;
    if (this.verbose) {
      console.log(`[typemacro] Expanding type macro: ${macroName}`);
    }
    try {
      const typeArgs = node.typeArguments ? Array.from(node.typeArguments) : [];
      const result = macro.expand(this.ctx, node, typeArgs);
      return ts6.visitNode(result, this.visit.bind(this));
    } catch (error) {
      this.ctx.reportError(node, `Type macro expansion failed: ${error}`);
      return node;
    }
  }
  /**
   * Create an expression that throws at runtime when a macro expansion fails.
   * This ensures failures are loud rather than silently producing broken output.
   */
  createMacroErrorExpression(message) {
    const factory = this.ctx.factory;
    return factory.createCallExpression(
      factory.createParenthesizedExpression(
        factory.createArrowFunction(
          void 0,
          void 0,
          [],
          void 0,
          factory.createToken(ts6.SyntaxKind.EqualsGreaterThanToken),
          factory.createBlock([
            factory.createThrowStatement(
              factory.createNewExpression(
                factory.createIdentifier("Error"),
                void 0,
                [factory.createStringLiteral(message)]
              )
            )
          ])
        )
      ),
      void 0,
      []
    );
  }
  /**
   * Create a statement that throws at runtime when a macro expansion fails.
   */
  createMacroErrorStatement(message) {
    const factory = this.ctx.factory;
    return factory.createThrowStatement(
      factory.createNewExpression(
        factory.createIdentifier("Error"),
        void 0,
        [factory.createStringLiteral(message)]
      )
    );
  }
  /**
   * Update a node with new decorators
   */
  updateDecorators(node, decorators) {
    const modifiers = decorators.length > 0 ? decorators : void 0;
    const factory = this.ctx.factory;
    if (ts6.isClassDeclaration(node)) {
      return factory.updateClassDeclaration(
        node,
        modifiers ? [
          ...modifiers,
          ...node.modifiers?.filter((m) => !ts6.isDecorator(m)) ?? []
        ] : node.modifiers?.filter((m) => !ts6.isDecorator(m)),
        node.name,
        node.typeParameters,
        node.heritageClauses,
        node.members
      );
    }
    if (ts6.isFunctionDeclaration(node)) {
      return factory.updateFunctionDeclaration(
        node,
        modifiers ? [
          ...modifiers,
          ...node.modifiers?.filter((m) => !ts6.isDecorator(m)) ?? []
        ] : node.modifiers?.filter((m) => !ts6.isDecorator(m)),
        node.asteriskToken,
        node.name,
        node.typeParameters,
        node.parameters,
        node.type,
        node.body
      );
    }
    if (ts6.isMethodDeclaration(node)) {
      return factory.updateMethodDeclaration(
        node,
        modifiers ? [
          ...modifiers,
          ...node.modifiers?.filter((m) => !ts6.isDecorator(m)) ?? []
        ] : node.modifiers?.filter((m) => !ts6.isDecorator(m)),
        node.asteriskToken,
        node.name,
        node.questionToken,
        node.typeParameters,
        node.parameters,
        node.type,
        node.body
      );
    }
    if (ts6.isInterfaceDeclaration(node)) {
      return node;
    }
    return node;
  }
};

// src/integrations/unplugin.ts
function findTsConfig(cwd, explicit) {
  if (explicit) {
    return path.resolve(cwd, explicit);
  }
  const found = ts7.findConfigFile(cwd, ts7.sys.fileExists, "tsconfig.json");
  if (!found) {
    throw new Error(
      `[typemacro] Could not find tsconfig.json from ${cwd}. Pass the tsconfig option to specify the path explicitly.`
    );
  }
  return found;
}
function createProgram2(configPath) {
  const configFile = ts7.readConfigFile(configPath, ts7.sys.readFile);
  if (configFile.error) {
    throw new Error(
      `[typemacro] Error reading ${configPath}: ${ts7.flattenDiagnosticMessageText(configFile.error.messageText, "\n")}`
    );
  }
  const config = ts7.parseJsonConfigFileContent(
    configFile.config,
    ts7.sys,
    path.dirname(configPath)
  );
  const host = ts7.createCompilerHost(config.options);
  const program = ts7.createProgram(config.fileNames, config.options, host);
  return { program, host, config };
}
function shouldTransform(id, include, exclude) {
  const normalizedId = id.replace(/\\/g, "/");
  if (exclude) {
    if (exclude instanceof RegExp) {
      if (exclude.test(normalizedId)) return false;
    } else {
      if (exclude.some((pattern) => normalizedId.includes(pattern)))
        return false;
    }
  } else {
    if (/node_modules/.test(normalizedId)) return false;
  }
  if (include) {
    if (include instanceof RegExp) {
      return include.test(normalizedId);
    }
    return include.some((pattern) => normalizedId.includes(pattern));
  }
  return /\.[jt]sx?$/.test(normalizedId);
}
var unpluginFactory = (options = {}) => {
  let cache;
  const verbose = options?.verbose ?? false;
  return {
    name: "typemacro",
    enforce: "pre",
    buildStart() {
      try {
        const configPath = findTsConfig(process.cwd(), options?.tsconfig);
        cache = createProgram2(configPath);
        if (verbose) {
          console.log(`[typemacro] Loaded config from ${configPath}`);
          console.log(
            `[typemacro] Program has ${cache.config.fileNames.length} files`
          );
        }
      } catch (error) {
        console.error(String(error));
      }
    },
    transformInclude(id) {
      return shouldTransform(id, options?.include, options?.exclude);
    },
    transform(code, id) {
      if (!cache) return null;
      const sourceFile = cache.program.getSourceFile(id);
      if (!sourceFile) {
        if (verbose) {
          console.log(`[typemacro] Skipping ${id} (not in program)`);
        }
        return null;
      }
      const transformerConfig = { verbose };
      const result = ts7.transform(sourceFile, [
        macroTransformerFactory(cache.program, transformerConfig)
      ]);
      if (result.transformed.length === 0) {
        result.dispose();
        return null;
      }
      const printer = ts7.createPrinter({ newLine: ts7.NewLineKind.LineFeed });
      const transformed = printer.printFile(result.transformed[0]);
      result.dispose();
      if (transformed === code) return null;
      return {
        code: transformed,
        // TODO: generate proper source map from the transformation
        map: null
      };
    }
  };
};
var unplugin = /* @__PURE__ */ (0, import_unplugin.createUnplugin)(unpluginFactory);

// src/integrations/webpack.ts
var webpack_default = unplugin.webpack;
//# sourceMappingURL=webpack.cjs.map