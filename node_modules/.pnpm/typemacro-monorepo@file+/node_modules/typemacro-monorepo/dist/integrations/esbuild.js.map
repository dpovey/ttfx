{"version":3,"sources":["../../src/integrations/unplugin.ts","../../src/transforms/macro-transformer.ts","../../src/core/context.ts","../../src/core/registry.ts","../../src/macros/comptime.ts","../../src/macros/derive.ts","../../src/macros/operators.ts","../../src/macros/reflect.ts","../../src/macros/typeclass.ts","../../src/integrations/esbuild.ts"],"sourcesContent":["/**\n * typemacro unplugin integration\n *\n * Universal plugin that works with Vite, Rollup, Webpack, esbuild, and Rspack.\n * Uses the TypeScript compiler API to create a Program, then runs the macro\n * transformer on each .ts/.tsx file during the build.\n */\n\nimport * as ts from \"typescript\";\nimport * as path from \"path\";\nimport { createUnplugin, type UnpluginFactory } from \"unplugin\";\nimport macroTransformerFactory, {\n  type MacroTransformerConfig,\n} from \"../transforms/macro-transformer.js\";\n\nexport interface TypeMacroPluginOptions {\n  /** Path to tsconfig.json (default: auto-detected) */\n  tsconfig?: string;\n\n  /** File patterns to include (default: /\\.[jt]sx?$/) */\n  include?: RegExp | string[];\n\n  /** File patterns to exclude (default: /node_modules/) */\n  exclude?: RegExp | string[];\n\n  /** Enable verbose logging */\n  verbose?: boolean;\n}\n\ninterface ProgramCache {\n  program: ts.Program;\n  host: ts.CompilerHost;\n  config: ts.ParsedCommandLine;\n}\n\nfunction findTsConfig(cwd: string, explicit?: string): string {\n  if (explicit) {\n    return path.resolve(cwd, explicit);\n  }\n\n  const found = ts.findConfigFile(cwd, ts.sys.fileExists, \"tsconfig.json\");\n  if (!found) {\n    throw new Error(\n      `[typemacro] Could not find tsconfig.json from ${cwd}. ` +\n        `Pass the tsconfig option to specify the path explicitly.`,\n    );\n  }\n  return found;\n}\n\nfunction createProgram(configPath: string): ProgramCache {\n  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);\n  if (configFile.error) {\n    throw new Error(\n      `[typemacro] Error reading ${configPath}: ${ts.flattenDiagnosticMessageText(configFile.error.messageText, \"\\n\")}`,\n    );\n  }\n\n  const config = ts.parseJsonConfigFileContent(\n    configFile.config,\n    ts.sys,\n    path.dirname(configPath),\n  );\n\n  const host = ts.createCompilerHost(config.options);\n  const program = ts.createProgram(config.fileNames, config.options, host);\n\n  return { program, host, config };\n}\n\nfunction shouldTransform(\n  id: string,\n  include?: RegExp | string[],\n  exclude?: RegExp | string[],\n): boolean {\n  const normalizedId = id.replace(/\\\\/g, \"/\");\n\n  // Check exclude first\n  if (exclude) {\n    if (exclude instanceof RegExp) {\n      if (exclude.test(normalizedId)) return false;\n    } else {\n      if (exclude.some((pattern) => normalizedId.includes(pattern)))\n        return false;\n    }\n  } else {\n    if (/node_modules/.test(normalizedId)) return false;\n  }\n\n  // Check include\n  if (include) {\n    if (include instanceof RegExp) {\n      return include.test(normalizedId);\n    }\n    return include.some((pattern) => normalizedId.includes(pattern));\n  }\n\n  return /\\.[jt]sx?$/.test(normalizedId);\n}\n\nexport const unpluginFactory: UnpluginFactory<\n  TypeMacroPluginOptions | undefined\n> = (options = {}) => {\n  let cache: ProgramCache | undefined;\n  const verbose = options?.verbose ?? false;\n\n  return {\n    name: \"typemacro\",\n    enforce: \"pre\",\n\n    buildStart() {\n      try {\n        const configPath = findTsConfig(process.cwd(), options?.tsconfig);\n        cache = createProgram(configPath);\n        if (verbose) {\n          console.log(`[typemacro] Loaded config from ${configPath}`);\n          console.log(\n            `[typemacro] Program has ${cache.config.fileNames.length} files`,\n          );\n        }\n      } catch (error) {\n        console.error(String(error));\n      }\n    },\n\n    transformInclude(id) {\n      return shouldTransform(id, options?.include, options?.exclude);\n    },\n\n    transform(code, id) {\n      if (!cache) return null;\n\n      const sourceFile = cache.program.getSourceFile(id);\n      if (!sourceFile) {\n        // File not in the TS program -- skip\n        if (verbose) {\n          console.log(`[typemacro] Skipping ${id} (not in program)`);\n        }\n        return null;\n      }\n\n      const transformerConfig: MacroTransformerConfig = { verbose };\n\n      // Run the macro transformer\n      const result = ts.transform(sourceFile, [\n        macroTransformerFactory(cache.program, transformerConfig),\n      ]);\n\n      if (result.transformed.length === 0) {\n        result.dispose();\n        return null;\n      }\n\n      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n      const transformed = printer.printFile(result.transformed[0]);\n      result.dispose();\n\n      // Only return if the code actually changed\n      if (transformed === code) return null;\n\n      return {\n        code: transformed,\n        // TODO: generate proper source map from the transformation\n        map: null,\n      };\n    },\n  };\n};\n\nexport const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory);\n","/**\n * typemacro Transformer - Main TypeScript transformer for macro expansion\n *\n * This transformer integrates with ts-patch to process macros during compilation.\n */\n\nimport * as ts from \"typescript\";\nimport { MacroContextImpl, createMacroContext } from \"../core/context.js\";\nimport { globalRegistry } from \"../core/registry.js\";\nimport {\n  ExpressionMacro,\n  AttributeMacro,\n  DeriveMacro,\n  DeriveTypeInfo,\n  DeriveFieldInfo,\n} from \"../core/types.js\";\n\n// Import built-in macros to register them\nimport \"../macros/index.js\";\n\n/**\n * Configuration for the transformer\n */\nexport interface MacroTransformerConfig {\n  /** Enable verbose logging */\n  verbose?: boolean;\n\n  /** Custom macro module paths to load */\n  macroModules?: string[];\n}\n\n/**\n * Create the TypeScript transformer factory\n * This is the entry point called by ts-patch\n */\nexport default function macroTransformerFactory(\n  program: ts.Program,\n  config?: MacroTransformerConfig,\n): ts.TransformerFactory<ts.SourceFile> {\n  const verbose = config?.verbose ?? false;\n\n  if (verbose) {\n    console.log(\"[typemacro] Initializing transformer\");\n    console.log(\n      `[typemacro] Registered macros: ${globalRegistry\n        .getAll()\n        .map((m) => m.name)\n        .join(\", \")}`,\n    );\n  }\n\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile) => {\n      if (verbose) {\n        console.log(`[typemacro] Processing: ${sourceFile.fileName}`);\n      }\n\n      const ctx = createMacroContext(program, sourceFile, context);\n      const transformer = new MacroTransformer(ctx, verbose);\n\n      const result = ts.visitNode(\n        sourceFile,\n        transformer.visit.bind(transformer),\n      );\n\n      // Report diagnostics through the TS diagnostic pipeline\n      const macroDiagnostics = ctx.getDiagnostics();\n      for (const diag of macroDiagnostics) {\n        const start = diag.node ? diag.node.getStart(sourceFile) : 0;\n        const length = diag.node ? diag.node.getWidth(sourceFile) : 0;\n\n        const tsDiag: ts.Diagnostic = {\n          file: sourceFile,\n          start,\n          length,\n          messageText: `[typemacro] ${diag.message}`,\n          category:\n            diag.severity === \"error\"\n              ? ts.DiagnosticCategory.Error\n              : ts.DiagnosticCategory.Warning,\n          code: 90000, // Custom diagnostic code range for typemacro\n          source: \"typemacro\",\n        };\n\n        // Use the transformation context's addDiagnostic if available (TS 5.x+)\n        const ctxWithDiag = context as ts.TransformationContext & {\n          addDiagnostic?: (diag: ts.Diagnostic) => void;\n        };\n        if (ctxWithDiag.addDiagnostic) {\n          ctxWithDiag.addDiagnostic(tsDiag);\n        }\n\n        // Also log for build tools that don't surface TS diagnostics\n        if (verbose) {\n          const prefix = diag.severity === \"error\" ? \"ERROR\" : \"WARNING\";\n          const loc = diag.node\n            ? ` at ${sourceFile.fileName}:${sourceFile.getLineAndCharacterOfPosition(start).line + 1}`\n            : \"\";\n          console.log(`[typemacro ${prefix}]${loc} ${diag.message}`);\n        }\n      }\n\n      return result as ts.SourceFile;\n    };\n  };\n}\n\n/**\n * The main transformer class that handles macro expansion\n */\nclass MacroTransformer {\n  private additionalStatements: ts.Statement[] = [];\n\n  constructor(\n    private ctx: MacroContextImpl,\n    private verbose: boolean,\n  ) {}\n\n  /**\n   * Visit a node and potentially transform it\n   */\n  visit(node: ts.Node): ts.Node | ts.Node[] {\n    // First, check for macro invocations at this node\n    const transformed = this.tryTransform(node);\n    if (transformed !== undefined) {\n      return transformed;\n    }\n\n    // Otherwise, visit children\n    return ts.visitEachChild(\n      node,\n      this.visit.bind(this),\n      this.ctx.transformContext,\n    );\n  }\n\n  /**\n   * Try to transform a node if it's a macro invocation\n   */\n  private tryTransform(node: ts.Node): ts.Node | ts.Node[] | undefined {\n    // Check for expression macros (function calls)\n    if (ts.isCallExpression(node)) {\n      const result = this.tryExpandExpressionMacro(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    // Check for decorated declarations (attribute macros)\n    if (this.hasDecorators(node)) {\n      const result = this.tryExpandAttributeMacros(node as ts.HasDecorators);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    // Check for tagged template expressions\n    if (ts.isTaggedTemplateExpression(node)) {\n      const result = this.tryExpandTaggedTemplate(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    // Check for type reference macros (type-level macros like Add<3, 4>)\n    if (ts.isTypeReferenceNode(node)) {\n      const result = this.tryExpandTypeMacro(node);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Check if a node has decorators\n   */\n  private hasDecorators(node: ts.Node): node is ts.HasDecorators {\n    return ts.canHaveDecorators(node) && ts.getDecorators(node) !== undefined;\n  }\n\n  /**\n   * Try to expand an expression macro\n   */\n  private tryExpandExpressionMacro(\n    node: ts.CallExpression,\n  ): ts.Expression | undefined {\n    // Get the macro name from the call expression\n    let macroName: string | undefined;\n\n    if (ts.isIdentifier(node.expression)) {\n      macroName = node.expression.text;\n    } else if (ts.isPropertyAccessExpression(node.expression)) {\n      // Handle namespaced macros like `macro.comptime()`\n      if (\n        ts.isIdentifier(node.expression.expression) &&\n        node.expression.expression.text === \"macro\"\n      ) {\n        macroName = node.expression.name.text;\n      }\n    }\n\n    if (!macroName) return undefined;\n\n    // Look up the macro\n    const macro = globalRegistry.getExpression(macroName);\n    if (!macro) return undefined;\n\n    if (this.verbose) {\n      console.log(`[typemacro] Expanding expression macro: ${macroName}`);\n    }\n\n    try {\n      const result = macro.expand(this.ctx, node, node.arguments);\n\n      // Visit the result to handle nested macros\n      return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n    } catch (error) {\n      this.ctx.reportError(node, `Macro expansion failed: ${error}`);\n      return this.createMacroErrorExpression(\n        `typemacro: expansion of '${macroName}' failed: ${error}`,\n      );\n    }\n  }\n\n  /**\n   * Try to expand attribute macros on a declaration\n   */\n  private tryExpandAttributeMacros(\n    node: ts.HasDecorators,\n  ): ts.Node | ts.Node[] | undefined {\n    const decorators = ts.getDecorators(node);\n    if (!decorators || decorators.length === 0) return undefined;\n\n    let currentNode: ts.Node = node;\n    const extraStatements: ts.Statement[] = [];\n    const remainingDecorators: ts.Decorator[] = [];\n    let wasTransformed = false;\n\n    for (const decorator of decorators) {\n      const { macroName, args } = this.parseDecorator(decorator);\n\n      // Check for @derive decorator\n      if (macroName === \"derive\") {\n        const derives = this.expandDeriveDecorator(decorator, node, args);\n        if (derives) {\n          extraStatements.push(...derives);\n          wasTransformed = true;\n          continue;\n        }\n      }\n\n      // Check for attribute macro\n      const macro = globalRegistry.getAttribute(macroName);\n      if (macro) {\n        if (this.verbose) {\n          console.log(`[typemacro] Expanding attribute macro: ${macroName}`);\n        }\n\n        try {\n          const result = macro.expand(\n            this.ctx,\n            decorator,\n            currentNode as ts.Declaration,\n            args,\n          );\n\n          if (Array.isArray(result)) {\n            if (result.length > 0) {\n              currentNode = result[0];\n              extraStatements.push(...result.slice(1).filter(ts.isStatement));\n            }\n          } else {\n            currentNode = result;\n          }\n          wasTransformed = true;\n        } catch (error) {\n          this.ctx.reportError(\n            decorator,\n            `Attribute macro expansion failed: ${error}`,\n          );\n          // Emit a diagnostic statement alongside the original node\n          extraStatements.push(\n            this.createMacroErrorStatement(\n              `typemacro: attribute macro '${macroName}' failed: ${error}`,\n            ),\n          );\n          remainingDecorators.push(decorator);\n          wasTransformed = true;\n        }\n      } else {\n        // Keep decorators that aren't macros\n        remainingDecorators.push(decorator);\n      }\n    }\n\n    if (!wasTransformed) return undefined;\n\n    // Update the node with remaining decorators\n    if (remainingDecorators.length !== decorators.length) {\n      currentNode = this.updateDecorators(currentNode, remainingDecorators);\n    }\n\n    // Visit the transformed node\n    const visited = ts.visitNode(currentNode, this.visit.bind(this));\n\n    if (extraStatements.length > 0) {\n      return [visited as ts.Node, ...extraStatements];\n    }\n\n    return visited as ts.Node;\n  }\n\n  /**\n   * Parse a decorator to extract macro name and arguments\n   */\n  private parseDecorator(decorator: ts.Decorator): {\n    macroName: string;\n    args: ts.Expression[];\n  } {\n    const expr = decorator.expression;\n\n    if (ts.isIdentifier(expr)) {\n      return { macroName: expr.text, args: [] };\n    }\n\n    if (ts.isCallExpression(expr)) {\n      if (ts.isIdentifier(expr.expression)) {\n        return {\n          macroName: expr.expression.text,\n          args: Array.from(expr.arguments),\n        };\n      }\n    }\n\n    return { macroName: \"\", args: [] };\n  }\n\n  /**\n   * Expand @derive decorator\n   */\n  private expandDeriveDecorator(\n    decorator: ts.Decorator,\n    node: ts.Node,\n    args: ts.Expression[],\n  ): ts.Statement[] | undefined {\n    if (\n      !ts.isInterfaceDeclaration(node) &&\n      !ts.isClassDeclaration(node) &&\n      !ts.isTypeAliasDeclaration(node)\n    ) {\n      this.ctx.reportError(\n        decorator,\n        \"@derive can only be applied to interfaces, classes, or type aliases\",\n      );\n      return undefined;\n    }\n\n    const statements: ts.Statement[] = [];\n    const typeInfo = this.extractTypeInfo(node);\n\n    for (const arg of args) {\n      if (!ts.isIdentifier(arg)) {\n        this.ctx.reportError(arg, \"derive arguments must be identifiers\");\n        continue;\n      }\n\n      const deriveName = arg.text;\n      const macro = globalRegistry.getDerive(deriveName);\n\n      if (!macro) {\n        this.ctx.reportError(arg, `Unknown derive macro: ${deriveName}`);\n        continue;\n      }\n\n      if (this.verbose) {\n        console.log(`[typemacro] Expanding derive macro: ${deriveName}`);\n      }\n\n      try {\n        const result = macro.expand(this.ctx, node, typeInfo);\n        statements.push(...result);\n      } catch (error) {\n        this.ctx.reportError(arg, `Derive macro expansion failed: ${error}`);\n      }\n    }\n\n    return statements.length > 0 ? statements : undefined;\n  }\n\n  /**\n   * Extract type information for derive macros\n   */\n  private extractTypeInfo(\n    node:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n  ): DeriveTypeInfo {\n    const name = node.name?.text ?? \"Anonymous\";\n    const type = this.ctx.typeChecker.getTypeAtLocation(node);\n    const typeParameters = node.typeParameters\n      ? Array.from(node.typeParameters)\n      : [];\n\n    const fields: DeriveFieldInfo[] = [];\n    const properties = this.ctx.typeChecker.getPropertiesOfType(type);\n\n    for (const prop of properties) {\n      const declarations = prop.getDeclarations();\n      if (!declarations || declarations.length === 0) continue;\n\n      const decl = declarations[0];\n      const propType = this.ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        decl,\n      );\n      const propTypeString = this.ctx.typeChecker.typeToString(propType);\n\n      const optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n      const readonly =\n        ts.isPropertyDeclaration(decl) || ts.isPropertySignature(decl)\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false;\n\n      fields.push({\n        name: prop.name,\n        typeString: propTypeString,\n        type: propType,\n        optional,\n        readonly,\n      });\n    }\n\n    return { name, fields, typeParameters, type };\n  }\n\n  /**\n   * Try to expand a tagged template expression\n   */\n  private tryExpandTaggedTemplate(\n    node: ts.TaggedTemplateExpression,\n  ): ts.Expression | undefined {\n    if (!ts.isIdentifier(node.tag)) return undefined;\n\n    const tagName = node.tag.text;\n\n    // First check the dedicated tagged template registry\n    const taggedMacro = globalRegistry.getTaggedTemplate(tagName);\n    if (taggedMacro) {\n      if (this.verbose) {\n        console.log(`[typemacro] Expanding tagged template macro: ${tagName}`);\n      }\n\n      try {\n        // Run validation if provided\n        if (taggedMacro.validate && !taggedMacro.validate(this.ctx, node)) {\n          this.ctx.reportError(\n            node,\n            `Tagged template validation failed for '${tagName}'`,\n          );\n          return this.createMacroErrorExpression(\n            `typemacro: tagged template '${tagName}' validation failed`,\n          );\n        }\n\n        const result = taggedMacro.expand(this.ctx, node);\n        return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n      } catch (error) {\n        this.ctx.reportError(\n          node,\n          `Tagged template macro expansion failed: ${error}`,\n        );\n        return this.createMacroErrorExpression(\n          `typemacro: tagged template '${tagName}' expansion failed: ${error}`,\n        );\n      }\n    }\n\n    // Fall back to expression macros for backward compatibility\n    const exprMacro = globalRegistry.getExpression(tagName);\n    if (!exprMacro) return undefined;\n\n    if (this.verbose) {\n      console.log(\n        `[typemacro] Expanding tagged template via expression macro: ${tagName}`,\n      );\n    }\n\n    try {\n      const result = exprMacro.expand(\n        this.ctx,\n        node as unknown as ts.CallExpression,\n        [node.template as unknown as ts.Expression],\n      );\n      return ts.visitNode(result, this.visit.bind(this)) as ts.Expression;\n    } catch (error) {\n      this.ctx.reportError(\n        node,\n        `Tagged template macro expansion failed: ${error}`,\n      );\n      return this.createMacroErrorExpression(\n        `typemacro: tagged template '${tagName}' expansion failed: ${error}`,\n      );\n    }\n  }\n\n  /**\n   * Try to expand a type macro (type-level macros like Add<3, 4>)\n   */\n  private tryExpandTypeMacro(\n    node: ts.TypeReferenceNode,\n  ): ts.TypeNode | undefined {\n    let macroName: string | undefined;\n\n    if (ts.isIdentifier(node.typeName)) {\n      macroName = node.typeName.text;\n    } else if (ts.isQualifiedName(node.typeName)) {\n      // Handle namespaced type macros like typemacro.Add\n      if (\n        ts.isIdentifier(node.typeName.left) &&\n        node.typeName.left.text === \"typemacro\"\n      ) {\n        macroName = node.typeName.right.text;\n      }\n    }\n\n    if (!macroName) return undefined;\n\n    const macro = globalRegistry.getType(macroName);\n    if (!macro) return undefined;\n\n    if (this.verbose) {\n      console.log(`[typemacro] Expanding type macro: ${macroName}`);\n    }\n\n    try {\n      const typeArgs = node.typeArguments\n        ? Array.from(node.typeArguments)\n        : [];\n      const result = macro.expand(this.ctx, node, typeArgs);\n      return ts.visitNode(result, this.visit.bind(this)) as ts.TypeNode;\n    } catch (error) {\n      this.ctx.reportError(node, `Type macro expansion failed: ${error}`);\n      // Return the original node unchanged on failure\n      return node;\n    }\n  }\n\n  /**\n   * Create an expression that throws at runtime when a macro expansion fails.\n   * This ensures failures are loud rather than silently producing broken output.\n   */\n  private createMacroErrorExpression(message: string): ts.Expression {\n    const factory = this.ctx.factory;\n    // Generates: (() => { throw new Error(\"message\"); })()\n    return factory.createCallExpression(\n      factory.createParenthesizedExpression(\n        factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          factory.createBlock([\n            factory.createThrowStatement(\n              factory.createNewExpression(\n                factory.createIdentifier(\"Error\"),\n                undefined,\n                [factory.createStringLiteral(message)],\n              ),\n            ),\n          ]),\n        ),\n      ),\n      undefined,\n      [],\n    );\n  }\n\n  /**\n   * Create a statement that throws at runtime when a macro expansion fails.\n   */\n  private createMacroErrorStatement(message: string): ts.Statement {\n    const factory = this.ctx.factory;\n    return factory.createThrowStatement(\n      factory.createNewExpression(\n        factory.createIdentifier(\"Error\"),\n        undefined,\n        [factory.createStringLiteral(message)],\n      ),\n    );\n  }\n\n  /**\n   * Update a node with new decorators\n   */\n  private updateDecorators(node: ts.Node, decorators: ts.Decorator[]): ts.Node {\n    const modifiers = decorators.length > 0 ? decorators : undefined;\n    const factory = this.ctx.factory;\n\n    if (ts.isClassDeclaration(node)) {\n      return factory.updateClassDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.name,\n        node.typeParameters,\n        node.heritageClauses,\n        node.members,\n      );\n    }\n\n    if (ts.isFunctionDeclaration(node)) {\n      return factory.updateFunctionDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.asteriskToken,\n        node.name,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.body,\n      );\n    }\n\n    if (ts.isMethodDeclaration(node)) {\n      return factory.updateMethodDeclaration(\n        node,\n        modifiers\n          ? [\n              ...modifiers,\n              ...(node.modifiers?.filter((m) => !ts.isDecorator(m)) ?? []),\n            ]\n          : node.modifiers?.filter((m) => !ts.isDecorator(m)),\n        node.asteriskToken,\n        node.name,\n        node.questionToken,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.body,\n      );\n    }\n\n    // For interfaces, we can't have decorators in the output\n    if (ts.isInterfaceDeclaration(node)) {\n      return node;\n    }\n\n    return node;\n  }\n}\n\n// Also export for programmatic use\nexport { MacroTransformer };\n","/**\n * MacroContext Implementation - Provides utilities for macro expansion\n */\n\nimport * as ts from \"typescript\";\nimport { MacroContext, ComptimeValue, MacroDiagnostic } from \"./types.js\";\n\nexport class MacroContextImpl implements MacroContext {\n  private diagnostics: MacroDiagnostic[] = [];\n  private uniqueNameCounter = 0;\n\n  constructor(\n    public readonly program: ts.Program,\n    public readonly typeChecker: ts.TypeChecker,\n    public readonly sourceFile: ts.SourceFile,\n    public readonly factory: ts.NodeFactory,\n    public readonly transformContext: ts.TransformationContext,\n  ) {}\n\n  // -------------------------------------------------------------------------\n  // Node Creation Utilities\n  // -------------------------------------------------------------------------\n\n  createIdentifier(name: string): ts.Identifier {\n    return this.factory.createIdentifier(name);\n  }\n\n  createNumericLiteral(value: number): ts.NumericLiteral {\n    return this.factory.createNumericLiteral(value);\n  }\n\n  createStringLiteral(value: string): ts.StringLiteral {\n    return this.factory.createStringLiteral(value);\n  }\n\n  createBooleanLiteral(value: boolean): ts.Expression {\n    return value ? this.factory.createTrue() : this.factory.createFalse();\n  }\n\n  createArrayLiteral(elements: ts.Expression[]): ts.ArrayLiteralExpression {\n    return this.factory.createArrayLiteralExpression(elements);\n  }\n\n  createObjectLiteral(\n    properties: Array<{ name: string; value: ts.Expression }>,\n  ): ts.ObjectLiteralExpression {\n    const propAssignments = properties.map(({ name, value }) =>\n      this.factory.createPropertyAssignment(\n        this.factory.createIdentifier(name),\n        value,\n      ),\n    );\n    return this.factory.createObjectLiteralExpression(propAssignments, true);\n  }\n\n  parseExpression(code: string): ts.Expression {\n    // Create a temporary source file to parse the expression\n    const tempSource = ts.createSourceFile(\n      \"__macro_temp__.ts\",\n      `const __expr__ = ${code};`,\n      ts.ScriptTarget.Latest,\n      true,\n      ts.ScriptKind.TS,\n    );\n\n    // Extract the expression from the variable declaration\n    const statement = tempSource.statements[0];\n    if (ts.isVariableStatement(statement)) {\n      const declaration = statement.declarationList.declarations[0];\n      if (declaration.initializer) {\n        return declaration.initializer;\n      }\n    }\n\n    throw new Error(`Failed to parse expression: ${code}`);\n  }\n\n  parseStatements(code: string): ts.Statement[] {\n    const tempSource = ts.createSourceFile(\n      \"__macro_temp__.ts\",\n      code,\n      ts.ScriptTarget.Latest,\n      true,\n      ts.ScriptKind.TS,\n    );\n    return Array.from(tempSource.statements);\n  }\n\n  // -------------------------------------------------------------------------\n  // Type Utilities\n  // -------------------------------------------------------------------------\n\n  getTypeOf(node: ts.Node): ts.Type {\n    return this.typeChecker.getTypeAtLocation(node);\n  }\n\n  getTypeString(node: ts.Node): string {\n    const type = this.getTypeOf(node);\n    return this.typeChecker.typeToString(type);\n  }\n\n  isAssignableTo(source: ts.Type, target: ts.Type): boolean {\n    return this.typeChecker.isTypeAssignableTo(source, target);\n  }\n\n  getPropertiesOfType(type: ts.Type): ts.Symbol[] {\n    return this.typeChecker.getPropertiesOfType(type);\n  }\n\n  getSymbol(node: ts.Node): ts.Symbol | undefined {\n    return this.typeChecker.getSymbolAtLocation(node);\n  }\n\n  // -------------------------------------------------------------------------\n  // Diagnostics\n  // -------------------------------------------------------------------------\n\n  reportError(node: ts.Node, message: string): void {\n    this.diagnostics.push({\n      severity: \"error\",\n      message,\n      node,\n    });\n  }\n\n  reportWarning(node: ts.Node, message: string): void {\n    this.diagnostics.push({\n      severity: \"warning\",\n      message,\n      node,\n    });\n  }\n\n  getDiagnostics(): MacroDiagnostic[] {\n    return [...this.diagnostics];\n  }\n\n  clearDiagnostics(): void {\n    this.diagnostics = [];\n  }\n\n  // -------------------------------------------------------------------------\n  // Compile-Time Evaluation\n  // -------------------------------------------------------------------------\n\n  evaluate(node: ts.Node): ComptimeValue {\n    return this.evaluateNode(node);\n  }\n\n  isComptime(node: ts.Node): boolean {\n    // Check if a node can be evaluated at compile time\n    if (ts.isLiteralExpression(node)) {\n      return true;\n    }\n\n    if (ts.isArrayLiteralExpression(node)) {\n      return node.elements.every((e) => this.isComptime(e));\n    }\n\n    if (ts.isObjectLiteralExpression(node)) {\n      return node.properties.every((p) => {\n        if (ts.isPropertyAssignment(p)) {\n          return this.isComptime(p.initializer);\n        }\n        return false;\n      });\n    }\n\n    if (ts.isBinaryExpression(node)) {\n      return this.isComptime(node.left) && this.isComptime(node.right);\n    }\n\n    if (ts.isPrefixUnaryExpression(node) || ts.isPostfixUnaryExpression(node)) {\n      return this.isComptime(node.operand);\n    }\n\n    if (ts.isConditionalExpression(node)) {\n      return (\n        this.isComptime(node.condition) &&\n        this.isComptime(node.whenTrue) &&\n        this.isComptime(node.whenFalse)\n      );\n    }\n\n    if (ts.isParenthesizedExpression(node)) {\n      return this.isComptime(node.expression);\n    }\n\n    // Identifiers are comptime only if they refer to const values\n    if (ts.isIdentifier(node)) {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n      if (symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0) {\n          const decl = declarations[0];\n          if (ts.isVariableDeclaration(decl)) {\n            const parent = decl.parent;\n            if (ts.isVariableDeclarationList(parent)) {\n              if (parent.flags & ts.NodeFlags.Const) {\n                return decl.initializer\n                  ? this.isComptime(decl.initializer)\n                  : false;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private evaluateNode(node: ts.Node): ComptimeValue {\n    // Numeric literals\n    if (ts.isNumericLiteral(node)) {\n      return { kind: \"number\", value: parseFloat(node.text) };\n    }\n\n    // String literals\n    if (ts.isStringLiteral(node)) {\n      return { kind: \"string\", value: node.text };\n    }\n\n    // Boolean literals\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return { kind: \"boolean\", value: true };\n    }\n    if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return { kind: \"boolean\", value: false };\n    }\n\n    // Null/undefined\n    if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return { kind: \"null\" };\n    }\n    if (node.kind === ts.SyntaxKind.UndefinedKeyword) {\n      return { kind: \"undefined\" };\n    }\n\n    // Array literals\n    if (ts.isArrayLiteralExpression(node)) {\n      const elements = node.elements.map((e) => this.evaluateNode(e));\n      const hasError = elements.find((e) => e.kind === \"error\");\n      if (hasError) return hasError;\n      return { kind: \"array\", elements };\n    }\n\n    // Object literals\n    if (ts.isObjectLiteralExpression(node)) {\n      const properties = new Map<string, ComptimeValue>();\n      for (const prop of node.properties) {\n        if (ts.isPropertyAssignment(prop)) {\n          const name = ts.isIdentifier(prop.name)\n            ? prop.name.text\n            : ts.isStringLiteral(prop.name)\n              ? prop.name.text\n              : null;\n          if (name) {\n            const value = this.evaluateNode(prop.initializer);\n            if (value.kind === \"error\") return value;\n            properties.set(name, value);\n          }\n        }\n      }\n      return { kind: \"object\", properties };\n    }\n\n    // Parenthesized expressions\n    if (ts.isParenthesizedExpression(node)) {\n      return this.evaluateNode(node.expression);\n    }\n\n    // Binary expressions\n    if (ts.isBinaryExpression(node)) {\n      return this.evaluateBinaryExpression(node);\n    }\n\n    // Prefix unary expressions\n    if (ts.isPrefixUnaryExpression(node)) {\n      return this.evaluatePrefixUnary(node);\n    }\n\n    // Conditional expressions (ternary)\n    if (ts.isConditionalExpression(node)) {\n      const condition = this.evaluateNode(node.condition);\n      if (condition.kind === \"error\") return condition;\n      const condValue = this.comptimeToBoolean(condition);\n      if (condValue === null) {\n        return { kind: \"error\", message: \"Cannot convert to boolean\" };\n      }\n      return condValue\n        ? this.evaluateNode(node.whenTrue)\n        : this.evaluateNode(node.whenFalse);\n    }\n\n    // Template literals (simple case)\n    if (ts.isTemplateExpression(node)) {\n      let result = node.head.text;\n      for (const span of node.templateSpans) {\n        const value = this.evaluateNode(span.expression);\n        if (value.kind === \"error\") return value;\n        result += this.comptimeToString(value) + span.literal.text;\n      }\n      return { kind: \"string\", value: result };\n    }\n\n    if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return { kind: \"string\", value: node.text };\n    }\n\n    // Arrow functions - return as function value for later evaluation\n    if (ts.isArrowFunction(node)) {\n      return {\n        kind: \"function\",\n        fn: (..._args: ComptimeValue[]) => {\n          // For now, we only support simple arrow functions\n          if (ts.isBlock(node.body)) {\n            return {\n              kind: \"error\",\n              message: \"Block body arrow functions not yet supported\",\n            };\n          }\n          return this.evaluateNode(node.body);\n        },\n      };\n    }\n\n    // Call expressions - evaluate function calls at compile time\n    if (ts.isCallExpression(node)) {\n      const fn = this.evaluateNode(node.expression);\n      if (fn.kind === \"function\") {\n        const args = node.arguments.map((a) => this.evaluateNode(a));\n        const errorArg = args.find((a) => a.kind === \"error\");\n        if (errorArg) return errorArg;\n        return fn.fn(...args);\n      }\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot evaluate node of kind ${ts.SyntaxKind[node.kind]} at compile time`,\n    };\n  }\n\n  private evaluateBinaryExpression(node: ts.BinaryExpression): ComptimeValue {\n    const left = this.evaluateNode(node.left);\n    const right = this.evaluateNode(node.right);\n\n    if (left.kind === \"error\") return left;\n    if (right.kind === \"error\") return right;\n\n    const op = node.operatorToken.kind;\n\n    // Numeric operations\n    if (left.kind === \"number\" && right.kind === \"number\") {\n      switch (op) {\n        case ts.SyntaxKind.PlusToken:\n          return { kind: \"number\", value: left.value + right.value };\n        case ts.SyntaxKind.MinusToken:\n          return { kind: \"number\", value: left.value - right.value };\n        case ts.SyntaxKind.AsteriskToken:\n          return { kind: \"number\", value: left.value * right.value };\n        case ts.SyntaxKind.SlashToken:\n          return { kind: \"number\", value: left.value / right.value };\n        case ts.SyntaxKind.PercentToken:\n          return { kind: \"number\", value: left.value % right.value };\n        case ts.SyntaxKind.AsteriskAsteriskToken:\n          return { kind: \"number\", value: left.value ** right.value };\n        case ts.SyntaxKind.LessThanToken:\n          return { kind: \"boolean\", value: left.value < right.value };\n        case ts.SyntaxKind.LessThanEqualsToken:\n          return { kind: \"boolean\", value: left.value <= right.value };\n        case ts.SyntaxKind.GreaterThanToken:\n          return { kind: \"boolean\", value: left.value > right.value };\n        case ts.SyntaxKind.GreaterThanEqualsToken:\n          return { kind: \"boolean\", value: left.value >= right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n        case ts.SyntaxKind.AmpersandToken:\n          return { kind: \"number\", value: left.value & right.value };\n        case ts.SyntaxKind.BarToken:\n          return { kind: \"number\", value: left.value | right.value };\n        case ts.SyntaxKind.CaretToken:\n          return { kind: \"number\", value: left.value ^ right.value };\n        case ts.SyntaxKind.LessThanLessThanToken:\n          return { kind: \"number\", value: left.value << right.value };\n        case ts.SyntaxKind.GreaterThanGreaterThanToken:\n          return { kind: \"number\", value: left.value >> right.value };\n        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n          return { kind: \"number\", value: left.value >>> right.value };\n      }\n    }\n\n    // String operations\n    if (left.kind === \"string\" && right.kind === \"string\") {\n      switch (op) {\n        case ts.SyntaxKind.PlusToken:\n          return { kind: \"string\", value: left.value + right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n        case ts.SyntaxKind.LessThanToken:\n          return { kind: \"boolean\", value: left.value < right.value };\n        case ts.SyntaxKind.GreaterThanToken:\n          return { kind: \"boolean\", value: left.value > right.value };\n      }\n    }\n\n    // String + number concatenation\n    if (\n      (left.kind === \"string\" && right.kind === \"number\") ||\n      (left.kind === \"number\" && right.kind === \"string\")\n    ) {\n      if (op === ts.SyntaxKind.PlusToken) {\n        return {\n          kind: \"string\",\n          value: this.comptimeToString(left) + this.comptimeToString(right),\n        };\n      }\n    }\n\n    // Boolean operations\n    if (left.kind === \"boolean\" && right.kind === \"boolean\") {\n      switch (op) {\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n          return { kind: \"boolean\", value: left.value && right.value };\n        case ts.SyntaxKind.BarBarToken:\n          return { kind: \"boolean\", value: left.value || right.value };\n        case ts.SyntaxKind.EqualsEqualsToken:\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value === right.value };\n        case ts.SyntaxKind.ExclamationEqualsToken:\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return { kind: \"boolean\", value: left.value !== right.value };\n      }\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot apply operator ${ts.SyntaxKind[op]} to ${left.kind} and ${right.kind}`,\n    };\n  }\n\n  private evaluatePrefixUnary(node: ts.PrefixUnaryExpression): ComptimeValue {\n    const operand = this.evaluateNode(node.operand);\n    if (operand.kind === \"error\") return operand;\n\n    switch (node.operator) {\n      case ts.SyntaxKind.MinusToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: -operand.value };\n        }\n        break;\n      case ts.SyntaxKind.PlusToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: +operand.value };\n        }\n        break;\n      case ts.SyntaxKind.ExclamationToken:\n        const boolValue = this.comptimeToBoolean(operand);\n        if (boolValue !== null) {\n          return { kind: \"boolean\", value: !boolValue };\n        }\n        break;\n      case ts.SyntaxKind.TildeToken:\n        if (operand.kind === \"number\") {\n          return { kind: \"number\", value: ~operand.value };\n        }\n        break;\n    }\n\n    return {\n      kind: \"error\",\n      message: `Cannot apply unary ${ts.SyntaxKind[node.operator]} to ${operand.kind}`,\n    };\n  }\n\n  private comptimeToBoolean(value: ComptimeValue): boolean | null {\n    switch (value.kind) {\n      case \"boolean\":\n        return value.value;\n      case \"number\":\n        return value.value !== 0;\n      case \"string\":\n        return value.value !== \"\";\n      case \"null\":\n      case \"undefined\":\n        return false;\n      case \"array\":\n      case \"object\":\n      case \"function\":\n        return true;\n      default:\n        return null;\n    }\n  }\n\n  private comptimeToString(value: ComptimeValue): string {\n    switch (value.kind) {\n      case \"string\":\n        return value.value;\n      case \"number\":\n        return String(value.value);\n      case \"boolean\":\n        return String(value.value);\n      case \"null\":\n        return \"null\";\n      case \"undefined\":\n        return \"undefined\";\n      case \"array\":\n        return `[${value.elements.map((e) => this.comptimeToString(e)).join(\", \")}]`;\n      case \"object\":\n        const entries = Array.from(value.properties.entries())\n          .map(([k, v]) => `${k}: ${this.comptimeToString(v)}`)\n          .join(\", \");\n        return `{ ${entries} }`;\n      case \"function\":\n        return \"[Function]\";\n      case \"type\":\n        return \"[Type]\";\n      case \"error\":\n        return `[Error: ${value.message}]`;\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Unique Name Generation\n  // -------------------------------------------------------------------------\n\n  generateUniqueName(prefix: string): ts.Identifier {\n    const name = `__typemacro_${prefix}_${this.uniqueNameCounter++}__`;\n    return this.factory.createIdentifier(name);\n  }\n\n  // -------------------------------------------------------------------------\n  // Helper: Convert ComptimeValue to TypeScript Expression\n  // -------------------------------------------------------------------------\n\n  comptimeValueToExpression(value: ComptimeValue): ts.Expression {\n    switch (value.kind) {\n      case \"number\":\n        return this.createNumericLiteral(value.value);\n      case \"string\":\n        return this.createStringLiteral(value.value);\n      case \"boolean\":\n        return this.createBooleanLiteral(value.value);\n      case \"null\":\n        return this.factory.createNull();\n      case \"undefined\":\n        return this.factory.createIdentifier(\"undefined\");\n      case \"array\":\n        return this.createArrayLiteral(\n          value.elements.map((e) => this.comptimeValueToExpression(e)),\n        );\n      case \"object\":\n        const props: Array<{ name: string; value: ts.Expression }> = [];\n        value.properties.forEach((v, k) => {\n          props.push({ name: k, value: this.comptimeValueToExpression(v) });\n        });\n        return this.createObjectLiteral(props);\n      case \"error\":\n        throw new Error(\n          `Cannot convert error value to expression: ${value.message}`,\n        );\n      default:\n        throw new Error(`Cannot convert ${value.kind} to expression`);\n    }\n  }\n}\n\n/**\n * Create a macro context for a given program and source file\n */\nexport function createMacroContext(\n  program: ts.Program,\n  sourceFile: ts.SourceFile,\n  transformContext: ts.TransformationContext,\n): MacroContextImpl {\n  return new MacroContextImpl(\n    program,\n    program.getTypeChecker(),\n    sourceFile,\n    transformContext.factory,\n    transformContext,\n  );\n}\n","/**\n * Macro Registry - Stores and retrieves macro definitions\n */\n\nimport {\n  MacroDefinition,\n  MacroRegistry,\n  ExpressionMacro,\n  AttributeMacro,\n  DeriveMacro,\n  TaggedTemplateMacroDef,\n  TypeMacro,\n} from \"./types.js\";\n\nclass MacroRegistryImpl implements MacroRegistry {\n  private expressionMacros = new Map<string, ExpressionMacro>();\n  private attributeMacros = new Map<string, AttributeMacro>();\n  private deriveMacros = new Map<string, DeriveMacro>();\n  private taggedTemplateMacros = new Map<string, TaggedTemplateMacroDef>();\n  private typeMacros = new Map<string, TypeMacro>();\n\n  register(macro: MacroDefinition): void {\n    switch (macro.kind) {\n      case \"expression\":\n        if (this.expressionMacros.has(macro.name)) {\n          throw new Error(\n            `Expression macro '${macro.name}' is already registered`,\n          );\n        }\n        this.expressionMacros.set(macro.name, macro);\n        break;\n\n      case \"attribute\":\n        if (this.attributeMacros.has(macro.name)) {\n          throw new Error(\n            `Attribute macro '${macro.name}' is already registered`,\n          );\n        }\n        this.attributeMacros.set(macro.name, macro);\n        break;\n\n      case \"derive\":\n        if (this.deriveMacros.has(macro.name)) {\n          throw new Error(`Derive macro '${macro.name}' is already registered`);\n        }\n        this.deriveMacros.set(macro.name, macro);\n        break;\n\n      case \"tagged-template\":\n        if (this.taggedTemplateMacros.has(macro.name)) {\n          throw new Error(\n            `Tagged template macro '${macro.name}' is already registered`,\n          );\n        }\n        this.taggedTemplateMacros.set(macro.name, macro);\n        break;\n\n      case \"type\":\n        if (this.typeMacros.has(macro.name)) {\n          throw new Error(\n            `Type macro '${macro.name}' is already registered`,\n          );\n        }\n        this.typeMacros.set(macro.name, macro);\n        break;\n\n      default:\n        throw new Error(\n          `Unknown macro kind: ${(macro as MacroDefinition).kind}`,\n        );\n    }\n  }\n\n  getExpression(name: string): ExpressionMacro | undefined {\n    return this.expressionMacros.get(name);\n  }\n\n  getAttribute(name: string): AttributeMacro | undefined {\n    return this.attributeMacros.get(name);\n  }\n\n  getDerive(name: string): DeriveMacro | undefined {\n    return this.deriveMacros.get(name);\n  }\n\n  getTaggedTemplate(name: string): TaggedTemplateMacroDef | undefined {\n    return this.taggedTemplateMacros.get(name);\n  }\n\n  getType(name: string): TypeMacro | undefined {\n    return this.typeMacros.get(name);\n  }\n\n  getAll(): MacroDefinition[] {\n    return [\n      ...this.expressionMacros.values(),\n      ...this.attributeMacros.values(),\n      ...this.deriveMacros.values(),\n      ...this.taggedTemplateMacros.values(),\n      ...this.typeMacros.values(),\n    ];\n  }\n\n  /** Clear all registered macros (useful for testing) */\n  clear(): void {\n    this.expressionMacros.clear();\n    this.attributeMacros.clear();\n    this.deriveMacros.clear();\n    this.taggedTemplateMacros.clear();\n    this.typeMacros.clear();\n  }\n}\n\n/** Global macro registry singleton */\nexport const globalRegistry = new MacroRegistryImpl();\n\n/** Create a new isolated registry (for testing or scoped usage) */\nexport function createRegistry(): MacroRegistry {\n  return new MacroRegistryImpl();\n}\n\n// ============================================================================\n// Macro Definition Helpers\n// ============================================================================\n\n/**\n * Define an expression macro with type inference\n */\nexport function defineExpressionMacro(\n  definition: Omit<ExpressionMacro, \"kind\">,\n): ExpressionMacro {\n  return {\n    ...definition,\n    kind: \"expression\",\n  };\n}\n\n/**\n * Define an attribute macro with type inference\n */\nexport function defineAttributeMacro(\n  definition: Omit<AttributeMacro, \"kind\">,\n): AttributeMacro {\n  return {\n    ...definition,\n    kind: \"attribute\",\n  };\n}\n\n/**\n * Define a derive macro with type inference\n */\nexport function defineDeriveMacro(\n  definition: Omit<DeriveMacro, \"kind\">,\n): DeriveMacro {\n  return {\n    ...definition,\n    kind: \"derive\",\n  };\n}\n\n/**\n * Define a tagged template macro with type inference\n */\nexport function defineTaggedTemplateMacro(\n  definition: Omit<TaggedTemplateMacroDef, \"kind\">,\n): TaggedTemplateMacroDef {\n  return {\n    ...definition,\n    kind: \"tagged-template\",\n  };\n}\n\n/**\n * Define a type macro with type inference\n */\nexport function defineTypeMacro(\n  definition: Omit<TypeMacro, \"kind\">,\n): TypeMacro {\n  return {\n    ...definition,\n    kind: \"type\",\n  };\n}\n\n/**\n * Register multiple macros at once\n */\nexport function registerMacros(\n  registry: MacroRegistry,\n  ...macros: MacroDefinition[]\n): void {\n  for (const macro of macros) {\n    registry.register(macro);\n  }\n}\n","/**\n * comptime macro - Evaluate expressions at compile time\n *\n * Inspired by Zig's comptime keyword, this macro evaluates expressions\n * during compilation and replaces them with their computed values.\n *\n * Uses Node's vm module to execute transpiled TypeScript in a sandbox,\n * giving full JavaScript semantics (closures, recursion, all operators,\n * built-in methods) without maintaining a custom interpreter.\n *\n * Usage:\n *   const x = comptime(() => 5 * 5);           // becomes: const x = 25;\n *   const factorial5 = comptime(() => {\n *     let result = 1;\n *     for (let i = 1; i <= 5; i++) result *= i;\n *     return result;\n *   });                                         // becomes: const factorial5 = 120;\n */\n\nimport * as ts from \"typescript\";\nimport * as vm from \"node:vm\";\nimport { defineExpressionMacro, globalRegistry } from \"../core/registry.js\";\nimport { MacroContext, ComptimeValue } from \"../core/types.js\";\nimport { MacroContextImpl } from \"../core/context.js\";\n\n/** Maximum execution time for comptime evaluation (ms) */\nconst COMPTIME_TIMEOUT_MS = 5000;\n\n/** Maximum iteration limit hint (for documentation; actual enforcement is via timeout) */\nconst MAX_ITERATIONS = 100_000;\n\nexport const comptimeMacro = defineExpressionMacro({\n  name: \"comptime\",\n  description: \"Evaluate an expression at compile time\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(callExpr, \"comptime expects exactly one argument\");\n      return callExpr;\n    }\n\n    const arg = args[0];\n\n    // If it's an arrow function or function expression, evaluate via vm\n    if (ts.isArrowFunction(arg) || ts.isFunctionExpression(arg)) {\n      return evaluateViaVm(ctx as MacroContextImpl, arg, callExpr);\n    }\n\n    // For simple expressions, try the lightweight AST evaluator first\n    const result = ctx.evaluate(arg);\n\n    if (result.kind === \"error\") {\n      // Fall back to vm-based evaluation for complex expressions\n      return evaluateViaVm(ctx as MacroContextImpl, arg, callExpr);\n    }\n\n    return (ctx as MacroContextImpl).comptimeValueToExpression(result);\n  },\n});\n\n/**\n * Evaluate a TypeScript expression/function at compile time using Node's vm module.\n *\n * This transpiles the source to JavaScript, runs it in a sandboxed context,\n * and converts the result back to a TypeScript AST node.\n */\nfunction evaluateViaVm(\n  ctx: MacroContextImpl,\n  node: ts.Node,\n  callExpr: ts.CallExpression,\n): ts.Expression {\n  const sourceText = node.getText ? node.getText() : nodeToString(node, ctx);\n\n  // Wrap in an IIFE if it's a function  call it immediately\n  const isFunction = ts.isArrowFunction(node) || ts.isFunctionExpression(node);\n  const codeToEval = isFunction ? `(${sourceText})()` : `(${sourceText})`;\n\n  // Transpile TypeScript to JavaScript\n  const { outputText, diagnostics } = ts.transpileModule(codeToEval, {\n    compilerOptions: {\n      target: ts.ScriptTarget.ES2022,\n      module: ts.ModuleKind.CommonJS,\n      strict: false,\n      removeComments: true,\n    },\n    reportDiagnostics: true,\n  });\n\n  if (diagnostics && diagnostics.length > 0) {\n    const messages = diagnostics.map((d) =>\n      ts.flattenDiagnosticMessageText(d.messageText, \"\\n\"),\n    );\n    ctx.reportError(\n      callExpr,\n      `Cannot transpile comptime expression: ${messages.join(\"; \")}`,\n    );\n    return callExpr;\n  }\n\n  // Strip the trailing export {} that transpileModule sometimes adds\n  const cleanedJs = outputText\n    .replace(/^\"use strict\";\\s*/, \"\")\n    .replace(/\\s*Object\\.defineProperty\\(exports.*\\n?/g, \"\")\n    .replace(/\\s*exports\\.\\S+ = void 0;\\s*/g, \"\");\n\n  try {\n    const sandbox = createComptimeSandbox();\n    const context = vm.createContext(sandbox);\n    const result = vm.runInContext(cleanedJs, context, {\n      timeout: COMPTIME_TIMEOUT_MS,\n      filename: \"comptime-eval.js\",\n    });\n\n    return jsValueToExpression(ctx, result, callExpr);\n  } catch (error: unknown) {\n    ctx.reportError(callExpr, formatComptimeError(error, sourceText, ctx, callExpr));\n    return callExpr;\n  }\n}\n\n/**\n * Format a comptime evaluation error with source context.\n *\n * Includes the original source snippet, file location, and a clear\n * explanation of what went wrong -- not just the raw vm error.\n */\nfunction formatComptimeError(\n  error: unknown,\n  sourceText: string,\n  ctx: MacroContextImpl,\n  callExpr: ts.CallExpression,\n): string {\n  const rawMessage = error instanceof Error ? error.message : String(error);\n\n  // Get source location\n  const sourceFile = ctx.sourceFile;\n  const start = callExpr.getStart(sourceFile);\n  const { line, character } =\n    sourceFile.getLineAndCharacterOfPosition(start);\n  const location = `${sourceFile.fileName}:${line + 1}:${character + 1}`;\n\n  // Truncate long source snippets\n  const maxSnippetLen = 200;\n  const snippet =\n    sourceText.length > maxSnippetLen\n      ? sourceText.slice(0, maxSnippetLen) + \"...\"\n      : sourceText;\n\n  // Detect common error patterns and provide helpful messages\n  let hint = \"\";\n  if (rawMessage.includes(\"Script execution timed out\")) {\n    hint =\n      `\\n  Hint: The expression took longer than ${COMPTIME_TIMEOUT_MS}ms to evaluate. ` +\n      `Check for infinite loops or very expensive computations.`;\n  } else if (\n    rawMessage.includes(\"is not defined\") ||\n    rawMessage.includes(\"is not a function\")\n  ) {\n    const match = rawMessage.match(/(\\w+) is not (defined|a function)/);\n    const name = match?.[1] ?? \"unknown\";\n    hint =\n      `\\n  Hint: '${name}' is not available in the comptime sandbox. ` +\n      `Only safe built-ins (Math, JSON, Array, etc.) are accessible. ` +\n      `File I/O, network, and process access are intentionally blocked.`;\n  } else if (rawMessage.includes(\"Cannot read properties of\")) {\n    hint =\n      \"\\n  Hint: A null/undefined value was accessed. \" +\n      \"Check that all variables are properly initialized.\";\n  }\n\n  return (\n    `Compile-time evaluation failed at ${location}\\n` +\n    `  Source: comptime(${snippet})\\n` +\n    `  Error: ${rawMessage}${hint}`\n  );\n}\n\n/**\n * Create a sandboxed environment for comptime evaluation.\n * Only safe, side-effect-free globals are exposed.\n */\nfunction createComptimeSandbox(): Record<string, unknown> {\n  return {\n    // Safe built-ins\n    Math,\n    Number,\n    String,\n    Boolean,\n    Array,\n    Object,\n    Map,\n    Set,\n    WeakMap,\n    WeakSet,\n    JSON,\n    Date,\n    RegExp,\n    Error,\n    TypeError,\n    RangeError,\n    SyntaxError,\n    parseInt,\n    parseFloat,\n    isNaN,\n    isFinite,\n    NaN,\n    Infinity,\n    undefined,\n\n    // Console for debugging (output goes to build log)\n    console: {\n      log: (...args: unknown[]) => console.log(\"[comptime]\", ...args),\n      warn: (...args: unknown[]) => console.warn(\"[comptime]\", ...args),\n      error: (...args: unknown[]) => console.error(\"[comptime]\", ...args),\n    },\n  };\n}\n\n/**\n * Convert a JavaScript runtime value to a TypeScript AST expression.\n */\nfunction jsValueToExpression(\n  ctx: MacroContextImpl,\n  value: unknown,\n  errorNode: ts.Node,\n): ts.Expression {\n  if (value === null) {\n    return ctx.factory.createNull();\n  }\n\n  if (value === undefined) {\n    return ctx.factory.createIdentifier(\"undefined\");\n  }\n\n  if (typeof value === \"number\") {\n    if (value < 0) {\n      return ctx.factory.createPrefixUnaryExpression(\n        ts.SyntaxKind.MinusToken,\n        ctx.factory.createNumericLiteral(Math.abs(value)),\n      );\n    }\n    if (!isFinite(value)) {\n      return ctx.factory.createIdentifier(value > 0 ? \"Infinity\" : \"-Infinity\");\n    }\n    if (isNaN(value)) {\n      return ctx.factory.createIdentifier(\"NaN\");\n    }\n    return ctx.factory.createNumericLiteral(value);\n  }\n\n  if (typeof value === \"string\") {\n    return ctx.factory.createStringLiteral(value);\n  }\n\n  if (typeof value === \"boolean\") {\n    return value ? ctx.factory.createTrue() : ctx.factory.createFalse();\n  }\n\n  if (typeof value === \"bigint\") {\n    return ctx.factory.createBigIntLiteral(value.toString());\n  }\n\n  if (Array.isArray(value)) {\n    const elements = value.map((el) => jsValueToExpression(ctx, el, errorNode));\n    return ctx.factory.createArrayLiteralExpression(elements);\n  }\n\n  if (value instanceof RegExp) {\n    return ctx.factory.createCallExpression(\n      ctx.factory.createIdentifier(\"RegExp\"),\n      undefined,\n      [\n        ctx.factory.createStringLiteral(value.source),\n        ctx.factory.createStringLiteral(value.flags),\n      ],\n    );\n  }\n\n  if (typeof value === \"object\") {\n    const properties: ts.PropertyAssignment[] = [];\n    for (const [key, val] of Object.entries(value)) {\n      properties.push(\n        ctx.factory.createPropertyAssignment(\n          /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)\n            ? ctx.factory.createIdentifier(key)\n            : ctx.factory.createStringLiteral(key),\n          jsValueToExpression(ctx, val, errorNode),\n        ),\n      );\n    }\n    return ctx.factory.createObjectLiteralExpression(properties, true);\n  }\n\n  // Functions, symbols, etc. cannot be serialized to AST\n  ctx.reportError(\n    errorNode,\n    `Cannot serialize comptime result of type ${typeof value} to AST`,\n  );\n  return ctx.factory.createIdentifier(\"undefined\");\n}\n\n/**\n * Convert a TS node to its source text when getText() is unavailable\n * (e.g., for synthetically created nodes).\n */\nfunction nodeToString(node: ts.Node, ctx: MacroContextImpl): string {\n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n  return printer.printNode(ts.EmitHint.Expression, node, ctx.sourceFile);\n}\n\n/**\n * Convert a JS value to a ComptimeValue (for interop with the lightweight evaluator).\n */\nexport function jsToComptimeValue(value: unknown): ComptimeValue {\n  if (value === null) return { kind: \"null\" };\n  if (value === undefined) return { kind: \"undefined\" };\n  if (typeof value === \"number\") return { kind: \"number\", value };\n  if (typeof value === \"string\") return { kind: \"string\", value };\n  if (typeof value === \"boolean\") return { kind: \"boolean\", value };\n  if (Array.isArray(value)) {\n    return { kind: \"array\", elements: value.map(jsToComptimeValue) };\n  }\n  if (typeof value === \"object\") {\n    const properties = new Map<string, ComptimeValue>();\n    for (const [k, v] of Object.entries(value)) {\n      properties.set(k, jsToComptimeValue(v));\n    }\n    return { kind: \"object\", properties };\n  }\n  return {\n    kind: \"error\",\n    message: `Cannot convert ${typeof value} to ComptimeValue`,\n  };\n}\n\n// Register the macro\nglobalRegistry.register(comptimeMacro);\n","/**\n * Derive Macros - Auto-generate common implementations\n *\n * Inspired by Rust's derive macros, these automatically generate\n * implementations for common traits/interfaces.\n *\n * Usage:\n *   @derive(Eq, Ord, Clone, Debug)\n *   interface Point {\n *     x: number;\n *     y: number;\n *   }\n */\n\nimport * as ts from \"typescript\";\nimport { defineDeriveMacro, globalRegistry } from \"../core/registry.js\";\nimport {\n  MacroContext,\n  DeriveTypeInfo,\n  DeriveFieldInfo,\n} from \"../core/types.js\";\n\n// ============================================================================\n// Eq - Generate equality comparison function\n// ============================================================================\n\nexport const EqDerive = defineDeriveMacro({\n  name: \"Eq\",\n  description: \"Generate an equality comparison function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `${uncapitalize(name)}Eq`;\n\n    // Generate: (a: Type, b: Type) => boolean\n    const comparisons = fields.map(\n      (field) => `a.${field.name} === b.${field.name}`,\n    );\n\n    const body = comparisons.length > 0 ? comparisons.join(\" && \") : \"true\";\n\n    const code = `\nexport function ${fnName}(a: ${name}, b: ${name}): boolean {\n  return ${body};\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Ord - Generate comparison/ordering function\n// ============================================================================\n\nexport const OrdDerive = defineDeriveMacro({\n  name: \"Ord\",\n  description: \"Generate a comparison function for ordering\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `${uncapitalize(name)}Compare`;\n\n    // Generate field comparisons\n    const comparisons = fields\n      .map((field) => {\n        return `\n  if (a.${field.name} < b.${field.name}) return -1;\n  if (a.${field.name} > b.${field.name}) return 1;`;\n      })\n      .join(\"\\n\");\n\n    const code = `\nexport function ${fnName}(a: ${name}, b: ${name}): -1 | 0 | 1 {\n${comparisons}\n  return 0;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Clone - Generate a deep clone function\n// ============================================================================\n\nexport const CloneDerive = defineDeriveMacro({\n  name: \"Clone\",\n  description: \"Generate a deep clone function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `clone${name}`;\n\n    // Generate field copying\n    const copies = fields.map((field) => {\n      // For now, simple copy. Could be enhanced for nested objects\n      return `    ${field.name}: value.${field.name}`;\n    });\n\n    const code = `\nexport function ${fnName}(value: ${name}): ${name} {\n  return {\n${copies.join(\",\\n\")}\n  };\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Debug - Generate a debug string representation\n// ============================================================================\n\nexport const DebugDerive = defineDeriveMacro({\n  name: \"Debug\",\n  description: \"Generate a debug string representation function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `debug${name}`;\n\n    // Generate field string representations\n    const fieldStrs = fields.map(\n      (field) => `\\${JSON.stringify(value.${field.name})}`,\n    );\n\n    const fieldNames = fields.map((f) => f.name);\n    const pairs = fieldNames.map((n, i) => `${n}: ${fieldStrs[i]}`);\n\n    const code = `\nexport function ${fnName}(value: ${name}): string {\n  return \\`${name} { ${pairs.join(\", \")} }\\`;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Hash - Generate a hash function\n// ============================================================================\n\nexport const HashDerive = defineDeriveMacro({\n  name: \"Hash\",\n  description: \"Generate a hash function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `hash${name}`;\n\n    // Simple djb2-style hash\n    const hashCode = fields\n      .map((field) => {\n        const fieldType = getBaseType(field);\n        if (fieldType === \"number\") {\n          return `  hash = ((hash << 5) + hash) + (value.${field.name} | 0);`;\n        } else if (fieldType === \"string\") {\n          return `  for (let i = 0; i < value.${field.name}.length; i++) {\n    hash = ((hash << 5) + hash) + value.${field.name}.charCodeAt(i);\n  }`;\n        } else if (fieldType === \"boolean\") {\n          return `  hash = ((hash << 5) + hash) + (value.${field.name} ? 1 : 0);`;\n        }\n        return `  hash = ((hash << 5) + hash) + String(value.${field.name}).length;`;\n      })\n      .join(\"\\n\");\n\n    const code = `\nexport function ${fnName}(value: ${name}): number {\n  let hash = 5381;\n${hashCode}\n  return hash >>> 0;\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Default - Generate a default value factory\n// ============================================================================\n\nexport const DefaultDerive = defineDeriveMacro({\n  name: \"Default\",\n  description: \"Generate a default value factory function\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const fnName = `default${name}`;\n\n    // Generate default values based on type\n    const defaults = fields.map((field) => {\n      const defaultValue = getDefaultForType(field);\n      return `    ${field.name}: ${defaultValue}`;\n    });\n\n    const code = `\nexport function ${fnName}(): ${name} {\n  return {\n${defaults.join(\",\\n\")}\n  };\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// JSON - Generate JSON serialization/deserialization\n// ============================================================================\n\nexport const JsonDerive = defineDeriveMacro({\n  name: \"Json\",\n  description: \"Generate JSON serialization and deserialization functions\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n\n    // Serialize function\n    const serializeCode = `\nexport function ${uncapitalize(name)}ToJson(value: ${name}): string {\n  return JSON.stringify(value);\n}\n`;\n\n    // Deserialize with validation\n    const validations = fields\n      .map((field) => {\n        const baseType = getBaseType(field);\n        const optionalCheck = field.optional\n          ? \"\"\n          : `\n    if (obj.${field.name} === undefined) {\n      throw new Error(\"Missing required field: ${field.name}\");\n    }`;\n        const typeCheck = `\n    if (obj.${field.name} !== undefined && typeof obj.${field.name} !== \"${baseType}\") {\n      throw new Error(\"Field ${field.name} must be ${baseType}\");\n    }`;\n        return optionalCheck + typeCheck;\n      })\n      .join(\"\\n\");\n\n    const deserializeCode = `\nexport function ${uncapitalize(name)}FromJson(json: string): ${name} {\n  const obj = JSON.parse(json);\n${validations}\n  return obj as ${name};\n}\n`;\n\n    return [\n      ...ctx.parseStatements(serializeCode),\n      ...ctx.parseStatements(deserializeCode),\n    ];\n  },\n});\n\n// ============================================================================\n// Builder - Generate a builder pattern\n// ============================================================================\n\nexport const BuilderDerive = defineDeriveMacro({\n  name: \"Builder\",\n  description: \"Generate a builder pattern class\",\n\n  expand(\n    ctx: MacroContext,\n    _target:\n      | ts.InterfaceDeclaration\n      | ts.ClassDeclaration\n      | ts.TypeAliasDeclaration,\n    typeInfo: DeriveTypeInfo,\n  ): ts.Statement[] {\n    const { name, fields } = typeInfo;\n    const builderName = `${name}Builder`;\n\n    // Generate setter methods\n    const setters = fields\n      .map((field) => {\n        const methodName = `with${capitalize(field.name)}`;\n        return `\n  ${methodName}(${field.name}: ${field.typeString}): ${builderName} {\n    this._${field.name} = ${field.name};\n    return this;\n  }`;\n      })\n      .join(\"\\n\");\n\n    // Generate private fields\n    const privateFields = fields\n      .map((field) => {\n        const defaultValue = getDefaultForType(field);\n        return `  private _${field.name}: ${field.typeString} = ${defaultValue};`;\n      })\n      .join(\"\\n\");\n\n    // Generate build method\n    const buildProps = fields\n      .map((field) => `      ${field.name}: this._${field.name}`)\n      .join(\",\\n\");\n\n    const code = `\nexport class ${builderName} {\n${privateFields}\n\n${setters}\n\n  build(): ${name} {\n    return {\n${buildProps}\n    };\n  }\n}\n`;\n\n    return ctx.parseStatements(code);\n  },\n});\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction uncapitalize(str: string): string {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction getBaseType(field: DeriveFieldInfo): string {\n  const typeStr = field.typeString.toLowerCase();\n  if (typeStr === \"number\" || typeStr.includes(\"number\")) return \"number\";\n  if (typeStr === \"string\" || typeStr.includes(\"string\")) return \"string\";\n  if (typeStr === \"boolean\" || typeStr.includes(\"boolean\")) return \"boolean\";\n  if (typeStr.startsWith(\"array\") || typeStr.includes(\"[]\")) return \"object\";\n  return \"object\";\n}\n\nfunction getDefaultForType(field: DeriveFieldInfo): string {\n  if (field.optional) {\n    return \"undefined\";\n  }\n\n  const baseType = getBaseType(field);\n  switch (baseType) {\n    case \"number\":\n      return \"0\";\n    case \"string\":\n      return '\"\"';\n    case \"boolean\":\n      return \"false\";\n    default:\n      return \"{}\";\n  }\n}\n\n// ============================================================================\n// Export all derive macros as a collection\n// ============================================================================\n\nexport const deriveMacros = {\n  Eq: EqDerive,\n  Ord: OrdDerive,\n  Clone: CloneDerive,\n  Debug: DebugDerive,\n  Hash: HashDerive,\n  Default: DefaultDerive,\n  Json: JsonDerive,\n  Builder: BuilderDerive,\n};\n\n/**\n * Create a derived function name based on convention\n */\nexport function createDerivedFunctionName(\n  operation: string,\n  typeName: string,\n): string {\n  switch (operation) {\n    case \"eq\":\n      return `${uncapitalize(typeName)}Eq`;\n    case \"ord\":\n      return `${uncapitalize(typeName)}Ord`;\n    case \"compare\":\n      return `${uncapitalize(typeName)}Compare`;\n    case \"clone\":\n      return `clone${typeName}`;\n    case \"debug\":\n      return `debug${typeName}`;\n    case \"hash\":\n      return `hash${typeName}`;\n    case \"default\":\n      return `default${typeName}`;\n    case \"toJson\":\n      return `${uncapitalize(typeName)}ToJson`;\n    case \"fromJson\":\n      return `${uncapitalize(typeName)}FromJson`;\n    default:\n      return `${uncapitalize(typeName)}${capitalize(operation)}`;\n  }\n}\n\n// Register all derive macros\nglobalRegistry.register(EqDerive);\nglobalRegistry.register(OrdDerive);\nglobalRegistry.register(CloneDerive);\nglobalRegistry.register(DebugDerive);\nglobalRegistry.register(HashDerive);\nglobalRegistry.register(DefaultDerive);\nglobalRegistry.register(JsonDerive);\nglobalRegistry.register(BuilderDerive);\n","/**\n * Operator Overloading Macros\n *\n * Provides operator overloading for TypeScript through macro expansion.\n * This transforms operator usage into method calls at compile time.\n *\n * Usage:\n *   @operators({ \"+\": \"add\", \"-\": \"sub\", \"*\": \"mul\", \"/\": \"div\" })\n *   class Vector {\n *     add(other: Vector): Vector { ... }\n *   }\n *\n *   // Usage:\n *   const c = ops(a + b);  // Expands to: a.add(b)\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  defineAttributeMacro,\n  globalRegistry,\n} from \"../core/registry.js\";\nimport { MacroContext, AttributeTarget } from \"../core/types.js\";\n\n/**\n * Operator mappings storage.\n *\n * Note: These mappings are populated during a single compilation pass.\n * The @operators decorator on a class must be processed before any ops()\n * call that references that class. Within a single tsc invocation this\n * works because the transformer processes files in dependency order.\n *\n * For cross-compilation persistence (e.g., incremental builds), a future\n * enhancement could serialize mappings to a .typemacro-cache file.\n */\nconst operatorMappings = new Map<string, Map<string, string>>();\n\n/**\n * Clear all operator mappings (for testing)\n */\nexport function clearOperatorMappings(): void {\n  operatorMappings.clear();\n}\n\n/**\n * Register operator mappings for a type\n */\nexport function registerOperators(\n  typeName: string,\n  mappings: Record<string, string>,\n): void {\n  const typeMap = operatorMappings.get(typeName) ?? new Map();\n  for (const [op, method] of Object.entries(mappings)) {\n    typeMap.set(op, method);\n  }\n  operatorMappings.set(typeName, typeMap);\n}\n\n/**\n * Get the method name for an operator on a type.\n * Falls back to checking well-known method names by convention\n * if no explicit mapping is registered.\n */\nexport function getOperatorMethod(\n  typeName: string,\n  operator: string,\n): string | undefined {\n  const explicit = operatorMappings.get(typeName)?.get(operator);\n  if (explicit) return explicit;\n\n  // Convention-based fallback: check if the type has a method matching\n  // the standard operator method name. This allows ops() to work even\n  // without @operators if the class follows naming conventions.\n  return undefined;\n}\n\n// ============================================================================\n// @operators Attribute Macro\n// ============================================================================\n\nexport const operatorsAttribute = defineAttributeMacro({\n  name: \"operators\",\n  description: \"Define operator overloading mappings for a class\",\n  validTargets: [\"class\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (!ts.isClassDeclaration(target) || !target.name) {\n      ctx.reportError(\n        decorator,\n        \"@operators can only be applied to named classes\",\n      );\n      return target;\n    }\n\n    const className = target.name.text;\n\n    // Parse the operator mappings from the decorator argument\n    if (args.length !== 1 || !ts.isObjectLiteralExpression(args[0])) {\n      ctx.reportError(\n        decorator,\n        \"@operators requires an object literal argument\",\n      );\n      return target;\n    }\n\n    const mappings: Record<string, string> = {};\n\n    for (const prop of args[0].properties) {\n      if (ts.isPropertyAssignment(prop)) {\n        let keyName: string | undefined;\n\n        if (ts.isStringLiteral(prop.name)) {\n          keyName = prop.name.text;\n        } else if (ts.isIdentifier(prop.name)) {\n          keyName = prop.name.text;\n        }\n\n        if (keyName && ts.isStringLiteral(prop.initializer)) {\n          mappings[keyName] = prop.initializer.text;\n        }\n      }\n    }\n\n    // Register the mappings at compile time\n    registerOperators(className, mappings);\n\n    // Return the class unchanged (the mappings are used by the ops() macro)\n    return target;\n  },\n});\n\n// ============================================================================\n// ops() Expression Macro - Transform operators to method calls\n// ============================================================================\n\nexport const opsMacro = defineExpressionMacro({\n  name: \"ops\",\n  description: \"Transform operators into method calls\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"ops() expects exactly one expression argument\",\n      );\n      return callExpr;\n    }\n\n    const expr = args[0];\n    return transformExpression(ctx, expr);\n  },\n});\n\n/**\n * Recursively transform an expression, converting operators to method calls\n */\nfunction transformExpression(\n  ctx: MacroContext,\n  expr: ts.Expression,\n): ts.Expression {\n  const factory = ctx.factory;\n\n  // Handle binary expressions\n  if (ts.isBinaryExpression(expr)) {\n    const operator = getOperatorString(expr.operatorToken.kind);\n    if (!operator) {\n      // Not an overloadable operator, recurse into children\n      return factory.updateBinaryExpression(\n        expr,\n        transformExpression(ctx, expr.left),\n        expr.operatorToken,\n        transformExpression(ctx, expr.right),\n      );\n    }\n\n    // Try to determine the type of the left operand\n    const leftType = ctx.getTypeOf(expr.left);\n    const typeName = ctx.typeChecker.typeToString(leftType);\n\n    // Clean up the type name (remove generics, etc.)\n    const baseTypeName = typeName.split(\"<\")[0].trim();\n\n    // Check if we have operator mappings for this type\n    const method = getOperatorMethod(baseTypeName, operator);\n\n    if (method) {\n      // Transform: a + b  =>  a.add(b)\n      const left = transformExpression(ctx, expr.left);\n      const right = transformExpression(ctx, expr.right);\n\n      return factory.createCallExpression(\n        factory.createPropertyAccessExpression(left, method),\n        undefined,\n        [right],\n      );\n    }\n\n    // No mapping found, recurse into children\n    return factory.updateBinaryExpression(\n      expr,\n      transformExpression(ctx, expr.left),\n      expr.operatorToken,\n      transformExpression(ctx, expr.right),\n    );\n  }\n\n  // Handle prefix unary expressions\n  if (ts.isPrefixUnaryExpression(expr)) {\n    const operator = getPrefixOperatorString(expr.operator);\n    if (operator) {\n      const operandType = ctx.getTypeOf(expr.operand);\n      const typeName = ctx.typeChecker\n        .typeToString(operandType)\n        .split(\"<\")[0]\n        .trim();\n      const method = getOperatorMethod(typeName, operator);\n\n      if (method) {\n        // Transform: -a  =>  a.neg()\n        const operand = transformExpression(ctx, expr.operand);\n        return factory.createCallExpression(\n          factory.createPropertyAccessExpression(operand, method),\n          undefined,\n          [],\n        );\n      }\n    }\n\n    return factory.updatePrefixUnaryExpression(\n      expr,\n      transformExpression(ctx, expr.operand),\n    );\n  }\n\n  // Handle parenthesized expressions\n  if (ts.isParenthesizedExpression(expr)) {\n    return factory.updateParenthesizedExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n    );\n  }\n\n  // Handle call expressions (recurse into arguments)\n  if (ts.isCallExpression(expr)) {\n    return factory.updateCallExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n      expr.typeArguments,\n      expr.arguments.map((arg) => transformExpression(ctx, arg)),\n    );\n  }\n\n  // Handle property access\n  if (ts.isPropertyAccessExpression(expr)) {\n    return factory.updatePropertyAccessExpression(\n      expr,\n      transformExpression(ctx, expr.expression),\n      expr.name,\n    );\n  }\n\n  // Return unchanged for other expression types\n  return expr;\n}\n\n/**\n * Convert a binary operator token to a string representation\n */\nfunction getOperatorString(kind: ts.SyntaxKind): string | undefined {\n  switch (kind) {\n    case ts.SyntaxKind.PlusToken:\n      return \"+\";\n    case ts.SyntaxKind.MinusToken:\n      return \"-\";\n    case ts.SyntaxKind.AsteriskToken:\n      return \"*\";\n    case ts.SyntaxKind.SlashToken:\n      return \"/\";\n    case ts.SyntaxKind.PercentToken:\n      return \"%\";\n    case ts.SyntaxKind.AsteriskAsteriskToken:\n      return \"**\";\n    case ts.SyntaxKind.LessThanToken:\n      return \"<\";\n    case ts.SyntaxKind.LessThanEqualsToken:\n      return \"<=\";\n    case ts.SyntaxKind.GreaterThanToken:\n      return \">\";\n    case ts.SyntaxKind.GreaterThanEqualsToken:\n      return \">=\";\n    case ts.SyntaxKind.EqualsEqualsToken:\n      return \"==\";\n    case ts.SyntaxKind.EqualsEqualsEqualsToken:\n      return \"===\";\n    case ts.SyntaxKind.ExclamationEqualsToken:\n      return \"!=\";\n    case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n      return \"!==\";\n    case ts.SyntaxKind.AmpersandToken:\n      return \"&\";\n    case ts.SyntaxKind.BarToken:\n      return \"|\";\n    case ts.SyntaxKind.CaretToken:\n      return \"^\";\n    case ts.SyntaxKind.LessThanLessThanToken:\n      return \"<<\";\n    case ts.SyntaxKind.GreaterThanGreaterThanToken:\n      return \">>\";\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Convert a prefix unary operator to a string representation\n */\nfunction getPrefixOperatorString(\n  kind: ts.PrefixUnaryOperator,\n): string | undefined {\n  switch (kind) {\n    case ts.SyntaxKind.MinusToken:\n      return \"-unary\";\n    case ts.SyntaxKind.PlusToken:\n      return \"+unary\";\n    case ts.SyntaxKind.ExclamationToken:\n      return \"!\";\n    case ts.SyntaxKind.TildeToken:\n      return \"~\";\n    default:\n      return undefined;\n  }\n}\n\n// ============================================================================\n// pipe() and compose() - Functional composition macros\n// ============================================================================\n\nexport const pipeMacro = defineExpressionMacro({\n  name: \"pipe\",\n  description: \"Pipe a value through a series of functions\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 2) {\n      ctx.reportError(\n        callExpr,\n        \"pipe() requires at least an initial value and one function\",\n      );\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n\n    // pipe(x, f, g, h) => h(g(f(x)))\n    let result = args[0];\n\n    for (let i = 1; i < args.length; i++) {\n      result = factory.createCallExpression(args[i], undefined, [result]);\n    }\n\n    return result;\n  },\n});\n\nexport const composeMacro = defineExpressionMacro({\n  name: \"compose\",\n  description: \"Compose functions right-to-left\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length < 1) {\n      ctx.reportError(callExpr, \"compose() requires at least one function\");\n      return callExpr;\n    }\n\n    const factory = ctx.factory;\n\n    // compose(f, g, h) => (x) => f(g(h(x)))\n    // Generate: (x) => f(g(h(x)))\n\n    const paramName = ctx.generateUniqueName(\"x\");\n\n    let body: ts.Expression = paramName;\n    for (let i = args.length - 1; i >= 0; i--) {\n      body = factory.createCallExpression(args[i], undefined, [body]);\n    }\n\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [factory.createParameterDeclaration(undefined, undefined, paramName)],\n      undefined,\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      body,\n    );\n  },\n});\n\n// Register macros\nglobalRegistry.register(operatorsAttribute);\nglobalRegistry.register(opsMacro);\nglobalRegistry.register(pipeMacro);\nglobalRegistry.register(composeMacro);\n","/**\n * Compile-Time Reflection Macros\n *\n * Provides compile-time type introspection capabilities, allowing you to\n * examine types, generate code based on type information, and more.\n *\n * Inspired by:\n * - Rust's proc_macro with derive\n * - Java/C# reflection but at compile time\n * - Zig's @typeInfo\n *\n * @example\n * ```typescript\n * @reflect\n * interface User {\n *   id: number;\n *   name: string;\n *   email: string;\n * }\n *\n * // Get metadata at compile time\n * const userMeta = typeInfo<User>();\n * // { name: \"User\", fields: [{ name: \"id\", type: \"number\" }, ...] }\n *\n * // Generate a validator\n * const validateUser = validator<User>();\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineExpressionMacro,\n  defineAttributeMacro,\n  globalRegistry,\n} from \"../core/registry.js\";\nimport { MacroContext, AttributeTarget } from \"../core/types.js\";\n\n// ============================================================================\n// Type Information Structures\n// ============================================================================\n\nexport interface TypeInfo {\n  name: string;\n  kind:\n    | \"interface\"\n    | \"class\"\n    | \"type\"\n    | \"enum\"\n    | \"primitive\"\n    | \"union\"\n    | \"intersection\"\n    | \"array\"\n    | \"tuple\"\n    | \"function\";\n  fields?: FieldInfo[];\n  methods?: MethodInfo[];\n  typeParameters?: string[];\n  extends?: string[];\n  modifiers?: string[];\n}\n\nexport interface FieldInfo {\n  name: string;\n  type: string;\n  optional: boolean;\n  readonly: boolean;\n  defaultValue?: string;\n}\n\nexport interface MethodInfo {\n  name: string;\n  parameters: ParameterInfo[];\n  returnType: string;\n  isAsync: boolean;\n  isStatic: boolean;\n}\n\nexport interface ParameterInfo {\n  name: string;\n  type: string;\n  optional: boolean;\n  defaultValue?: string;\n}\n\n// ============================================================================\n// @reflect Attribute Macro\n// ============================================================================\n\nexport const reflectAttribute = defineAttributeMacro({\n  name: \"reflect\",\n  description: \"Enable compile-time reflection for a type\",\n  validTargets: [\"interface\", \"class\", \"type\"] as AttributeTarget[],\n\n  expand(\n    ctx: MacroContext,\n    decorator: ts.Decorator,\n    target: ts.Declaration,\n    _args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    // Extract type information directly from the type checker\n    const typeInfo = extractTypeInfo(ctx, target);\n\n    if (typeInfo) {\n      // Generate metadata as an exported const alongside the original declaration\n      const metaName = `__${typeInfo.name}_meta__`;\n      const metaDecl = generateTypeInfoDeclaration(ctx, metaName, typeInfo);\n\n      return [target, metaDecl];\n    }\n\n    return target;\n  },\n});\n\n/**\n * Extract type information from a declaration\n */\nfunction extractTypeInfo(\n  ctx: MacroContext,\n  node: ts.Declaration,\n): TypeInfo | null {\n  if (ts.isInterfaceDeclaration(node)) {\n    return extractInterfaceInfo(ctx, node);\n  }\n\n  if (ts.isClassDeclaration(node)) {\n    return extractClassInfo(ctx, node);\n  }\n\n  if (ts.isTypeAliasDeclaration(node)) {\n    return extractTypeAliasInfo(ctx, node);\n  }\n\n  return null;\n}\n\nfunction extractInterfaceInfo(\n  ctx: MacroContext,\n  node: ts.InterfaceDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n  const fields: FieldInfo[] = properties.map((prop) => {\n    const decls = prop.getDeclarations();\n    const decl = decls?.[0];\n    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n      prop,\n      decl || node,\n    );\n\n    return {\n      name: prop.name,\n      type: ctx.typeChecker.typeToString(propType),\n      optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n      readonly:\n        decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl))\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false,\n    };\n  });\n\n  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];\n  const extendsTypes =\n    node.heritageClauses\n      ?.filter((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword)\n      .flatMap((hc) => hc.types.map((t) => t.expression.getText())) ?? [];\n\n  return {\n    name: node.name.text,\n    kind: \"interface\",\n    fields,\n    typeParameters,\n    extends: extendsTypes,\n  };\n}\n\nfunction extractClassInfo(\n  ctx: MacroContext,\n  node: ts.ClassDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n  const fields: FieldInfo[] = [];\n  const methods: MethodInfo[] = [];\n\n  for (const prop of properties) {\n    const decls = prop.getDeclarations();\n    const decl = decls?.[0];\n    const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n      prop,\n      decl || node,\n    );\n    const typeStr = ctx.typeChecker.typeToString(propType);\n\n    // Check if it's a method\n    if (decl && ts.isMethodDeclaration(decl)) {\n      const params: ParameterInfo[] = decl.parameters.map((p) => ({\n        name: ts.isIdentifier(p.name) ? p.name.text : \"param\",\n        type: p.type ? p.type.getText() : \"unknown\",\n        optional: !!p.questionToken,\n        defaultValue: p.initializer?.getText(),\n      }));\n\n      methods.push({\n        name: prop.name,\n        parameters: params,\n        returnType: decl.type?.getText() ?? \"void\",\n        isAsync: !!decl.modifiers?.some(\n          (m) => m.kind === ts.SyntaxKind.AsyncKeyword,\n        ),\n        isStatic: !!decl.modifiers?.some(\n          (m) => m.kind === ts.SyntaxKind.StaticKeyword,\n        ),\n      });\n    } else {\n      fields.push({\n        name: prop.name,\n        type: typeStr,\n        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n        readonly:\n          decl && ts.isPropertyDeclaration(decl)\n            ? (decl.modifiers?.some(\n                (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n              ) ?? false)\n            : false,\n      });\n    }\n  }\n\n  const typeParameters = node.typeParameters?.map((tp) => tp.name.text) ?? [];\n\n  return {\n    name: node.name?.text ?? \"Anonymous\",\n    kind: \"class\",\n    fields,\n    methods,\n    typeParameters,\n  };\n}\n\nfunction extractTypeAliasInfo(\n  ctx: MacroContext,\n  node: ts.TypeAliasDeclaration,\n): TypeInfo {\n  const type = ctx.typeChecker.getTypeAtLocation(node);\n  const typeString = ctx.typeChecker.typeToString(type);\n\n  // For object types, extract fields\n  if (type.isClassOrInterface() || type.flags & ts.TypeFlags.Object) {\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n    const fields: FieldInfo[] = properties.map((prop) => {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, node);\n      return {\n        name: prop.name,\n        type: ctx.typeChecker.typeToString(propType),\n        optional: (prop.flags & ts.SymbolFlags.Optional) !== 0,\n        readonly: false,\n      };\n    });\n\n    return {\n      name: node.name.text,\n      kind: \"type\",\n      fields,\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  // Union type\n  if (type.isUnion()) {\n    return {\n      name: node.name.text,\n      kind: \"union\",\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  // Intersection type\n  if (type.isIntersection()) {\n    return {\n      name: node.name.text,\n      kind: \"intersection\",\n      typeParameters: node.typeParameters?.map((tp) => tp.name.text) ?? [],\n    };\n  }\n\n  return {\n    name: node.name.text,\n    kind: \"type\",\n  };\n}\n\n/**\n * Generate a TypeInfo declaration\n */\nfunction generateTypeInfoDeclaration(\n  ctx: MacroContext,\n  name: string,\n  info: TypeInfo,\n): ts.Statement {\n  const factory = ctx.factory;\n\n  const fieldsArray =\n    info.fields?.map((f) =>\n      factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(f.name),\n          ),\n          factory.createPropertyAssignment(\n            \"type\",\n            factory.createStringLiteral(f.type),\n          ),\n          factory.createPropertyAssignment(\n            \"optional\",\n            f.optional ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"readonly\",\n            f.readonly ? factory.createTrue() : factory.createFalse(),\n          ),\n        ],\n        true,\n      ),\n    ) ?? [];\n\n  const methodsArray =\n    info.methods?.map((m) =>\n      factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(m.name),\n          ),\n          factory.createPropertyAssignment(\n            \"returnType\",\n            factory.createStringLiteral(m.returnType),\n          ),\n          factory.createPropertyAssignment(\n            \"isAsync\",\n            m.isAsync ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"isStatic\",\n            m.isStatic ? factory.createTrue() : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"parameters\",\n            factory.createArrayLiteralExpression(\n              m.parameters.map((p) =>\n                factory.createObjectLiteralExpression(\n                  [\n                    factory.createPropertyAssignment(\n                      \"name\",\n                      factory.createStringLiteral(p.name),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"type\",\n                      factory.createStringLiteral(p.type),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"optional\",\n                      p.optional ? factory.createTrue() : factory.createFalse(),\n                    ),\n                  ],\n                  true,\n                ),\n              ),\n            ),\n          ),\n        ],\n        true,\n      ),\n    ) ?? [];\n\n  const infoObj = factory.createObjectLiteralExpression(\n    [\n      factory.createPropertyAssignment(\n        \"name\",\n        factory.createStringLiteral(info.name),\n      ),\n      factory.createPropertyAssignment(\n        \"kind\",\n        factory.createStringLiteral(info.kind),\n      ),\n      factory.createPropertyAssignment(\n        \"fields\",\n        factory.createArrayLiteralExpression(fieldsArray, true),\n      ),\n      factory.createPropertyAssignment(\n        \"methods\",\n        factory.createArrayLiteralExpression(methodsArray, true),\n      ),\n      factory.createPropertyAssignment(\n        \"typeParameters\",\n        factory.createArrayLiteralExpression(\n          (info.typeParameters ?? []).map((tp) =>\n            factory.createStringLiteral(tp),\n          ),\n        ),\n      ),\n    ],\n    true,\n  );\n\n  return factory.createVariableStatement(\n    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n    factory.createVariableDeclarationList(\n      [factory.createVariableDeclaration(name, undefined, undefined, infoObj)],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\n// ============================================================================\n// typeInfo<T>() Expression Macro\n// ============================================================================\n\nexport const typeInfoMacro = defineExpressionMacro({\n  name: \"typeInfo\",\n  description: \"Get compile-time type information\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n\n    // Get the type argument\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(callExpr, \"typeInfo requires exactly one type argument\");\n      return callExpr;\n    }\n\n    const typeArg = typeArgs[0];\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArg);\n    const typeName = ctx.typeChecker.typeToString(type);\n\n    // Always extract type info directly from the type checker.\n    // This avoids cross-file mutable state and works reliably\n    // regardless of file processing order or incremental builds.\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n    // Determine the kind\n    let kind = \"type\";\n    const symbol = type.getSymbol();\n    if (symbol) {\n      const decls = symbol.getDeclarations();\n      if (decls && decls.length > 0) {\n        const decl = decls[0];\n        if (ts.isInterfaceDeclaration(decl)) kind = \"interface\";\n        else if (ts.isClassDeclaration(decl)) kind = \"class\";\n        else if (ts.isEnumDeclaration(decl)) kind = \"enum\";\n      }\n    }\n\n    const fieldsArray = properties.map((prop) => {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        callExpr,\n      );\n      const decls = prop.getDeclarations();\n      const decl = decls?.[0];\n      const isReadonly =\n        decl && (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl))\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false;\n\n      return factory.createObjectLiteralExpression(\n        [\n          factory.createPropertyAssignment(\n            \"name\",\n            factory.createStringLiteral(prop.name),\n          ),\n          factory.createPropertyAssignment(\n            \"type\",\n            factory.createStringLiteral(ctx.typeChecker.typeToString(propType)),\n          ),\n          factory.createPropertyAssignment(\n            \"optional\",\n            (prop.flags & ts.SymbolFlags.Optional) !== 0\n              ? factory.createTrue()\n              : factory.createFalse(),\n          ),\n          factory.createPropertyAssignment(\n            \"readonly\",\n            isReadonly ? factory.createTrue() : factory.createFalse(),\n          ),\n        ],\n        true,\n      );\n    });\n\n    return factory.createObjectLiteralExpression(\n      [\n        factory.createPropertyAssignment(\n          \"name\",\n          factory.createStringLiteral(typeName),\n        ),\n        factory.createPropertyAssignment(\n          \"kind\",\n          factory.createStringLiteral(kind),\n        ),\n        factory.createPropertyAssignment(\n          \"fields\",\n          factory.createArrayLiteralExpression(fieldsArray, true),\n        ),\n      ],\n      true,\n    );\n  },\n});\n\n// ============================================================================\n// fieldNames<T>() - Get field names as a tuple type\n// ============================================================================\n\nexport const fieldNamesMacro = defineExpressionMacro({\n  name: \"fieldNames\",\n  description: \"Get field names of a type as an array\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n    const typeArgs = callExpr.typeArguments;\n\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(\n        callExpr,\n        \"fieldNames requires exactly one type argument\",\n      );\n      return callExpr;\n    }\n\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n\n    return factory.createArrayLiteralExpression(\n      properties.map((prop) => factory.createStringLiteral(prop.name)),\n    );\n  },\n});\n\n// ============================================================================\n// validator<T>() - Generate a runtime validator\n// ============================================================================\n\nexport const validatorMacro = defineExpressionMacro({\n  name: \"validator\",\n  description: \"Generate a runtime validator for a type\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    const factory = ctx.factory;\n    const typeArgs = callExpr.typeArguments;\n\n    if (!typeArgs || typeArgs.length !== 1) {\n      ctx.reportError(callExpr, \"validator requires exactly one type argument\");\n      return callExpr;\n    }\n\n    const type = ctx.typeChecker.getTypeFromTypeNode(typeArgs[0]);\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n    const typeName = ctx.typeChecker.typeToString(type);\n\n    // Generate validation checks for each property\n    const checks: ts.Statement[] = [];\n\n    for (const prop of properties) {\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n        prop,\n        callExpr,\n      );\n      const propTypeStr = ctx.typeChecker.typeToString(propType);\n      const isOptional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n\n      // Generate type check\n      let checkExpr: ts.Expression;\n\n      if (propTypeStr === \"string\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"string\"),\n        );\n      } else if (propTypeStr === \"number\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"number\"),\n        );\n      } else if (propTypeStr === \"boolean\") {\n        checkExpr = factory.createBinaryExpression(\n          factory.createTypeOfExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n          ),\n          factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n          factory.createStringLiteral(\"boolean\"),\n        );\n      } else {\n        // Skip complex types for now\n        continue;\n      }\n\n      // Add optional check\n      if (isOptional) {\n        checkExpr = factory.createBinaryExpression(\n          factory.createBinaryExpression(\n            factory.createPropertyAccessExpression(\n              factory.createIdentifier(\"value\"),\n              prop.name,\n            ),\n            factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n            factory.createIdentifier(\"undefined\"),\n          ),\n          factory.createToken(ts.SyntaxKind.AmpersandAmpersandToken),\n          checkExpr,\n        );\n      }\n\n      checks.push(\n        factory.createIfStatement(\n          checkExpr,\n          factory.createBlock([\n            factory.createExpressionStatement(\n              factory.createCallExpression(\n                factory.createPropertyAccessExpression(\n                  factory.createIdentifier(\"errors\"),\n                  \"push\",\n                ),\n                undefined,\n                [\n                  factory.createStringLiteral(\n                    `Invalid type for field '${prop.name}': expected ${propTypeStr}`,\n                  ),\n                ],\n              ),\n            ),\n          ]),\n        ),\n      );\n    }\n\n    // Build the validator function\n    return factory.createArrowFunction(\n      undefined,\n      undefined,\n      [\n        factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          factory.createIdentifier(\"value\"),\n          undefined,\n          factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n        ),\n      ],\n      factory.createTypeReferenceNode(\"ValidationResult\", [typeArgs[0]]),\n      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      factory.createBlock(\n        [\n          // const errors: string[] = [];\n          factory.createVariableStatement(\n            undefined,\n            factory.createVariableDeclarationList(\n              [\n                factory.createVariableDeclaration(\n                  \"errors\",\n                  undefined,\n                  factory.createArrayTypeNode(\n                    factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n                  ),\n                  factory.createArrayLiteralExpression([]),\n                ),\n              ],\n              ts.NodeFlags.Const,\n            ),\n          ),\n          // Type check: if (typeof value !== \"object\" || value === null)\n          factory.createIfStatement(\n            factory.createBinaryExpression(\n              factory.createBinaryExpression(\n                factory.createTypeOfExpression(\n                  factory.createIdentifier(\"value\"),\n                ),\n                factory.createToken(ts.SyntaxKind.ExclamationEqualsEqualsToken),\n                factory.createStringLiteral(\"object\"),\n              ),\n              factory.createToken(ts.SyntaxKind.BarBarToken),\n              factory.createBinaryExpression(\n                factory.createIdentifier(\"value\"),\n                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n                factory.createNull(),\n              ),\n            ),\n            factory.createBlock([\n              factory.createReturnStatement(\n                factory.createObjectLiteralExpression(\n                  [\n                    factory.createPropertyAssignment(\n                      \"success\",\n                      factory.createFalse(),\n                    ),\n                    factory.createPropertyAssignment(\n                      \"errors\",\n                      factory.createArrayLiteralExpression([\n                        factory.createStringLiteral(\n                          `Expected object, got ${typeof null}`,\n                        ),\n                      ]),\n                    ),\n                  ],\n                  true,\n                ),\n              ),\n            ]),\n          ),\n          ...checks,\n          // Return result\n          factory.createReturnStatement(\n            factory.createConditionalExpression(\n              factory.createBinaryExpression(\n                factory.createPropertyAccessExpression(\n                  factory.createIdentifier(\"errors\"),\n                  \"length\",\n                ),\n                factory.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken),\n                factory.createNumericLiteral(0),\n              ),\n              factory.createToken(ts.SyntaxKind.QuestionToken),\n              factory.createObjectLiteralExpression(\n                [\n                  factory.createPropertyAssignment(\n                    \"success\",\n                    factory.createTrue(),\n                  ),\n                  factory.createPropertyAssignment(\n                    \"value\",\n                    factory.createAsExpression(\n                      factory.createIdentifier(\"value\"),\n                      typeArgs[0],\n                    ),\n                  ),\n                ],\n                true,\n              ),\n              factory.createToken(ts.SyntaxKind.ColonToken),\n              factory.createObjectLiteralExpression(\n                [\n                  factory.createPropertyAssignment(\n                    \"success\",\n                    factory.createFalse(),\n                  ),\n                  factory.createPropertyAssignment(\n                    \"errors\",\n                    factory.createIdentifier(\"errors\"),\n                  ),\n                ],\n                true,\n              ),\n            ),\n          ),\n        ],\n        true,\n      ),\n    );\n  },\n});\n\n// Register macros\nglobalRegistry.register(reflectAttribute);\nglobalRegistry.register(typeInfoMacro);\nglobalRegistry.register(fieldNamesMacro);\nglobalRegistry.register(validatorMacro);\n\n// ============================================================================\n// Types for Runtime\n// ============================================================================\n\nexport type ValidationResult<T> =\n  | { success: true; value: T }\n  | { success: false; errors: string[] };\n","/**\n * Typeclass Macros - Scala 3-like typeclasses with auto-derivation\n *\n * Provides a complete typeclass system inspired by Scala 3:\n *\n * 1. @typeclass - Defines a typeclass from an interface\n * 2. @instance - Registers a typeclass instance for a type\n * 3. @deriving - Auto-derives typeclass instances for product/sum types\n * 4. summon<TC<A>>() - Compile-time implicit resolution\n * 5. Extension methods - Typeclass methods available directly on types\n *\n * ## Scala 3 Derivation Rules\n *\n * Product types (interfaces/classes with fields):\n *   - If all fields have TC instances, the product type can derive TC\n *   - Derivation combines field instances (e.g., Eq checks all fields equal)\n *\n * Sum types (discriminated unions):\n *   - If all variants have TC instances, the sum type can derive TC\n *   - Derivation dispatches on discriminant\n *\n * ## Example\n *\n * ```typescript\n * // Define a typeclass\n * @typeclass\n * interface Show<A> {\n *   show(a: A): string;\n * }\n *\n * // Provide an instance\n * @instance\n * const showNumber: Show<number> = {\n *   show: (a) => String(a),\n * };\n *\n * // Auto-derive for product types\n * @deriving(Show, Eq)\n * interface Point {\n *   x: number;\n *   y: number;\n * }\n *\n * // Use extension methods\n * const p: Point = { x: 1, y: 2 };\n * p.show();          // \"Point(x = 1, y = 2)\"\n * p.eq({ x: 1, y: 2 }); // true\n *\n * // Summon instances explicitly\n * const showPoint = summon<Show<Point>>();\n * showPoint.show(p); // \"Point(x = 1, y = 2)\"\n * ```\n */\n\nimport * as ts from \"typescript\";\nimport {\n  defineAttributeMacro,\n  defineExpressionMacro,\n  defineDeriveMacro,\n  globalRegistry,\n} from \"../core/registry.js\";\nimport {\n  MacroContext,\n  DeriveTypeInfo,\n  DeriveFieldInfo,\n} from \"../core/types.js\";\n\n// ============================================================================\n// Instance Registry - Tracks typeclass instances at compile time\n// ============================================================================\n\ninterface TypeclassInfo {\n  /** Name of the typeclass (e.g., \"Show\", \"Eq\") */\n  name: string;\n  /** Type parameter name (e.g., \"A\" in Show<A>) */\n  typeParam: string;\n  /** Methods defined by the typeclass */\n  methods: TypeclassMethod[];\n  /** Whether this typeclass supports auto-derivation for products */\n  canDeriveProduct: boolean;\n  /** Whether this typeclass supports auto-derivation for sums */\n  canDeriveSum: boolean;\n}\n\ninterface TypeclassMethod {\n  name: string;\n  /** Parameters (excluding the typeclass's type param, which is the \"self\") */\n  params: Array<{ name: string; typeString: string }>;\n  /** Return type as string */\n  returnType: string;\n  /** Whether the first parameter is the \"self\" type (for extension methods) */\n  isSelfMethod: boolean;\n}\n\ninterface InstanceInfo {\n  /** Typeclass name */\n  typeclassName: string;\n  /** Concrete type this instance is for */\n  forType: string;\n  /** Variable name holding the instance */\n  instanceName: string;\n  /** Whether this was auto-derived */\n  derived: boolean;\n}\n\n/** Global compile-time registry of typeclasses and instances */\nconst typeclassRegistry = new Map<string, TypeclassInfo>();\nconst instanceRegistry: InstanceInfo[] = [];\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction uncapitalize(str: string): string {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction instanceVarName(tcName: string, typeName: string): string {\n  return `${uncapitalize(tcName)}${capitalize(typeName)}`;\n}\n\nfunction getBaseType(field: DeriveFieldInfo): string {\n  const typeStr = field.typeString.toLowerCase();\n  if (typeStr === \"number\" || typeStr.includes(\"number\")) return \"number\";\n  if (typeStr === \"string\" || typeStr.includes(\"string\")) return \"string\";\n  if (typeStr === \"boolean\" || typeStr.includes(\"boolean\")) return \"boolean\";\n  if (typeStr.startsWith(\"array\") || typeStr.includes(\"[]\")) return \"array\";\n  return \"object\";\n}\n\n/**\n * Find a registered instance for a given typeclass and type.\n */\nfunction findInstance(\n  tcName: string,\n  typeName: string,\n): InstanceInfo | undefined {\n  return instanceRegistry.find(\n    (i) => i.typeclassName === tcName && i.forType === typeName,\n  );\n}\n\n/**\n * Get the typeclass info for a given name.\n */\nfunction getTypeclass(name: string): TypeclassInfo | undefined {\n  return typeclassRegistry.get(name);\n}\n\n// ============================================================================\n// @typeclass - Attribute Macro\n// ============================================================================\n// Transforms an interface into a typeclass definition.\n//\n// Input:\n//   @typeclass\n//   interface Show<A> {\n//     show(a: A): string;\n//   }\n//\n// Output:\n//   interface Show<A> {\n//     show(a: A): string;\n//   }\n//   namespace Show {\n//     export function summon<A>(instances: Record<string, any>): Show<A> { ... }\n//   }\n//   // + registers typeclass metadata for derivation\n// ============================================================================\n\nexport const typeclassAttribute = defineAttributeMacro({\n  name: \"typeclass\",\n  description:\n    \"Define a typeclass from an interface, enabling derivation and extension methods\",\n  validTargets: [\"interface\"],\n\n  expand(\n    ctx: MacroContext,\n    _decorator: ts.Decorator,\n    target: ts.Declaration,\n    _args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (!ts.isInterfaceDeclaration(target)) {\n      ctx.reportError(target, \"@typeclass can only be applied to interfaces\");\n      return target;\n    }\n\n    const tcName = target.name.text;\n    const typeParams = target.typeParameters;\n\n    if (!typeParams || typeParams.length === 0) {\n      ctx.reportError(\n        target,\n        \"@typeclass interface must have at least one type parameter (e.g., interface Show<A>)\",\n      );\n      return target;\n    }\n\n    const typeParam = typeParams[0].name.text;\n\n    // Extract methods from the interface\n    const methods: TypeclassMethod[] = [];\n    for (const member of target.members) {\n      if (ts.isMethodSignature(member) && member.name) {\n        const methodName = ts.isIdentifier(member.name)\n          ? member.name.text\n          : member.name.getText();\n\n        const params: Array<{ name: string; typeString: string }> = [];\n        let isSelfMethod = false;\n\n        for (let i = 0; i < member.parameters.length; i++) {\n          const param = member.parameters[i];\n          const paramName = ts.isIdentifier(param.name)\n            ? param.name.text\n            : param.name.getText();\n          const paramType = param.type ? param.type.getText() : \"unknown\";\n\n          // Check if this parameter uses the typeclass's type param\n          if (i === 0 && paramType === typeParam) {\n            isSelfMethod = true;\n          }\n\n          params.push({ name: paramName, typeString: paramType });\n        }\n\n        const returnType = member.type ? member.type.getText() : \"void\";\n\n        methods.push({\n          name: methodName,\n          params,\n          returnType,\n          isSelfMethod,\n        });\n      }\n    }\n\n    // Register the typeclass\n    const tcInfo: TypeclassInfo = {\n      name: tcName,\n      typeParam,\n      methods,\n      canDeriveProduct: true,\n      canDeriveSum: true,\n    };\n    typeclassRegistry.set(tcName, tcInfo);\n\n    // Generate the companion namespace with utility functions\n    const companionCode = generateCompanionNamespace(tcInfo);\n\n    // Generate extension method helpers\n    const extensionCode = generateExtensionHelpers(tcInfo);\n\n    const statements = [\n      ...ctx.parseStatements(companionCode),\n      ...ctx.parseStatements(extensionCode),\n    ];\n\n    return [target, ...statements];\n  },\n});\n\n/**\n * Generate a companion namespace for a typeclass.\n *\n * Scala 3 equivalent:\n *   object Show {\n *     def summon[A](using tc: Show[A]): Show[A] = tc\n *     def derived[A](using Mirror.ProductOf[A]): Show[A] = ...\n *   }\n */\nfunction generateCompanionNamespace(tc: TypeclassInfo): string {\n  const { name } = tc;\n  const registryVar = `__${uncapitalize(name)}Instances__`;\n\n  return `\n// Typeclass instance registry for ${name}\nconst ${registryVar}: Map<string, ${name}<any>> = new Map();\n\nnamespace ${name} {\n  /** Register an instance of ${name} for type T */\n  export function registerInstance<T>(typeName: string, instance: ${name}<T>): void {\n    ${registryVar}.set(typeName, instance);\n  }\n\n  /** Summon (resolve) an instance of ${name} for type T */\n  export function summon<T>(typeName: string): ${name}<T> {\n    const instance = ${registryVar}.get(typeName);\n    if (!instance) {\n      throw new Error(\\`No ${name} instance found for type '\\${typeName}'\\`);\n    }\n    return instance as ${name}<T>;\n  }\n\n  /** Check if an instance exists for the given type */\n  export function hasInstance(typeName: string): boolean {\n    return ${registryVar}.has(typeName);\n  }\n\n  /** Get all registered type names */\n  export function registeredTypes(): string[] {\n    return Array.from(${registryVar}.keys());\n  }\n}\n`;\n}\n\n/**\n * Generate extension method helpers for a typeclass.\n *\n * Scala 3 equivalent:\n *   extension [A](a: A)(using tc: Show[A])\n *     def show: String = tc.show(a)\n *\n * In TypeScript, we generate functions that look up the instance and call the method:\n *   function show<A>(a: A, typeName: string): string {\n *     return Show.summon<A>(typeName).show(a);\n *   }\n */\nfunction generateExtensionHelpers(tc: TypeclassInfo): string {\n  const { name, methods } = tc;\n  const extensionFns: string[] = [];\n\n  for (const method of methods) {\n    if (method.isSelfMethod) {\n      // This is a \"self\" method - generate an extension function\n      const otherParams = method.params.slice(1);\n      const otherParamDecls = otherParams\n        .map((p) => `${p.name}: ${p.typeString}`)\n        .join(\", \");\n      const otherParamNames = otherParams.map((p) => p.name).join(\", \");\n      const allArgs = [\"self\", ...otherParams.map((p) => p.name)].join(\", \");\n\n      const paramList = otherParamDecls\n        ? `self: any, ${otherParamDecls}, typeName: string`\n        : `self: any, typeName: string`;\n\n      extensionFns.push(`\n/** Extension method: ${method.name} via ${name} typeclass */\nfunction ${uncapitalize(name)}${capitalize(method.name)}<A>(${paramList}): ${method.returnType} {\n  return ${name}.summon<A>(typeName).${method.name}(${allArgs});\n}\n`);\n    }\n  }\n\n  return extensionFns.join(\"\\n\");\n}\n\n// ============================================================================\n// @instance - Attribute Macro\n// ============================================================================\n// Registers a typeclass instance for a specific type.\n//\n// Input:\n//   @instance(\"number\")\n//   const showNumber: Show<number> = {\n//     show: (a) => String(a),\n//   };\n//\n// Output:\n//   const showNumber: Show<number> = {\n//     show: (a) => String(a),\n//   };\n//   Show.registerInstance<number>(\"number\", showNumber);\n// ============================================================================\n\nexport const instanceAttribute = defineAttributeMacro({\n  name: \"instance\",\n  description: \"Register a typeclass instance for a specific type\",\n  validTargets: [\"property\", \"class\"],\n\n  expand(\n    ctx: MacroContext,\n    _decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    // Get the type name from the first argument\n    if (args.length === 0) {\n      ctx.reportError(\n        target,\n        '@instance requires a type name argument, e.g., @instance(\"number\")',\n      );\n      return target;\n    }\n\n    const typeNameArg = args[0];\n    let typeName: string;\n    if (ts.isStringLiteral(typeNameArg)) {\n      typeName = typeNameArg.text;\n    } else {\n      ctx.reportError(\n        typeNameArg,\n        \"@instance argument must be a string literal\",\n      );\n      return target;\n    }\n\n    // Extract the typeclass name from the type annotation\n    let tcName: string | undefined;\n    let varName: string | undefined;\n\n    if (ts.isVariableStatement(target)) {\n      const decl = target.declarationList.declarations[0];\n      if (decl && ts.isIdentifier(decl.name)) {\n        varName = decl.name.text;\n      }\n      if (decl && decl.type && ts.isTypeReferenceNode(decl.type)) {\n        tcName = decl.type.typeName.getText();\n      }\n    } else if (ts.isVariableDeclaration(target)) {\n      if (ts.isIdentifier(target.name)) {\n        varName = target.name.text;\n      }\n      if (target.type && ts.isTypeReferenceNode(target.type)) {\n        tcName = target.type.typeName.getText();\n      }\n    }\n\n    // Fallback: try to infer from the second argument\n    if (!tcName && args.length > 1 && ts.isStringLiteral(args[1])) {\n      tcName = args[1].text;\n    }\n\n    if (!tcName || !varName) {\n      ctx.reportError(\n        target,\n        \"@instance: could not determine typeclass name. Ensure the variable has a type annotation like Show<number>\",\n      );\n      return target;\n    }\n\n    // Register in our compile-time registry\n    instanceRegistry.push({\n      typeclassName: tcName,\n      forType: typeName,\n      instanceName: varName,\n      derived: false,\n    });\n\n    // Generate registration call\n    const registrationCode = `${tcName}.registerInstance<${typeName}>(\"${typeName}\", ${varName});`;\n    const registrationStatements = ctx.parseStatements(registrationCode);\n\n    return [target, ...registrationStatements];\n  },\n});\n\n// ============================================================================\n// @deriving - Derive Macro for Auto-Derivation\n// ============================================================================\n// Auto-derives typeclass instances for product types (structs) and sum types\n// (discriminated unions) following Scala 3 derivation rules.\n//\n// Product type derivation:\n//   If all fields of a product type have instances of TC, then TC can be\n//   derived for the product type by combining field instances.\n//\n// Sum type derivation:\n//   If all variants of a sum type have instances of TC, then TC can be\n//   derived for the sum type by dispatching on the discriminant.\n//\n// Input:\n//   @deriving(Show, Eq)\n//   interface Point {\n//     x: number;\n//     y: number;\n//   }\n//\n// Output:\n//   interface Point { x: number; y: number; }\n//   const showPoint: Show<Point> = {\n//     show: (a) => `Point(x = ${showNumber.show(a.x)}, y = ${showNumber.show(a.y)})`,\n//   };\n//   Show.registerInstance<Point>(\"Point\", showPoint);\n//   const eqPoint: Eq<Point> = {\n//     eq: (a, b) => eqNumber.eq(a.x, b.x) && eqNumber.eq(a.y, b.y),\n//   };\n//   Eq.registerInstance<Point>(\"Point\", eqPoint);\n// ============================================================================\n\n/**\n * Built-in typeclass definitions with their derivation strategies.\n *\n * These define how to auto-derive instances for product and sum types.\n * Each entry specifies:\n * - methods: The typeclass methods to generate\n * - productDerive: How to combine field instances for product types\n * - sumDerive: How to dispatch on variants for sum types\n */\ninterface BuiltinTypeclassDerivation {\n  /** Generate instance code for a product type */\n  deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string;\n  /** Generate instance code for a sum type */\n  deriveSum(\n    typeName: string,\n    discriminant: string,\n    variants: Array<{ tag: string; typeName: string }>,\n  ): string;\n}\n\nconst builtinDerivations: Record<string, BuiltinTypeclassDerivation> = {\n  Show: {\n    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n      const fieldShows = fields\n        .map((f) => {\n          const inst = instanceVarName(\"show\", getBaseType(f));\n          return `${f.name} = \\${${inst}.show(a.${f.name})}`;\n        })\n        .join(\", \");\n\n      const varName = instanceVarName(\"show\", typeName);\n      return `\nconst ${varName}: Show<${typeName}> = {\n  show: (a: ${typeName}): string => \\`${typeName}(${fieldShows})\\`,\n};\nShow.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n\n    deriveSum(\n      typeName: string,\n      discriminant: string,\n      variants: Array<{ tag: string; typeName: string }>,\n    ): string {\n      const varName = instanceVarName(\"show\", typeName);\n      const cases = variants\n        .map((v) => {\n          const inst = instanceVarName(\"show\", v.typeName);\n          return `    case \"${v.tag}\": return ${inst}.show(a as any);`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Show<${typeName}> = {\n  show: (a: ${typeName}): string => {\n    switch ((a as any).${discriminant}) {\n${cases}\n      default: return String(a);\n    }\n  },\n};\nShow.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n  },\n\n  Eq: {\n    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n      const fieldEqs = fields.map((f) => {\n        const inst = instanceVarName(\"eq\", getBaseType(f));\n        return `${inst}.eq(a.${f.name}, b.${f.name})`;\n      });\n      const body = fieldEqs.length > 0 ? fieldEqs.join(\" && \") : \"true\";\n\n      const varName = instanceVarName(\"eq\", typeName);\n      return `\nconst ${varName}: Eq<${typeName}> = {\n  eq: (a: ${typeName}, b: ${typeName}): boolean => ${body},\n  neq: (a: ${typeName}, b: ${typeName}): boolean => !(${body}),\n};\nEq.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n\n    deriveSum(\n      typeName: string,\n      discriminant: string,\n      variants: Array<{ tag: string; typeName: string }>,\n    ): string {\n      const varName = instanceVarName(\"eq\", typeName);\n      const cases = variants\n        .map((v) => {\n          const inst = instanceVarName(\"eq\", v.typeName);\n          return `    case \"${v.tag}\": return (b as any).${discriminant} === \"${v.tag}\" && ${inst}.eq(a as any, b as any);`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Eq<${typeName}> = {\n  eq: (a: ${typeName}, b: ${typeName}): boolean => {\n    if ((a as any).${discriminant} !== (b as any).${discriminant}) return false;\n    switch ((a as any).${discriminant}) {\n${cases}\n      default: return false;\n    }\n  },\n  neq: (a: ${typeName}, b: ${typeName}): boolean => !${varName}.eq(a, b),\n};\nEq.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n  },\n\n  Ord: {\n    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n      const varName = instanceVarName(\"ord\", typeName);\n      const fieldComparisons = fields\n        .map((f) => {\n          const inst = instanceVarName(\"ord\", getBaseType(f));\n          return `  { const c = ${inst}.compare(a.${f.name}, b.${f.name}); if (c !== 0) return c; }`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Ord<${typeName}> = {\n  compare: (a: ${typeName}, b: ${typeName}): -1 | 0 | 1 => {\n${fieldComparisons}\n    return 0;\n  },\n};\nOrd.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n\n    deriveSum(\n      typeName: string,\n      discriminant: string,\n      variants: Array<{ tag: string; typeName: string }>,\n    ): string {\n      const varName = instanceVarName(\"ord\", typeName);\n      const tagOrder = variants.map((v, i) => `\"${v.tag}\": ${i}`).join(\", \");\n      const cases = variants\n        .map((v) => {\n          const inst = instanceVarName(\"ord\", v.typeName);\n          return `    case \"${v.tag}\": return ${inst}.compare(a as any, b as any);`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Ord<${typeName}> = {\n  compare: (a: ${typeName}, b: ${typeName}): -1 | 0 | 1 => {\n    const tagOrder: Record<string, number> = { ${tagOrder} };\n    const aTag = (a as any).${discriminant};\n    const bTag = (b as any).${discriminant};\n    if (aTag !== bTag) return aTag < bTag ? -1 : 1;\n    switch (aTag) {\n${cases}\n      default: return 0;\n    }\n  },\n};\nOrd.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n  },\n\n  Hash: {\n    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n      const varName = instanceVarName(\"hash\", typeName);\n      const fieldHashes = fields\n        .map((f) => {\n          const inst = instanceVarName(\"hash\", getBaseType(f));\n          return `  hash = ((hash << 5) + hash) ^ ${inst}.hash(a.${f.name});`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Hash<${typeName}> = {\n  hash: (a: ${typeName}): number => {\n    let hash = 5381;\n${fieldHashes}\n    return hash >>> 0;\n  },\n};\nHash.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n\n    deriveSum(\n      typeName: string,\n      discriminant: string,\n      variants: Array<{ tag: string; typeName: string }>,\n    ): string {\n      const varName = instanceVarName(\"hash\", typeName);\n      const cases = variants\n        .map((v, i) => {\n          const inst = instanceVarName(\"hash\", v.typeName);\n          return `    case \"${v.tag}\": return ((${i} << 16) | ${inst}.hash(a as any)) >>> 0;`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Hash<${typeName}> = {\n  hash: (a: ${typeName}): number => {\n    switch ((a as any).${discriminant}) {\n${cases}\n      default: return 0;\n    }\n  },\n};\nHash.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n  },\n\n  Functor: {\n    deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n      // Functor derivation for product types - maps over the \"contained\" value\n      // This is a simplified version; real Functor derivation would need\n      // to know which field is the \"contained\" type parameter\n      const varName = instanceVarName(\"functor\", typeName);\n      return `\nconst ${varName}: Functor<${typeName}> = {\n  map: <A, B>(fa: ${typeName}, f: (a: A) => B): ${typeName} => {\n    return { ...fa } as any;\n  },\n};\nFunctor.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n\n    deriveSum(\n      typeName: string,\n      discriminant: string,\n      variants: Array<{ tag: string; typeName: string }>,\n    ): string {\n      const varName = instanceVarName(\"functor\", typeName);\n      const cases = variants\n        .map((v) => {\n          const inst = instanceVarName(\"functor\", v.typeName);\n          return `    case \"${v.tag}\": return ${inst}.map(fa as any, f) as any;`;\n        })\n        .join(\"\\n\");\n\n      return `\nconst ${varName}: Functor<${typeName}> = {\n  map: <A, B>(fa: ${typeName}, f: (a: A) => B): ${typeName} => {\n    switch ((fa as any).${discriminant}) {\n${cases}\n      default: return fa;\n    }\n  },\n};\nFunctor.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n    },\n  },\n};\n\n// ============================================================================\n// Deriving Derive Macro\n// ============================================================================\n\n/**\n * Create a derive macro for a specific typeclass that uses auto-derivation.\n */\nfunction createTypeclassDeriveMacro(tcName: string) {\n  return defineDeriveMacro({\n    name: `${tcName}TC`,\n    description: `Auto-derive ${tcName} typeclass instance`,\n\n    expand(\n      ctx: MacroContext,\n      target:\n        | ts.InterfaceDeclaration\n        | ts.ClassDeclaration\n        | ts.TypeAliasDeclaration,\n      typeInfo: DeriveTypeInfo,\n    ): ts.Statement[] {\n      const derivation = builtinDerivations[tcName];\n      if (!derivation) {\n        ctx.reportError(\n          target,\n          `No built-in derivation strategy for typeclass '${tcName}'. ` +\n            `Register a custom derivation or provide a manual instance.`,\n        );\n        return [];\n      }\n\n      const { name: typeName, fields } = typeInfo;\n\n      // Check if this is a sum type (discriminated union)\n      if (ts.isTypeAliasDeclaration(target) && target.type) {\n        const sumInfo = tryExtractSumType(ctx, target);\n        if (sumInfo) {\n          const code = derivation.deriveSum(\n            typeName,\n            sumInfo.discriminant,\n            sumInfo.variants,\n          );\n          const stmts = ctx.parseStatements(code);\n\n          // Register in compile-time registry\n          instanceRegistry.push({\n            typeclassName: tcName,\n            forType: typeName,\n            instanceName: instanceVarName(uncapitalize(tcName), typeName),\n            derived: true,\n          });\n\n          return stmts;\n        }\n      }\n\n      // Product type derivation\n      const code = derivation.deriveProduct(typeName, fields);\n      const stmts = ctx.parseStatements(code);\n\n      // Register in compile-time registry\n      instanceRegistry.push({\n        typeclassName: tcName,\n        forType: typeName,\n        instanceName: instanceVarName(uncapitalize(tcName), typeName),\n        derived: true,\n      });\n\n      return stmts;\n    },\n  });\n}\n\n/**\n * Try to extract sum type information from a type alias declaration.\n * Looks for discriminated unions like:\n *   type Shape = Circle | Rectangle\n * where each variant has a common discriminant field (e.g., \"kind\" or \"_tag\").\n */\nfunction tryExtractSumType(\n  ctx: MacroContext,\n  target: ts.TypeAliasDeclaration,\n):\n  | { discriminant: string; variants: Array<{ tag: string; typeName: string }> }\n  | undefined {\n  if (!ts.isUnionTypeNode(target.type)) {\n    return undefined;\n  }\n\n  const variants: Array<{ tag: string; typeName: string }> = [];\n  let discriminant: string | undefined;\n\n  for (const member of target.type.types) {\n    if (!ts.isTypeReferenceNode(member)) {\n      return undefined; // Not a named type reference\n    }\n\n    const typeName = member.typeName.getText();\n    const type = ctx.typeChecker.getTypeFromTypeNode(member);\n    const props = ctx.typeChecker.getPropertiesOfType(type);\n\n    // Look for common discriminant fields\n    for (const prop of props) {\n      const name = prop.name;\n      if (\n        name === \"kind\" ||\n        name === \"_tag\" ||\n        name === \"type\" ||\n        name === \"tag\"\n      ) {\n        if (!discriminant) {\n          discriminant = name;\n        } else if (discriminant !== name) {\n          continue;\n        }\n\n        // Get the literal type of the discriminant\n        const declarations = prop.getDeclarations();\n        if (declarations && declarations.length > 0) {\n          const decl = declarations[0];\n          const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(\n            prop,\n            decl,\n          );\n          if (propType.isStringLiteral()) {\n            variants.push({ tag: propType.value, typeName });\n          }\n        }\n      }\n    }\n  }\n\n  if (discriminant && variants.length > 0) {\n    return { discriminant, variants };\n  }\n\n  return undefined;\n}\n\n// Register derive macros for built-in typeclasses\nconst showTCDerive = createTypeclassDeriveMacro(\"Show\");\nconst eqTCDerive = createTypeclassDeriveMacro(\"Eq\");\nconst ordTCDerive = createTypeclassDeriveMacro(\"Ord\");\nconst hashTCDerive = createTypeclassDeriveMacro(\"Hash\");\nconst functorTCDerive = createTypeclassDeriveMacro(\"Functor\");\n\n// ============================================================================\n// @deriving - Attribute Macro (Convenience)\n// ============================================================================\n// A convenience attribute that combines multiple typeclass derivations.\n//\n// @deriving(Show, Eq, Ord)\n// interface Point { x: number; y: number; }\n// ============================================================================\n\nexport const derivingAttribute = defineAttributeMacro({\n  name: \"deriving\",\n  description:\n    \"Auto-derive typeclass instances for a type (Scala 3-like derives clause)\",\n  validTargets: [\"interface\", \"class\", \"type\"],\n\n  expand(\n    ctx: MacroContext,\n    _decorator: ts.Decorator,\n    target: ts.Declaration,\n    args: readonly ts.Expression[],\n  ): ts.Node | ts.Node[] {\n    if (\n      !ts.isInterfaceDeclaration(target) &&\n      !ts.isClassDeclaration(target) &&\n      !ts.isTypeAliasDeclaration(target)\n    ) {\n      ctx.reportError(\n        target,\n        \"@deriving can only be applied to interfaces, classes, or type aliases\",\n      );\n      return target;\n    }\n\n    const typeName = target.name?.text ?? \"Anonymous\";\n    const type = ctx.typeChecker.getTypeAtLocation(target);\n    const typeParameters = target.typeParameters\n      ? Array.from(target.typeParameters)\n      : [];\n\n    // Extract fields\n    const fields: DeriveFieldInfo[] = [];\n    const properties = ctx.typeChecker.getPropertiesOfType(type);\n    for (const prop of properties) {\n      const declarations = prop.getDeclarations();\n      if (!declarations || declarations.length === 0) continue;\n      const decl = declarations[0];\n      const propType = ctx.typeChecker.getTypeOfSymbolAtLocation(prop, decl);\n      const propTypeString = ctx.typeChecker.typeToString(propType);\n      const optional = (prop.flags & ts.SymbolFlags.Optional) !== 0;\n      const readonly =\n        ts.isPropertyDeclaration(decl) || ts.isPropertySignature(decl)\n          ? (decl.modifiers?.some(\n              (m) => m.kind === ts.SyntaxKind.ReadonlyKeyword,\n            ) ?? false)\n          : false;\n\n      fields.push({\n        name: prop.name,\n        typeString: propTypeString,\n        type: propType,\n        optional,\n        readonly,\n      });\n    }\n\n    const typeInfo: DeriveTypeInfo = {\n      name: typeName,\n      fields,\n      typeParameters,\n      type,\n    };\n\n    const allStatements: ts.Statement[] = [];\n\n    for (const arg of args) {\n      if (!ts.isIdentifier(arg)) {\n        ctx.reportError(arg, \"@deriving arguments must be typeclass names\");\n        continue;\n      }\n\n      const tcName = arg.text;\n      const derivation = builtinDerivations[tcName];\n\n      if (derivation) {\n        // Use built-in derivation\n        let code: string;\n\n        // Check for sum type\n        if (ts.isTypeAliasDeclaration(target)) {\n          const sumInfo = tryExtractSumType(ctx, target);\n          if (sumInfo) {\n            code = derivation.deriveSum(\n              typeName,\n              sumInfo.discriminant,\n              sumInfo.variants,\n            );\n          } else {\n            code = derivation.deriveProduct(typeName, fields);\n          }\n        } else {\n          code = derivation.deriveProduct(typeName, fields);\n        }\n\n        allStatements.push(...ctx.parseStatements(code));\n\n        instanceRegistry.push({\n          typeclassName: tcName,\n          forType: typeName,\n          instanceName: instanceVarName(uncapitalize(tcName), typeName),\n          derived: true,\n        });\n      } else {\n        // Try the derive macro registry\n        const deriveMacro = globalRegistry.getDerive(`${tcName}TC`);\n        if (deriveMacro) {\n          const stmts = deriveMacro.expand(ctx, target, typeInfo);\n          allStatements.push(...stmts);\n        } else {\n          ctx.reportError(\n            arg,\n            `No derivation strategy found for typeclass '${tcName}'. ` +\n              `Define a custom derivation or provide a manual instance.`,\n          );\n        }\n      }\n    }\n\n    return [target, ...allStatements];\n  },\n});\n\n// ============================================================================\n// summon<TC<A>>() - Expression Macro\n// ============================================================================\n// Scala 3-like implicit resolution at compile time.\n//\n// const showPoint = summon<Show<Point>>();\n// // Resolves to: Show.summon<Point>(\"Point\")\n// ============================================================================\n\nexport const summonMacro = defineExpressionMacro({\n  name: \"summon\",\n  description:\n    \"Resolve a typeclass instance at compile time (Scala 3-like summon)\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    _args: readonly ts.Expression[],\n  ): ts.Expression {\n    // Get the type argument: summon<Show<Point>>()\n    const typeArgs = callExpr.typeArguments;\n    if (!typeArgs || typeArgs.length === 0) {\n      ctx.reportError(\n        callExpr,\n        \"summon requires a type argument, e.g., summon<Show<Point>>()\",\n      );\n      return callExpr;\n    }\n\n    const typeArg = typeArgs[0];\n    if (!ts.isTypeReferenceNode(typeArg)) {\n      ctx.reportError(\n        callExpr,\n        \"summon type argument must be a type reference like Show<Point>\",\n      );\n      return callExpr;\n    }\n\n    const tcName = typeArg.typeName.getText();\n    const innerTypeArgs = typeArg.typeArguments;\n\n    if (!innerTypeArgs || innerTypeArgs.length === 0) {\n      ctx.reportError(\n        callExpr,\n        `summon<${tcName}<...>>() requires the typeclass to have a type argument`,\n      );\n      return callExpr;\n    }\n\n    const innerType = innerTypeArgs[0];\n    let typeName: string;\n\n    if (ts.isTypeReferenceNode(innerType)) {\n      typeName = innerType.typeName.getText();\n    } else if (innerType.kind === ts.SyntaxKind.NumberKeyword) {\n      typeName = \"number\";\n    } else if (innerType.kind === ts.SyntaxKind.StringKeyword) {\n      typeName = \"string\";\n    } else if (innerType.kind === ts.SyntaxKind.BooleanKeyword) {\n      typeName = \"boolean\";\n    } else {\n      typeName = innerType.getText();\n    }\n\n    // Generate: TC.summon<Type>(\"Type\")\n    const code = `${tcName}.summon<${typeName}>(\"${typeName}\")`;\n    return ctx.parseExpression(code);\n  },\n});\n\n// ============================================================================\n// extend() - Expression Macro for Extension Methods\n// ============================================================================\n// Provides Scala 3-like extension method syntax.\n//\n// extend(point).show()\n// // Resolves to: Show.summon<Point>(\"Point\").show(point)\n//\n// extend(point).eq(otherPoint)\n// // Resolves to: Eq.summon<Point>(\"Point\").eq(point, otherPoint)\n// ============================================================================\n\nexport const extendMacro = defineExpressionMacro({\n  name: \"extend\",\n  description: \"Call extension methods on a value via typeclass instances\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[],\n  ): ts.Expression {\n    if (args.length === 0) {\n      ctx.reportError(callExpr, \"extend() requires a value argument\");\n      return callExpr;\n    }\n\n    // We need to look at the parent to see what method is being called\n    // extend(value).method(args...)\n    const parent = callExpr.parent;\n    if (!parent || !ts.isPropertyAccessExpression(parent)) {\n      ctx.reportError(\n        callExpr,\n        \"extend() must be followed by a method call, e.g., extend(value).show()\",\n      );\n      return callExpr;\n    }\n\n    const methodName = parent.name.text;\n    const value = args[0];\n\n    // Try to determine the type of the value\n    const valueType = ctx.typeChecker.getTypeAtLocation(value);\n    const typeName = ctx.typeChecker.typeToString(valueType);\n\n    // Find which typeclass provides this method\n    for (const [tcName, tcInfo] of typeclassRegistry) {\n      const method = tcInfo.methods.find((m) => m.name === methodName);\n      if (method) {\n        // Found it! Generate the call\n        const grandParent = parent.parent;\n        if (grandParent && ts.isCallExpression(grandParent)) {\n          const extraArgs = Array.from(grandParent.arguments)\n            .map((a) => a.getText())\n            .join(\", \");\n          const allArgs = extraArgs\n            ? `${value.getText()}, ${extraArgs}`\n            : value.getText();\n          const code = `${tcName}.summon<${typeName}>(\"${typeName}\").${methodName}(${allArgs})`;\n          return ctx.parseExpression(code);\n        }\n\n        const code = `${tcName}.summon<${typeName}>(\"${typeName}\").${methodName}(${value.getText()})`;\n        return ctx.parseExpression(code);\n      }\n    }\n\n    ctx.reportError(\n      parent,\n      `No typeclass instance found providing method '${methodName}' for type '${typeName}'`,\n    );\n    return callExpr;\n  },\n});\n\n// ============================================================================\n// Built-in Typeclass Interfaces (for reference/documentation)\n// ============================================================================\n// These are the standard typeclass interfaces that users should define\n// in their code. The macros will work with any interface that follows\n// the typeclass pattern.\n\n/**\n * Generate code for standard typeclass interfaces.\n * Users can call this or define their own.\n */\nexport function generateStandardTypeclasses(): string {\n  return `\n// ============================================================================\n// Standard Typeclasses\n// ============================================================================\n\n/** Equality typeclass - Scala 3: trait Eq[A] */\n@typeclass\ninterface Eq<A> {\n  eq(a: A, b: A): boolean;\n  neq(a: A, b: A): boolean;\n}\n\n/** Ordering typeclass - Scala 3: trait Ord[A] extends Eq[A] */\n@typeclass\ninterface Ord<A> {\n  compare(a: A, b: A): -1 | 0 | 1;\n}\n\n/** Show typeclass - Scala 3: trait Show[A] */\n@typeclass\ninterface Show<A> {\n  show(a: A): string;\n}\n\n/** Hash typeclass */\n@typeclass\ninterface Hash<A> {\n  hash(a: A): number;\n}\n\n/** Semigroup typeclass - Scala 3: trait Semigroup[A] */\n@typeclass\ninterface Semigroup<A> {\n  combine(a: A, b: A): A;\n}\n\n/** Monoid typeclass - Scala 3: trait Monoid[A] extends Semigroup[A] */\n@typeclass\ninterface Monoid<A> {\n  empty(): A;\n  combine(a: A, b: A): A;\n}\n\n/** Functor typeclass - Scala 3: trait Functor[F[_]] */\n@typeclass\ninterface Functor<F> {\n  map<A, B>(fa: F, f: (a: A) => B): F;\n}\n\n// ============================================================================\n// Primitive Instances\n// ============================================================================\n\n// Eq instances for primitives\nconst eqNumber: Eq<number> = {\n  eq: (a, b) => a === b,\n  neq: (a, b) => a !== b,\n};\nEq.registerInstance<number>(\"number\", eqNumber);\n\nconst eqString: Eq<string> = {\n  eq: (a, b) => a === b,\n  neq: (a, b) => a !== b,\n};\nEq.registerInstance<string>(\"string\", eqString);\n\nconst eqBoolean: Eq<boolean> = {\n  eq: (a, b) => a === b,\n  neq: (a, b) => a !== b,\n};\nEq.registerInstance<boolean>(\"boolean\", eqBoolean);\n\n// Show instances for primitives\nconst showNumber: Show<number> = {\n  show: (a) => String(a),\n};\nShow.registerInstance<number>(\"number\", showNumber);\n\nconst showString: Show<string> = {\n  show: (a) => JSON.stringify(a),\n};\nShow.registerInstance<string>(\"string\", showString);\n\nconst showBoolean: Show<boolean> = {\n  show: (a) => String(a),\n};\nShow.registerInstance<boolean>(\"boolean\", showBoolean);\n\n// Ord instances for primitives\nconst ordNumber: Ord<number> = {\n  compare: (a, b) => a < b ? -1 : a > b ? 1 : 0,\n};\nOrd.registerInstance<number>(\"number\", ordNumber);\n\nconst ordString: Ord<string> = {\n  compare: (a, b) => a < b ? -1 : a > b ? 1 : 0,\n};\nOrd.registerInstance<string>(\"string\", ordString);\n\n// Hash instances for primitives\nconst hashNumber: Hash<number> = {\n  hash: (a) => a | 0,\n};\nHash.registerInstance<number>(\"number\", hashNumber);\n\nconst hashString: Hash<string> = {\n  hash: (a) => {\n    let h = 5381;\n    for (let i = 0; i < a.length; i++) {\n      h = ((h << 5) + h) + a.charCodeAt(i);\n    }\n    return h >>> 0;\n  },\n};\nHash.registerInstance<string>(\"string\", hashString);\n\nconst hashBoolean: Hash<boolean> = {\n  hash: (a) => a ? 1 : 0,\n};\nHash.registerInstance<boolean>(\"boolean\", hashBoolean);\n\n// Semigroup instances for primitives\nconst semigroupNumber: Semigroup<number> = {\n  combine: (a, b) => a + b,\n};\nSemigroup.registerInstance<number>(\"number\", semigroupNumber);\n\nconst semigroupString: Semigroup<string> = {\n  combine: (a, b) => a + b,\n};\nSemigroup.registerInstance<string>(\"string\", semigroupString);\n\n// Monoid instances for primitives\nconst monoidNumber: Monoid<number> = {\n  empty: () => 0,\n  combine: (a, b) => a + b,\n};\nMonoid.registerInstance<number>(\"number\", monoidNumber);\n\nconst monoidString: Monoid<string> = {\n  empty: () => \"\",\n  combine: (a, b) => a + b,\n};\nMonoid.registerInstance<string>(\"string\", monoidString);\n`;\n}\n\n// ============================================================================\n// Semigroup/Monoid derivation for products\n// ============================================================================\n\nbuiltinDerivations[\"Semigroup\"] = {\n  deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n    const varName = instanceVarName(\"semigroup\", typeName);\n    const fieldCombines = fields\n      .map((f) => {\n        const inst = instanceVarName(\"semigroup\", getBaseType(f));\n        return `    ${f.name}: ${inst}.combine(a.${f.name}, b.${f.name})`;\n      })\n      .join(\",\\n\");\n\n    return `\nconst ${varName}: Semigroup<${typeName}> = {\n  combine: (a: ${typeName}, b: ${typeName}): ${typeName} => ({\n${fieldCombines}\n  }),\n};\nSemigroup.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n  },\n\n  deriveSum(\n    _typeName: string,\n    _discriminant: string,\n    _variants: Array<{ tag: string; typeName: string }>,\n  ): string {\n    // Semigroup cannot generally be derived for sum types\n    return `// Semigroup cannot be auto-derived for sum types`;\n  },\n};\n\nbuiltinDerivations[\"Monoid\"] = {\n  deriveProduct(typeName: string, fields: DeriveFieldInfo[]): string {\n    const varName = instanceVarName(\"monoid\", typeName);\n    const fieldEmpties = fields\n      .map((f) => {\n        const inst = instanceVarName(\"monoid\", getBaseType(f));\n        return `    ${f.name}: ${inst}.empty()`;\n      })\n      .join(\",\\n\");\n    const fieldCombines = fields\n      .map((f) => {\n        const inst = instanceVarName(\"monoid\", getBaseType(f));\n        return `    ${f.name}: ${inst}.combine(a.${f.name}, b.${f.name})`;\n      })\n      .join(\",\\n\");\n\n    return `\nconst ${varName}: Monoid<${typeName}> = {\n  empty: (): ${typeName} => ({\n${fieldEmpties}\n  }),\n  combine: (a: ${typeName}, b: ${typeName}): ${typeName} => ({\n${fieldCombines}\n  }),\n};\nMonoid.registerInstance<${typeName}>(\"${typeName}\", ${varName});\n`;\n  },\n\n  deriveSum(\n    _typeName: string,\n    _discriminant: string,\n    _variants: Array<{ tag: string; typeName: string }>,\n  ): string {\n    return `// Monoid cannot be auto-derived for sum types`;\n  },\n};\n\n// ============================================================================\n// Register all macros with the global registry\n// ============================================================================\n\nglobalRegistry.register(typeclassAttribute);\nglobalRegistry.register(instanceAttribute);\nglobalRegistry.register(derivingAttribute);\nglobalRegistry.register(summonMacro);\nglobalRegistry.register(extendMacro);\nglobalRegistry.register(showTCDerive);\nglobalRegistry.register(eqTCDerive);\nglobalRegistry.register(ordTCDerive);\nglobalRegistry.register(hashTCDerive);\nglobalRegistry.register(functorTCDerive);\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  typeclassRegistry,\n  instanceRegistry,\n  builtinDerivations,\n  TypeclassInfo,\n  TypeclassMethod,\n  InstanceInfo,\n  BuiltinTypeclassDerivation,\n  findInstance,\n  getTypeclass,\n  instanceVarName,\n  createTypeclassDeriveMacro,\n};\n","/**\n * typemacro esbuild plugin\n *\n * @example\n * ```ts\n * import esbuild from \"esbuild\";\n * import typemacro from \"typemacro/esbuild\";\n *\n * esbuild.build({\n *   plugins: [typemacro()],\n * });\n * ```\n */\n\nimport { unplugin, type TypeMacroPluginOptions } from \"./unplugin.js\";\n\nexport default unplugin.esbuild;\nexport type { TypeMacroPluginOptions };\n"],"mappings":"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","names":["ts","ts","ts","ts","ts","ts","uncapitalize","capitalize","getBaseType","uncapitalize","capitalize","getBaseType","code","stmts","getBaseType","createProgram"]}