/**
 * Tests for macro import cleanup
 *
 * Verifies that import declarations are correctly trimmed or removed
 * when their specifiers resolve to macros during expansion.
 *
 * These tests exercise the MacroTransformer's import tracking and cleanup
 * by running the full transformer pipeline against synthetic source files
 * with a real TypeScript program (needed for symbol resolution).
 */

import { describe, it, expect, beforeEach, afterEach } from "vitest";
import * as ts from "typescript";
import * as path from "path";
import * as fs from "fs";
import * as os from "os";
import { globalRegistry } from "../src/core/registry.js";
import { defineExpressionMacro } from "../src/core/registry.js";
import macroTransformerFactory from "../src/transforms/macro-transformer.js";

/**
 * Helper: compile a source string through the macro transformer and return
 * the printed output. Sets up a real TS program so that symbol resolution
 * (and therefore import tracking) works correctly.
 *
 * `extraFiles` can provide additional virtual files that the source can
 * import from (e.g., a macro placeholder module).
 */
function transformSource(
  source: string,
  extraFiles: Record<string, string> = {},
): string {
  // Write files to a temp directory so TS can resolve imports
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "typemacro-test-"));
  const mainFile = path.join(tmpDir, "input.ts");

  try {
    fs.writeFileSync(mainFile, source);

    const filePaths = [mainFile];
    for (const [name, content] of Object.entries(extraFiles)) {
      const filePath = path.join(tmpDir, name);
      const dir = path.dirname(filePath);
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(filePath, content);
      filePaths.push(filePath);
    }

    const options: ts.CompilerOptions = {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      strict: true,
      noEmit: true,
      baseUrl: tmpDir,
      paths: {
        typemacro: [path.join(tmpDir, "typemacro.ts")],
        "typemacro/*": [path.join(tmpDir, "typemacro/*.ts")],
      },
    };

    const program = ts.createProgram(filePaths, options);
    const sourceFile = program.getSourceFile(mainFile)!;
    expect(sourceFile).toBeDefined();

    const transformerFactory = macroTransformerFactory(program);
    const result = ts.transform(sourceFile, [transformerFactory]);
    const transformed = result.transformed[0];

    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const output = printer.printFile(transformed);

    result.dispose();
    return output;
  } finally {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  }
}

/**
 * Check whether the output contains an import from the given module.
 */
function hasImportFrom(output: string, moduleSpecifier: string): boolean {
  return output.includes(`from "${moduleSpecifier}"`);
}

/**
 * Extract the import specifier names from an import declaration string.
 * e.g., 'import { a, b } from "mod"' â†’ ["a", "b"]
 */
function getNamedImports(output: string, moduleSpecifier: string): string[] {
  const regex = new RegExp(
    `import\\s*\\{([^}]*)\\}\\s*from\\s*["']${moduleSpecifier.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}["']`,
  );
  const match = output.match(regex);
  if (!match) return [];
  return match[1]
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

describe("Macro import cleanup", () => {
  // We register a test macro that is module-scoped to "typemacro"
  let originalMacros: ReturnType<typeof globalRegistry.getAll>;

  beforeEach(() => {
    originalMacros = globalRegistry.getAll();
  });

  afterEach(() => {
    // Registry doesn't support selective removal, but the built-in macros
    // are already registered globally and persist across tests.
  });

  // Provide a typemacro placeholder module that exports `comptime`
  const typemacroModule = `
    export declare function comptime<T>(fn: () => T): T;
    export declare function someRuntimeFn(): void;
  `;

  describe("full import removal", () => {
    it("should remove an import when all specifiers are macros", () => {
      const source = `
        import { comptime } from "./typemacro";
        const x = comptime(() => 1 + 2);
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      // The comptime call should be expanded
      // The import should be removed since comptime is the only specifier
      expect(hasImportFrom(output, "./typemacro")).toBe(false);
    });

    it("should remove an import with renamed macro specifier", () => {
      const source = `
        import { comptime as ct } from "./typemacro";
        const x = ct(() => 42);
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      expect(hasImportFrom(output, "./typemacro")).toBe(false);
    });
  });

  describe("partial import trimming", () => {
    it("should keep non-macro specifiers when trimming", () => {
      const source = `
        import { comptime, someRuntimeFn } from "./typemacro";
        const x = comptime(() => 1 + 2);
        someRuntimeFn();
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      // Import should still exist but only with someRuntimeFn
      expect(hasImportFrom(output, "./typemacro")).toBe(true);
      const imports = getNamedImports(output, "./typemacro");
      expect(imports).not.toContain("comptime");
      expect(imports).toContain("someRuntimeFn");
    });

    it("should handle mixed macro and non-macro with rename", () => {
      const source = `
        import { comptime as ct, someRuntimeFn } from "./typemacro";
        const x = ct(() => 99);
        someRuntimeFn();
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      expect(hasImportFrom(output, "./typemacro")).toBe(true);
      const imports = getNamedImports(output, "./typemacro");
      // "comptime as ct" should be removed
      expect(imports).not.toContain("comptime");
      expect(imports).not.toContain("ct");
      expect(imports.some((i) => i.includes("comptime"))).toBe(false);
      expect(imports).toContain("someRuntimeFn");
    });
  });

  describe("side-effect imports", () => {
    it("should never remove side-effect-only imports", () => {
      const source = `
        import "./typemacro";
        const x = 1;
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      // Side-effect import should remain
      expect(output).toContain(`"./typemacro"`);
    });
  });

  describe("non-macro imports", () => {
    it("should leave non-macro imports untouched", () => {
      const source = `
        import { someRuntimeFn } from "./typemacro";
        someRuntimeFn();
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      expect(hasImportFrom(output, "./typemacro")).toBe(true);
      const imports = getNamedImports(output, "./typemacro");
      expect(imports).toContain("someRuntimeFn");
    });
  });

  describe("unused macro imports (no call)", () => {
    it("should keep macro imports that are imported but never called", () => {
      // If comptime is imported but never invoked, the transformer never
      // resolves it as a macro, so the import should remain (it's the
      // user's responsibility to remove unused imports via their linter).
      const source = `
        import { comptime } from "./typemacro";
        const x = 1;
      `;

      const output = transformSource(source, {
        "typemacro.ts": typemacroModule,
      });

      // Import should remain since comptime was never called (never resolved)
      expect(hasImportFrom(output, "./typemacro")).toBe(true);
    });
  });
});
