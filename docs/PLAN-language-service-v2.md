# Plan: Transform-First Language Service Plugin

## Current State

The current `@typesugar/ts-plugin` language service uses a **diagnostic suppression** approach:

- It looks at AST nodes and suppresses expected errors (like TS2304 "Cannot find name" for derived methods).
- **Problems:**
  - Intellisense doesn't work for generated methods (e.g., `p1.clone()`).
  - Cannot handle custom syntax like `|>` or `F<_>` natively in the editor.
  - Fragile and easily out-of-sync with actual macro behavior.

## The Goal

Move to a **transform-first** approach. The language service should intercept file reads, run the full typesugar pipeline (preprocessor + macros), and feed the _transformed_ code to TypeScript. Source maps are then used to map diagnostics, hovers, and completions back to the user's original source code.

## Architecture

```text
User Editor                                  TypeScript Server
┌──────────────┐                             ┌───────────────┐
│              │                             │               │
│ src/file.ts  │─ ─ ─ (1) Edit ─ ─ ─ ─ ─ ─ ─▶│ Language      │
│              │                             │ Service Host  │
└──────────────┘                             │               │
      ▲                                      └──────┬────────┘
      │                                             │
      │                                      (2) Intercept reads
      │                                             ▼
      │                                      ┌───────────────┐
      │ (5) Map positions                    │ ts-plugin     │
      │     back via                         │ VirtualHost   │
      │     SourceMap                        │               │
      │                                      └──────┬────────┘
      │                                             │
      │                                      (3) Preprocess +
      │                                          Transform
      │                                             ▼
      │                                      ┌───────────────┐
      └─ ─ ─ (4) Return Diagnostics ─ ─ ─ ─ ─│ Transformed   │
                 & Completions               │ Source (.ts)  │
                                             └───────────────┘
```

## Existing Infrastructure to Leverage

We already built the foundational blocks in `packages/transformer/src/`:

- `pipeline.ts`: Orchestrates preprocessing and macro expansion.
- `virtual-host.ts`: `VirtualCompilerHost` that serves preprocessed content.
- `position-mapper.ts`: Maps positions between original and transformed code.
- `source-map-utils.ts`: Composes source maps from multiple transform stages.

## Implementation Steps

### Step 1: Initialize Pipeline in Language Service

Update `packages/transformer/src/language-service.ts`:

- On `create()`, instantiate the `TransformationPipeline`.
- Hook into `info.languageServiceHost`.

### Step 2: Intercept File Reads

TypeScript asks the host for file contents via `getScriptSnapshot` and `getScriptVersion`.

- Override `getScriptSnapshot(fileName)`:
  - If it's a project file, run it through the `TransformationPipeline`.
  - Return a snapshot of the _transformed_ code.
- Cache aggressively to maintain editor performance.

### Step 3: Map Diagnostics Back to Original Source

TypeScript will return diagnostics for the _transformed_ code.

- Override `proxy.getSemanticDiagnostics` and `proxy.getSyntacticDiagnostics`.
- For each diagnostic, use `position-mapper.ts` to map the `start` and `length` back to the original source coordinates.
- If a diagnostic originates from code entirely generated by a macro (and thus has no valid original position), either map it to the macro invocation node or suppress it.

### Step 4: Map IDE Features (Hover, Completions, Go-to-Definition)

When the user asks for completions at position X in original code:

- Map original position X to transformed position Y.
- Ask the underlying Language Service for completions at position Y.
- Map the resulting completion item ranges back to original coordinates.

Override the following proxy methods:

- `getCompletionsAtPosition`
- `getHoverAtPosition`
- `getDefinitionAtPosition`
- `getQuickInfoAtPosition`

### Step 5: Handle Custom Syntax (`|>`, `::`, `F<_>`)

Because the preprocessor runs before TypeScript sees the file:

- The editor won't show syntax errors for `|>`.
- To get good completions _around_ custom syntax, the source maps must be highly accurate.

## Risks and Challenges

1. **Performance:** Running full macro expansion on every keystroke is too slow.
   - _Mitigation:_ The `TransformCache` must be rock-solid. Only re-transform files that actually changed.
2. **Source Map Accuracy:** If source maps are slightly off, completions pop up in the wrong place.
   - _Mitigation:_ Rely heavily on `magic-string` generated maps in the preprocessor and exact node mapping in the transformer.
3. **Ghost Errors:** Errors in macro-generated code might be confusing to users if they point to the macro invocation without explanation.
   - _Mitigation:_ Add custom diagnostic messages indicating "Error in macro expansion: ...".

## Testing Strategy

1. Create a mock Language Service Host.
2. Feed it a file with `@derive(Eq)`.
3. Request completions on an instance of the class and verify `.equals` is suggested.
4. Intentionally introduce a type error in a macro and verify the diagnostic maps back to the `@derive` decorator.
